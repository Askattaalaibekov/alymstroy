// libs =======================================================!function(e){function t(n){if(i[n])return i[n].exports;var o=i[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var i={};t.m=e,t.c=i,t.d=function(e,i,n){t.o(e,i)||Object.defineProperty(e,i,{configurable:!1,enumerable:!0,get:n})},t.n=function(e){var i=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(i,"a",i),i},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=0)}([function(e,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});for(var n=i(1),o=i.n(n),r=i(3),s=i.n(r),a={styles:"position: fixed; \t\ttop: 0px; \t\tleft: 0px; \t\tbottom: 0px; \t\tz-index: 999; \t\toverflow: auto; \t\tpadding: 1rem; \t\tcolor: #000; \t\tbackground-color: rgba(255, 255, 255, 0.9); \t\tfont-family: monospace;",uaobject:(new o.a).getResult(),screen:{"screen width":function(){return window.screen.width},"screen availWidth":function(){return window.screen.availWidth},"screen height":function(){return window.screen.height},"screen availHeight":function(){return window.screen.availHeight}},viewport:{"viewport width":function(){return window.innerWidth},"viewport height":function(){return window.innerHeight}},document:{"documentEl clientWidth":function(){return document.documentElement.clientWidth},"documentEl offsetWidth":function(){return document.documentElement.offsetWidth},"documentEl scrollWidth":function(){return document.documentElement.scrollWidth},"documentEl clientHeight":function(){return document.documentElement.clientHeight},"documentEl offsetHeight":function(){return document.documentElement.offsetHeight},"documentEl scrollHeight":function(){return document.documentElement.scrollHeight}},check_hash:function(){return"#debug"===window.location.hash},collect_uaobject:function(){var e=[];for(var t in a.uaobject)if("ua"!==a.uaobject[t]&&"object"==typeof a.uaobject[t]){e.push(t);for(var i in a.uaobject[t])e.push(i+": "+a.uaobject[t][i])}return e},collect_dimensions:function(){var e=[],t=["screen","viewport","document"];for(var i in t){var n=t[i];e.push(n);for(var o in a[n])e.push(o+": "+a[n][o]())}return e},append_html:function(){var e="",t="";e+='<div class="gcpi__uaobject">';for(var i=a.collect_uaobject(),n=0;n<i.length;n++)e+="<div>"+i[n]+"</div>",t+=i[n]+"\r\n";e+="</div>",e+='<div class="gcpi__groups">';for(var o=a.collect_dimensions(),r=0;r<o.length;r++)e+="<div>"+o[r]+"</div>",t+=o[r]+"\r\n";e+="</div>",e+='<button class="gcpi__close" type="button" >Close</button>',e+='<button class="gcpi__clipboard" data-clipboard-text="'+t+'" type="button" >Copy</button>';var c=document.createElement("div");c.className="gcpi",c.style.cssText=a.styles,c.innerHTML=e,document.body.appendChild(c),new s.a(".gcpi__clipboard")},update_on_resize:function(){for(var e="",t="",i=document.querySelector(".gcpi__groups"),n=document.querySelector(".gcpi__clipboard"),o=a.collect_uaobject(),r=0;r<o.length;r++)t+=o[r]+"\r\n";for(var s=a.collect_dimensions(),c=0;c<s.length;c++)e+="<div>"+s[c]+"</div>",t+=s[c]+"\r\n";i.innerHTML=e,n.dataset.clipboardText=t}},c=["load","hashchange"],l=0;l<c.length;l++)window.addEventListener(c[l],function(){a.check_hash()&&(a.append_html(),document.querySelector(".gcpi__close").addEventListener("click",function(){location.replace(location.href.replace("#debug",""))},!1))},!1);window.addEventListener("resize",function(){a.check_hash()&&a.update_on_resize()},!1)},function(e,t,i){var n;!function(o,r){"use strict";var s="model",a="name",c="type",l="vendor",u="version",d="mobile",f="tablet",h={extend:function(e,t){var i={};for(var n in e)t[n]&&t[n].length%2==0?i[n]=t[n].concat(e[n]):i[n]=e[n];return i},has:function(e,t){return"string"==typeof e&&-1!==t.toLowerCase().indexOf(e.toLowerCase())},lowerize:function(e){return e.toLowerCase()},major:function(e){return"string"==typeof e?e.replace(/[^\d\.]/g,"").split(".")[0]:void 0},trim:function(e){return e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")}},p={rgx:function(e,t){for(var i,n,o,r,s,a,c=0;c<t.length&&!s;){var l=t[c],u=t[c+1];for(i=n=0;i<l.length&&!s;)if(s=l[i++].exec(e))for(o=0;o<u.length;o++)a=s[++n],r=u[o],"object"==typeof r&&r.length>0?2==r.length?"function"==typeof r[1]?this[r[0]]=r[1].call(this,a):this[r[0]]=r[1]:3==r.length?"function"!=typeof r[1]||r[1].exec&&r[1].test?this[r[0]]=a?a.replace(r[1],r[2]):void 0:this[r[0]]=a?r[1].call(this,a,r[2]):void 0:4==r.length&&(this[r[0]]=a?r[3].call(this,a.replace(r[1],r[2])):void 0):this[r]=a||void 0;c+=2}},str:function(e,t){for(var i in t)if("object"==typeof t[i]&&t[i].length>0){for(var n=0;n<t[i].length;n++)if(h.has(t[i][n],e))return"?"===i?void 0:i}else if(h.has(t[i],e))return"?"===i?void 0:i;return e}},w={browser:{oldsafari:{version:{"1.0":"/8",1.2:"/1",1.3:"/3","2.0":"/412","2.0.2":"/416","2.0.3":"/417","2.0.4":"/419","?":"/"}}},device:{amazon:{model:{"Fire Phone":["SD","KF"]}},sprint:{model:{"Evo Shift 4G":"7373KT"},vendor:{HTC:"APA",Sprint:"Sprint"}}},os:{windows:{version:{ME:"4.90","NT 3.11":"NT3.51","NT 4.0":"NT4.0",2000:"NT 5.0",XP:["NT 5.1","NT 5.2"],Vista:"NT 6.0",7:"NT 6.1",8:"NT 6.2",8.1:"NT 6.3",10:["NT 6.4","NT 10.0"],RT:"ARM"}}}},m={browser:[[/(opera\smini)\/([\w\.-]+)/i,/(opera\s[mobiletab]+).+version\/([\w\.-]+)/i,/(opera).+version\/([\w\.]+)/i,/(opera)[\/\s]+([\w\.]+)/i],[a,u],[/(opios)[\/\s]+([\w\.]+)/i],[[a,"Opera Mini"],u],[/\s(opr)\/([\w\.]+)/i],[[a,"Opera"],u],[/(kindle)\/([\w\.]+)/i,/(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]+)*/i,/(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i,/(?:ms|\()(ie)\s([\w\.]+)/i,/(rekonq)\/([\w\.]+)*/i,/(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser)\/([\w\.-]+)/i],[a,u],[/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i],[[a,"IE"],u],[/(edge)\/((\d+)?[\w\.]+)/i],[a,u],[/(yabrowser)\/([\w\.]+)/i],[[a,"Yandex"],u],[/(puffin)\/([\w\.]+)/i],[[a,"Puffin"],u],[/((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i],[[a,"UCBrowser"],u],[/(comodo_dragon)\/([\w\.]+)/i],[[a,/_/g," "],u],[/(micromessenger)\/([\w\.]+)/i],[[a,"WeChat"],u],[/(QQ)\/([\d\.]+)/i],[a,u],[/m?(qqbrowser)[\/\s]?([\w\.]+)/i],[a,u],[/xiaomi\/miuibrowser\/([\w\.]+)/i],[u,[a,"MIUI Browser"]],[/;fbav\/([\w\.]+);/i],[u,[a,"Facebook"]],[/(headlesschrome) ([\w\.]+)/i],[u,[a,"Chrome Headless"]],[/\swv\).+(chrome)\/([\w\.]+)/i],[[a,/(.+)/,"$1 WebView"],u],[/((?:oculus|samsung)browser)\/([\w\.]+)/i],[[a,/(.+(?:g|us))(.+)/,"$1 $2"],u],[/android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i],[u,[a,"Android Browser"]],[/(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i],[a,u],[/(dolfin)\/([\w\.]+)/i],[[a,"Dolphin"],u],[/((?:android.+)crmo|crios)\/([\w\.]+)/i],[[a,"Chrome"],u],[/(coast)\/([\w\.]+)/i],[[a,"Opera Coast"],u],[/fxios\/([\w\.-]+)/i],[u,[a,"Firefox"]],[/version\/([\w\.]+).+?mobile\/\w+\s(safari)/i],[u,[a,"Mobile Safari"]],[/version\/([\w\.]+).+?(mobile\s?safari|safari)/i],[u,a],[/webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i],[a,[u,p.str,w.browser.oldsafari.version]],[/(konqueror)\/([\w\.]+)/i,/(webkit|khtml)\/([\w\.]+)/i],[a,u],[/(navigator|netscape)\/([\w\.-]+)/i],[[a,"Netscape"],u],[/(swiftfox)/i,/(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i,/(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix)\/([\w\.-]+)/i,/(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i,/(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i,/(links)\s\(([\w\.]+)/i,/(gobrowser)\/?([\w\.]+)*/i,/(ice\s?browser)\/v?([\w\._]+)/i,/(mosaic)[\/\s]([\w\.]+)/i],[a,u]],cpu:[[/(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i],[["architecture","amd64"]],[/(ia32(?=;))/i],[["architecture",h.lowerize]],[/((?:i[346]|x)86)[;\)]/i],[["architecture","ia32"]],[/windows\s(ce|mobile);\sppc;/i],[["architecture","arm"]],[/((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i],[["architecture",/ower/,"",h.lowerize]],[/(sun4\w)[;\)]/i],[["architecture","sparc"]],[/((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+;))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i],[["architecture",h.lowerize]]],device:[[/\((ipad|playbook);[\w\s\);-]+(rim|apple)/i],[s,l,[c,f]],[/applecoremedia\/[\w\.]+ \((ipad)/],[s,[l,"Apple"],[c,f]],[/(apple\s{0,1}tv)/i],[[s,"Apple TV"],[l,"Apple"]],[/(archos)\s(gamepad2?)/i,/(hp).+(touchpad)/i,/(hp).+(tablet)/i,/(kindle)\/([\w\.]+)/i,/\s(nook)[\w\s]+build\/(\w+)/i,/(dell)\s(strea[kpr\s\d]*[\dko])/i],[l,s,[c,f]],[/(kf[A-z]+)\sbuild\/[\w\.]+.*silk\//i],[s,[l,"Amazon"],[c,f]],[/(sd|kf)[0349hijorstuw]+\sbuild\/[\w\.]+.*silk\//i],[[s,p.str,w.device.amazon.model],[l,"Amazon"],[c,d]],[/\((ip[honed|\s\w*]+);.+(apple)/i],[s,l,[c,d]],[/\((ip[honed|\s\w*]+);/i],[s,[l,"Apple"],[c,d]],[/(blackberry)[\s-]?(\w+)/i,/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]+)*/i,/(hp)\s([\w\s]+\w)/i,/(asus)-?(\w+)/i],[l,s,[c,d]],[/\(bb10;\s(\w+)/i],[s,[l,"BlackBerry"],[c,d]],[/android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone)/i],[s,[l,"Asus"],[c,f]],[/(sony)\s(tablet\s[ps])\sbuild\//i,/(sony)?(?:sgp.+)\sbuild\//i],[[l,"Sony"],[s,"Xperia Tablet"],[c,f]],[/android.+\s([c-g]\d{4}|so[-l]\w+)\sbuild\//i],[s,[l,"Sony"],[c,d]],[/\s(ouya)\s/i,/(nintendo)\s([wids3u]+)/i],[l,s,[c,"console"]],[/android.+;\s(shield)\sbuild/i],[s,[l,"Nvidia"],[c,"console"]],[/(playstation\s[34portablevi]+)/i],[s,[l,"Sony"],[c,"console"]],[/(sprint\s(\w+))/i],[[l,p.str,w.device.sprint.vendor],[s,p.str,w.device.sprint.model],[c,d]],[/(lenovo)\s?(S(?:5000|6000)+(?:[-][\w+]))/i],[l,s,[c,f]],[/(htc)[;_\s-]+([\w\s]+(?=\))|\w+)*/i,/(zte)-(\w+)*/i,/(alcatel|geeksphone|lenovo|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]+)*/i],[l,[s,/_/g," "],[c,d]],[/(nexus\s9)/i],[s,[l,"HTC"],[c,f]],[/d\/huawei([\w\s-]+)[;\)]/i,/(nexus\s6p)/i],[s,[l,"Huawei"],[c,d]],[/(microsoft);\s(lumia[\s\w]+)/i],[l,s,[c,d]],[/[\s\(;](xbox(?:\sone)?)[\s\);]/i],[s,[l,"Microsoft"],[c,"console"]],[/(kin\.[onetw]{3})/i],[[s,/\./g," "],[l,"Microsoft"],[c,d]],[/\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?(:?\s4g)?)[\w\s]+build\//i,/mot[\s-]?(\w+)*/i,/(XT\d{3,4}) build\//i,/(nexus\s6)/i],[s,[l,"Motorola"],[c,d]],[/android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i],[s,[l,"Motorola"],[c,f]],[/hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i],[[l,h.trim],[s,h.trim],[c,"smarttv"]],[/hbbtv.+maple;(\d+)/i],[[s,/^/,"SmartTV"],[l,"Samsung"],[c,"smarttv"]],[/\(dtv[\);].+(aquos)/i],[s,[l,"Sharp"],[c,"smarttv"]],[/android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i,/((SM-T\w+))/i],[[l,"Samsung"],s,[c,f]],[/smart-tv.+(samsung)/i],[l,[c,"smarttv"],s],[/((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i,/(sam[sung]*)[\s-]*(\w+-?[\w-]*)*/i,/sec-((sgh\w+))/i],[[l,"Samsung"],s,[c,d]],[/sie-(\w+)*/i],[s,[l,"Siemens"],[c,d]],[/(maemo|nokia).*(n900|lumia\s\d+)/i,/(nokia)[\s_-]?([\w-]+)*/i],[[l,"Nokia"],s,[c,d]],[/android\s3\.[\s\w;-]{10}(a\d{3})/i],[s,[l,"Acer"],[c,f]],[/android.+([vl]k\-?\d{3})\s+build/i],[s,[l,"LG"],[c,f]],[/android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i],[[l,"LG"],s,[c,f]],[/(lg) netcast\.tv/i],[l,s,[c,"smarttv"]],[/(nexus\s[45])/i,/lg[e;\s\/-]+(\w+)*/i,/android.+lg(\-?[\d\w]+)\s+build/i],[s,[l,"LG"],[c,d]],[/android.+(ideatab[a-z0-9\-\s]+)/i],[s,[l,"Lenovo"],[c,f]],[/linux;.+((jolla));/i],[l,s,[c,d]],[/((pebble))app\/[\d\.]+\s/i],[l,s,[c,"wearable"]],[/android.+;\s(oppo)\s?([\w\s]+)\sbuild/i],[l,s,[c,d]],[/crkey/i],[[s,"Chromecast"],[l,"Google"]],[/android.+;\s(glass)\s\d/i],[s,[l,"Google"],[c,"wearable"]],[/android.+;\s(pixel c)\s/i],[s,[l,"Google"],[c,f]],[/android.+;\s(pixel xl|pixel)\s/i],[s,[l,"Google"],[c,d]],[/android.+(\w+)\s+build\/hm\1/i,/android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i,/android.+(mi[\s\-_]*(?:one|one[\s_]plus|note lte)?[\s_]*(?:\d\w)?)\s+build/i],[[s,/_/g," "],[l,"Xiaomi"],[c,d]],[/android.+;\s(m[1-5]\snote)\sbuild/i],[s,[l,"Meizu"],[c,f]],[/android.+a000(1)\s+build/i],[s,[l,"OnePlus"],[c,d]],[/android.+[;\/]\s*(RCT[\d\w]+)\s+build/i],[s,[l,"RCA"],[c,f]],[/android.+[;\/]\s*(Venue[\d\s]*)\s+build/i],[s,[l,"Dell"],[c,f]],[/android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i],[s,[l,"Verizon"],[c,f]],[/android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(V?.*)\s+build/i],[[l,"Barnes & Noble"],s,[c,f]],[/android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i],[s,[l,"NuVision"],[c,f]],[/android.+[;\/]\s*(zte)?.+(k\d{2})\s+build/i],[[l,"ZTE"],s,[c,f]],[/android.+[;\/]\s*(gen\d{3})\s+build.*49h/i],[s,[l,"Swiss"],[c,d]],[/android.+[;\/]\s*(zur\d{3})\s+build/i],[s,[l,"Swiss"],[c,f]],[/android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i],[s,[l,"Zeki"],[c,f]],[/(android).+[;\/]\s+([YR]\d{2}x?.*)\s+build/i,/android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(.+)\s+build/i],[[l,"Dragon Touch"],s,[c,f]],[/android.+[;\/]\s*(NS-?.+)\s+build/i],[s,[l,"Insignia"],[c,f]],[/android.+[;\/]\s*((NX|Next)-?.+)\s+build/i],[s,[l,"NextBook"],[c,f]],[/android.+[;\/]\s*(Xtreme\_?)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i],[[l,"Voice"],s,[c,d]],[/android.+[;\/]\s*(LVTEL\-?)?(V1[12])\s+build/i],[[l,"LvTel"],s,[c,d]],[/android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i],[s,[l,"Envizen"],[c,f]],[/android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(.*\b)\s+build/i],[l,s,[c,f]],[/android.+[;\/]\s*(Trio[\s\-]*.*)\s+build/i],[s,[l,"MachSpeed"],[c,f]],[/android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i],[l,s,[c,f]],[/android.+[;\/]\s*TU_(1491)\s+build/i],[s,[l,"Rotor"],[c,f]],[/android.+(KS(.+))\s+build/i],[s,[l,"Amazon"],[c,f]],[/android.+(Gigaset)[\s\-]+(Q.+)\s+build/i],[l,s,[c,f]],[/\s(tablet|tab)[;\/]/i,/\s(mobile)(?:[;\/]|\ssafari)/i],[[c,h.lowerize],l,s],[/(android.+)[;\/].+build/i],[s,[l,"Generic"]]],engine:[[/windows.+\sedge\/([\w\.]+)/i],[u,[a,"EdgeHTML"]],[/(presto)\/([\w\.]+)/i,/(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i,/(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i,/(icab)[\/\s]([23]\.[\d\.]+)/i],[a,u],[/rv\:([\w\.]+).*(gecko)/i],[u,a]],os:[[/microsoft\s(windows)\s(vista|xp)/i],[a,u],[/(windows)\snt\s6\.2;\s(arm)/i,/(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s]+\w)*/i,/(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i],[a,[u,p.str,w.os.windows.version]],[/(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i],[[a,"Windows"],[u,p.str,w.os.windows.version]],[/\((bb)(10);/i],[[a,"BlackBerry"],u],[/(blackberry)\w*\/?([\w\.]+)*/i,/(tizen)[\/\s]([\w\.]+)/i,/(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|contiki)[\/\s-]?([\w\.]+)*/i,/linux;.+(sailfish);/i],[a,u],[/(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]+)*/i],[[a,"Symbian"],u],[/\((series40);/i],[a],[/mozilla.+\(mobile;.+gecko.+firefox/i],[[a,"Firefox OS"],u],[/(nintendo|playstation)\s([wids34portablevu]+)/i,/(mint)[\/\s\(]?(\w+)*/i,/(mageia|vectorlinux)[;\s]/i,/(joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]+)*/i,/(hurd|linux)\s?([\w\.]+)*/i,/(gnu)\s?([\w\.]+)*/i],[a,u],[/(cros)\s[\w]+\s([\w\.]+\w)/i],[[a,"Chromium OS"],u],[/(sunos)\s?([\w\.]+\d)*/i],[[a,"Solaris"],u],[/\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]+)*/i],[a,u],[/(haiku)\s(\w+)/i],[a,u],[/cfnetwork\/.+darwin/i,/ip[honead]+(?:.*os\s([\w]+)*\slike\smac|;\sopera)/i],[[u,/_/g,"."],[a,"iOS"]],[/(mac\sos\sx)\s?([\w\s\.]+\w)*/i,/(macintosh|mac(?=_powerpc)\s)/i],[[a,"Mac OS"],[u,/_/g,"."]],[/((?:open)?solaris)[\/\s-]?([\w\.]+)*/i,/(aix)\s((\d)(?=\.|\)|\s)[\w\.]*)*/i,/(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms)/i,/(unix)\s?([\w\.]+)*/i],[a,u]]},b=function(e,t){this[a]=e,this[u]=t},v=function(e){this.architecture=e},g=function(e,t,i){this[l]=e,this[s]=t,this[c]=i},y=b,k=b,x=function(e,t){if("object"==typeof e&&(t=e,e=void 0),!(this instanceof x))return new x(e,t).getResult();var i=e||(o&&o.navigator&&o.navigator.userAgent?o.navigator.userAgent:""),n=t?h.extend(m,t):m,r=new b,s=new v,a=new g,c=new y,l=new k;return this.getBrowser=function(){return p.rgx.call(r,i,n.browser),r.major=h.major(r.version),r},this.getCPU=function(){return p.rgx.call(s,i,n.cpu),s},this.getDevice=function(){return p.rgx.call(a,i,n.device),a},this.getEngine=function(){return p.rgx.call(c,i,n.engine),c},this.getOS=function(){return p.rgx.call(l,i,n.os),l},this.getResult=function(){return{ua:this.getUA(),browser:this.getBrowser(),engine:this.getEngine(),os:this.getOS(),device:this.getDevice(),cpu:this.getCPU()}},this.getUA=function(){return i},this.setUA=function(e){return i=e,r=new b,s=new v,a=new g,c=new y,l=new k,this},this};x.VERSION="0.7.14",x.BROWSER={NAME:a,MAJOR:"major",VERSION:u},x.CPU={ARCHITECTURE:"architecture"},x.DEVICE={MODEL:s,VENDOR:l,TYPE:c,CONSOLE:"console",MOBILE:d,SMARTTV:"smarttv",TABLET:f,WEARABLE:"wearable",EMBEDDED:"embedded"},x.ENGINE={NAME:a,VERSION:u},x.OS={NAME:a,VERSION:u},void 0!==t?(void 0!==e&&e.exports&&(t=e.exports=x),t.UAParser=x):i(2)?void 0!==(n=function(){return x}.call(t,i,t,e))&&(e.exports=n):o&&(o.UAParser=x);var E=o&&(o.jQuery||o.Zepto);if(void 0!==E){var T=new x;E.ua=T.getResult(),E.ua.get=function(){return T.getUA()},E.ua.set=function(e){T.setUA(e);var t=T.getResult();for(var i in t)E.ua[i]=t[i]}}}("object"==typeof window?window:this)},function(e,t){(function(t){e.exports=t}).call(t,{})},function(e,t,i){var n,o,r;!function(s,a){o=[e,i(4),i(6),i(7)],n=a,void 0!==(r="function"==typeof n?n.apply(t,o):n)&&(e.exports=r)}(0,function(e,t,i,n){"use strict";function o(e){return e&&e.__esModule?e:{default:e}}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function s(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function a(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}function c(e,t){var i="data-clipboard-"+e;if(t.hasAttribute(i))return t.getAttribute(i)}var l=o(t),u=o(i),d=o(n),f="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},h=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),p=function(e){function t(e,i){r(this,t);var n=s(this,(t.__proto__||Object.getPrototypeOf(t)).call(this));return n.resolveOptions(i),n.listenClick(e),n}return a(t,e),h(t,[{key:"resolveOptions",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.action="function"==typeof e.action?e.action:this.defaultAction,this.target="function"==typeof e.target?e.target:this.defaultTarget,this.text="function"==typeof e.text?e.text:this.defaultText,this.container="object"===f(e.container)?e.container:document.body}},{key:"listenClick",value:function(e){var t=this;this.listener=(0,d.default)(e,"click",function(e){return t.onClick(e)})}},{key:"onClick",value:function(e){var t=e.delegateTarget||e.currentTarget;this.clipboardAction&&(this.clipboardAction=null),this.clipboardAction=new l.default({action:this.action(t),target:this.target(t),text:this.text(t),container:this.container,trigger:t,emitter:this})}},{key:"defaultAction",value:function(e){return c("action",e)}},{key:"defaultTarget",value:function(e){var t=c("target",e);if(t)return document.querySelector(t)}},{key:"defaultText",value:function(e){return c("text",e)}},{key:"destroy",value:function(){this.listener.destroy(),this.clipboardAction&&(this.clipboardAction.destroy(),this.clipboardAction=null)}}],[{key:"isSupported",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:["copy","cut"],t="string"==typeof e?[e]:e,i=!!document.queryCommandSupported;return t.forEach(function(e){i=i&&!!document.queryCommandSupported(e)}),i}}]),t}(u.default);e.exports=p})},function(e,t,i){var n,o,r;!function(s,a){o=[e,i(5)],n=a,void 0!==(r="function"==typeof n?n.apply(t,o):n)&&(e.exports=r)}(0,function(e,t){"use strict";function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}var n=function(e){return e&&e.__esModule?e:{default:e}}(t),o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},r=function(){function e(e,t){for(var i=0;i<t.length;i++){var n=t[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(t,i,n){return i&&e(t.prototype,i),n&&e(t,n),t}}(),s=function(){function e(t){i(this,e),this.resolveOptions(t),this.initSelection()}return r(e,[{key:"resolveOptions",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};this.action=e.action,this.container=e.container,this.emitter=e.emitter,this.target=e.target,this.text=e.text,this.trigger=e.trigger,this.selectedText=""}},{key:"initSelection",value:function(){this.text?this.selectFake():this.target&&this.selectTarget()}},{key:"selectFake",value:function(){var e=this,t="rtl"==document.documentElement.getAttribute("dir");this.removeFake(),this.fakeHandlerCallback=function(){return e.removeFake()},this.fakeHandler=this.container.addEventListener("click",this.fakeHandlerCallback)||!0,this.fakeElem=document.createElement("textarea"),this.fakeElem.style.fontSize="12pt",this.fakeElem.style.border="0",this.fakeElem.style.padding="0",this.fakeElem.style.margin="0",this.fakeElem.style.position="absolute",this.fakeElem.style[t?"right":"left"]="-9999px";var i=window.pageYOffset||document.documentElement.scrollTop;this.fakeElem.style.top=i+"px",this.fakeElem.setAttribute("readonly",""),this.fakeElem.value=this.text,this.container.appendChild(this.fakeElem),this.selectedText=(0,n.default)(this.fakeElem),this.copyText()}},{key:"removeFake",value:function(){this.fakeHandler&&(this.container.removeEventListener("click",this.fakeHandlerCallback),this.fakeHandler=null,this.fakeHandlerCallback=null),this.fakeElem&&(this.container.removeChild(this.fakeElem),this.fakeElem=null)}},{key:"selectTarget",value:function(){this.selectedText=(0,n.default)(this.target),this.copyText()}},{key:"copyText",value:function(){var e=void 0;try{e=document.execCommand(this.action)}catch(t){e=!1}this.handleResult(e)}},{key:"handleResult",value:function(e){this.emitter.emit(e?"success":"error",{action:this.action,text:this.selectedText,trigger:this.trigger,clearSelection:this.clearSelection.bind(this)})}},{key:"clearSelection",value:function(){this.trigger&&this.trigger.focus(),window.getSelection().removeAllRanges()}},{key:"destroy",value:function(){this.removeFake()}},{key:"action",set:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"copy";if(this._action=e,"copy"!==this._action&&"cut"!==this._action)throw new Error('Invalid "action" value, use either "copy" or "cut"')},get:function(){return this._action}},{key:"target",set:function(e){if(void 0!==e){if(!e||"object"!==(void 0===e?"undefined":o(e))||1!==e.nodeType)throw new Error('Invalid "target" value, use a valid Element');if("copy"===this.action&&e.hasAttribute("disabled"))throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');if("cut"===this.action&&(e.hasAttribute("readonly")||e.hasAttribute("disabled")))throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');this._target=e}},get:function(){return this._target}}]),e}();e.exports=s})},function(e,t){function i(e){var t;if("SELECT"===e.nodeName)e.focus(),t=e.value;else if("INPUT"===e.nodeName||"TEXTAREA"===e.nodeName){var i=e.hasAttribute("readonly");i||e.setAttribute("readonly",""),e.select(),e.setSelectionRange(0,e.value.length),i||e.removeAttribute("readonly"),t=e.value}else{e.hasAttribute("contenteditable")&&e.focus();var n=window.getSelection(),o=document.createRange();o.selectNodeContents(e),n.removeAllRanges(),n.addRange(o),t=n.toString()}return t}e.exports=i},function(e,t){function i(){}i.prototype={on:function(e,t,i){var n=this.e||(this.e={});return(n[e]||(n[e]=[])).push({fn:t,ctx:i}),this},once:function(e,t,i){function n(){o.off(e,n),t.apply(i,arguments)}var o=this;return n._=t,this.on(e,n,i)},emit:function(e){var t=[].slice.call(arguments,1),i=((this.e||(this.e={}))[e]||[]).slice(),n=0,o=i.length;for(n;n<o;n++)i[n].fn.apply(i[n].ctx,t);return this},off:function(e,t){var i=this.e||(this.e={}),n=i[e],o=[];if(n&&t)for(var r=0,s=n.length;r<s;r++)n[r].fn!==t&&n[r].fn._!==t&&o.push(n[r]);return o.length?i[e]=o:delete i[e],this}},e.exports=i},function(e,t,i){function n(e,t,i){if(!e&&!t&&!i)throw new Error("Missing required arguments");if(!a.string(t))throw new TypeError("Second argument must be a String");if(!a.fn(i))throw new TypeError("Third argument must be a Function");if(a.node(e))return o(e,t,i);if(a.nodeList(e))return r(e,t,i);if(a.string(e))return s(e,t,i);throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList")}function o(e,t,i){return e.addEventListener(t,i),{destroy:function(){e.removeEventListener(t,i)}}}function r(e,t,i){return Array.prototype.forEach.call(e,function(e){e.addEventListener(t,i)}),{destroy:function(){Array.prototype.forEach.call(e,function(e){e.removeEventListener(t,i)})}}}function s(e,t,i){return c(document.body,e,t,i)}var a=i(8),c=i(9);e.exports=n},function(e,t){t.node=function(e){return void 0!==e&&e instanceof HTMLElement&&1===e.nodeType},t.nodeList=function(e){var i=Object.prototype.toString.call(e);return void 0!==e&&("[object NodeList]"===i||"[object HTMLCollection]"===i)&&"length"in e&&(0===e.length||t.node(e[0]))},t.string=function(e){return"string"==typeof e||e instanceof String},t.fn=function(e){return"[object Function]"===Object.prototype.toString.call(e)}},function(e,t,i){function n(e,t,i,n,r){var s=o.apply(this,arguments);return e.addEventListener(i,s,r),{destroy:function(){e.removeEventListener(i,s,r)}}}function o(e,t,i,n){return function(i){i.delegateTarget=r(i.target,t),i.delegateTarget&&n.call(e,i)}}var r=i(10);e.exports=n},function(e,t){function i(e,t){for(;e&&e.nodeType!==n;){if("function"==typeof e.matches&&e.matches(t))return e;e=e.parentNode}}var n=9;if("undefined"!=typeof Element&&!Element.prototype.matches){var o=Element.prototype;o.matches=o.matchesSelector||o.mozMatchesSelector||o.msMatchesSelector||o.oMatchesSelector||o.webkitMatchesSelector}e.exports=i}]);/* npm.im/object-fit-images 3.2.3 */var objectFitImages=function(){"use strict";function t(t,e){return"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='"+t+"' height='"+e+"'%3E%3C/svg%3E"}function e(t){if(t.srcset&&!m&&window.picturefill){var e=window.picturefill._;t[e.ns]&&t[e.ns].evaled||e.fillImg(t,{reselect:!0}),t[e.ns].curSrc||(t[e.ns].supported=!1,e.fillImg(t,{reselect:!0})),t.currentSrc=t[e.ns].curSrc||t.src}}function i(t){for(var e,i=getComputedStyle(t).fontFamily,r={};null!==(e=l.exec(i));)r[e[1]]=e[2];return r}function r(e,i,r){var n=t(i||1,r||0);p.call(e,"src")!==n&&b.call(e,"src",n)}function n(t,e){t.naturalWidth?e(t):setTimeout(n,100,t,e)}function c(t){var c=i(t),o=t[a];if(c["object-fit"]=c["object-fit"]||"fill",!o.img){if("fill"===c["object-fit"])return;if(!o.skipTest&&g&&!c["object-position"])return}if(!o.img){o.img=new Image(t.width,t.height),o.img.srcset=p.call(t,"data-ofi-srcset")||t.srcset,o.img.src=p.call(t,"data-ofi-src")||t.src,b.call(t,"data-ofi-src",t.src),t.srcset&&b.call(t,"data-ofi-srcset",t.srcset),r(t,t.naturalWidth||t.width,t.naturalHeight||t.height),t.srcset&&(t.srcset="");try{s(t)}catch(t){window.console&&console.warn("https://bit.ly/ofi-old-browser")}}e(o.img),t.style.backgroundImage='url("'+(o.img.currentSrc||o.img.src).replace(/"/g,'\\"')+'")',t.style.backgroundPosition=c["object-position"]||"center",t.style.backgroundRepeat="no-repeat",t.style.backgroundOrigin="content-box",/scale-down/.test(c["object-fit"])?n(o.img,function(){o.img.naturalWidth>t.width||o.img.naturalHeight>t.height?t.style.backgroundSize="contain":t.style.backgroundSize="auto"}):t.style.backgroundSize=c["object-fit"].replace("none","auto").replace("fill","100% 100%"),n(o.img,function(e){r(t,e.naturalWidth,e.naturalHeight)})}function s(t){var e={get:function(e){return t[a].img[e||"src"]},set:function(e,i){return t[a].img[i||"src"]=e,b.call(t,"data-ofi-"+i,e),c(t),e}};Object.defineProperty(t,"src",e),Object.defineProperty(t,"currentSrc",{get:function(){return e.get("currentSrc")}}),Object.defineProperty(t,"srcset",{get:function(){return e.get("srcset")},set:function(t){return e.set(t,"srcset")}})}function o(t,e){var i=!h&&!t;if(e=e||{},t=t||"img",f&&!e.skipTest||!d)return!1;"img"===t?t=document.getElementsByTagName("img"):"string"==typeof t?t=document.querySelectorAll(t):"length"in t||(t=[t]);for(var r=0;r<t.length;r++)t[r][a]=t[r][a]||{skipTest:e.skipTest},c(t[r]);i&&(document.body.addEventListener("load",function(t){"IMG"===t.target.tagName&&o(t.target,{skipTest:e.skipTest})},!0),h=!0,t="img"),e.watchMQ&&window.addEventListener("resize",o.bind(null,t,{skipTest:e.skipTest}))}var a="bfred-it:object-fit-images",l=/(object-fit|object-position)\s*:\s*([-\w\s%]+)/g,u="undefined"==typeof Image?{style:{"object-position":1}}:new Image,g="object-fit"in u.style,f="object-position"in u.style,d="background-size"in u.style,m="string"==typeof u.currentSrc,p=u.getAttribute,b=u.setAttribute,h=!1;return o.supportsObjectFit=g,o.supportsObjectPosition=f,function(){function t(t,e){return t[a]&&t[a].img&&("src"===e||"srcset"===e)?t[a].img:t}f||(HTMLImageElement.prototype.getAttribute=function(e){return p.call(t(this,e),e)},HTMLImageElement.prototype.setAttribute=function(e,i){return b.call(t(this,e),e,String(i))})}(),o}();/*! * @copyright Copyright (c) 2017 IcoMoon.io * @license   Licensed under MIT license *            See https://github.com/Keyamoon/svgxuse * @version   1.2.6 */(function(){if("undefined"!==typeof window&&window.addEventListener){var e=Object.create(null),l,d=function(){clearTimeout(l);l=setTimeout(n,100)},m=function(){},t=function(){window.addEventListener("resize",d,!1);window.addEventListener("orientationchange",d,!1);if(window.MutationObserver){var k=new MutationObserver(d);k.observe(document.documentElement,{childList:!0,subtree:!0,attributes:!0});m=function(){try{k.disconnect(),window.removeEventListener("resize",d,!1),window.removeEventListener("orientationchange",d,!1)}catch(v){}}}else document.documentElement.addEventListener("DOMSubtreeModified",d,!1),m=function(){document.documentElement.removeEventListener("DOMSubtreeModified",d,!1);window.removeEventListener("resize",d,!1);window.removeEventListener("orientationchange",d,!1)}},u=function(k){function e(a){if(void 0!==a.protocol)var c=a;else c=document.createElement("a"),c.href=a;return c.protocol.replace(/:/g,"")+c.host}if(window.XMLHttpRequest){var d=new XMLHttpRequest;var m=e(location);k=e(k);d=void 0===d.withCredentials&&""!==k&&k!==m?XDomainRequest||void 0:XMLHttpRequest}return d};var n=function(){function d(){--q;0===q&&(m(),t())}function l(a){return function(){!0!==e[a.base]&&(a.useEl.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href","#"+a.hash),a.useEl.hasAttribute("href")&&a.useEl.setAttribute("href","#"+a.hash))}}function p(a){return function(){var c=document.body,b=document.createElement("x");a.onload=null;b.innerHTML=a.responseText;if(b=b.getElementsByTagName("svg")[0])b.setAttribute("aria-hidden","true"),b.style.position="absolute",b.style.width=0,b.style.height=0,b.style.overflow="hidden",c.insertBefore(b,c.firstChild);d()}}function n(a){return function(){a.onerror=null;a.ontimeout=null;d()}}var a,c,q=0;m();var f=document.getElementsByTagName("use");for(c=0;c<f.length;c+=1){try{var g=f[c].getBoundingClientRect()}catch(w){g=!1}var h=(a=f[c].getAttribute("href")||f[c].getAttributeNS("http://www.w3.org/1999/xlink","href")||f[c].getAttribute("xlink:href"))&&a.split?a.split("#"):["",""];var b=h[0];h=h[1];var r=g&&0===g.left&&0===g.right&&0===g.top&&0===g.bottom;g&&0===g.width&&0===g.height&&!r?(f[c].hasAttribute("href")&&f[c].setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",a),b.length&&(a=e[b],!0!==a&&setTimeout(l({useEl:f[c],base:b,hash:h}),0),void 0===a&&(h=u(b),void 0!==h&&(a=new h,e[b]=a,a.onload=p(a),a.onerror=n(a),a.ontimeout=n(a),a.open("GET",b),a.send(),q+=1)))):r?b.length&&e[b]&&setTimeout(l({useEl:f[c],base:b,hash:h}),0):void 0===e[b]?e[b]=!0:e[b].onload&&(e[b].abort(),delete e[b].onload,e[b]=!0)}f="";q+=1;d()};var p=function(){window.removeEventListener("load",p,!1);l=setTimeout(n,0)};"complete"!==document.readyState?window.addEventListener("load",p,!1):p()}})();/*!  * Bootstrap util.js v4.3.1 (https://getbootstrap.com/)  * Copyright 2011-2019 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)  */(function (global, factory) {    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('jquery')) :        typeof define === 'function' && define.amd ? define(['jquery'], factory) :            (global = global || self, global.Util = factory(global.jQuery));}(this, function ($) { 'use strict';    $ = $ && $.hasOwnProperty('default') ? $['default'] : $;    /**     * --------------------------------------------------------------------------     * Bootstrap (v4.3.1): util.js     * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)     * --------------------------------------------------------------------------     */    /**     * ------------------------------------------------------------------------     * Private TransitionEnd Helpers     * ------------------------------------------------------------------------     */    var TRANSITION_END = 'transitionend';    var MAX_UID = 1000000;    var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)    function toType(obj) {        return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();    }    function getSpecialTransitionEndEvent() {        return {            bindType: TRANSITION_END,            delegateType: TRANSITION_END,            handle: function handle(event) {                if ($(event.target).is(this)) {                    return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params                }                return undefined; // eslint-disable-line no-undefined            }        };    }    function transitionEndEmulator(duration) {        var _this = this;        var called = false;        $(this).one(Util.TRANSITION_END, function () {            called = true;        });        setTimeout(function () {            if (!called) {                Util.triggerTransitionEnd(_this);            }        }, duration);        return this;    }    function setTransitionEndSupport() {        $.fn.emulateTransitionEnd = transitionEndEmulator;        $.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();    }    /**     * --------------------------------------------------------------------------     * Public Util Api     * --------------------------------------------------------------------------     */    var Util = {        TRANSITION_END: 'bsTransitionEnd',        getUID: function getUID(prefix) {            do {                // eslint-disable-next-line no-bitwise                prefix += ~~(Math.random() * MAX_UID); // "~~" acts like a faster Math.floor() here            } while (document.getElementById(prefix));            return prefix;        },        getSelectorFromElement: function getSelectorFromElement(element) {            var selector = element.getAttribute('data-target');            if (!selector || selector === '#') {                var hrefAttr = element.getAttribute('href');                selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : '';            }            try {                return document.querySelector(selector) ? selector : null;            } catch (err) {                return null;            }        },        getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {            if (!element) {                return 0;            } // Get transition-duration of the element            var transitionDuration = $(element).css('transition-duration');            var transitionDelay = $(element).css('transition-delay');            var floatTransitionDuration = parseFloat(transitionDuration);            var floatTransitionDelay = parseFloat(transitionDelay); // Return 0 if element or transition duration is not found            if (!floatTransitionDuration && !floatTransitionDelay) {                return 0;            } // If multiple durations are defined, take the first            transitionDuration = transitionDuration.split(',')[0];            transitionDelay = transitionDelay.split(',')[0];            return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;        },        reflow: function reflow(element) {            return element.offsetHeight;        },        triggerTransitionEnd: function triggerTransitionEnd(element) {            $(element).trigger(TRANSITION_END);        },        // TODO: Remove in v5        supportsTransitionEnd: function supportsTransitionEnd() {            return Boolean(TRANSITION_END);        },        isElement: function isElement(obj) {            return (obj[0] || obj).nodeType;        },        typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {            for (var property in configTypes) {                if (Object.prototype.hasOwnProperty.call(configTypes, property)) {                    var expectedTypes = configTypes[property];                    var value = config[property];                    var valueType = value && Util.isElement(value) ? 'element' : toType(value);                    if (!new RegExp(expectedTypes).test(valueType)) {                        throw new Error(componentName.toUpperCase() + ": " + ("Option \"" + property + "\" provided type \"" + valueType + "\" ") + ("but expected type \"" + expectedTypes + "\"."));                    }                }            }        },        findShadowRoot: function findShadowRoot(element) {            if (!document.documentElement.attachShadow) {                return null;            } // Can find the shadow root otherwise it'll return the document            if (typeof element.getRootNode === 'function') {                var root = element.getRootNode();                return root instanceof ShadowRoot ? root : null;            }            if (element instanceof ShadowRoot) {                return element;            } // when we don't find a shadow root            if (!element.parentNode) {                return null;            }            return Util.findShadowRoot(element.parentNode);        }    };    setTransitionEndSupport();    return Util;}));//# sourceMappingURL=util.js.mapfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }/** * -------------------------------------------------------------------------- * Bootstrap (v4.0.0): modal.js * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * -------------------------------------------------------------------------- */var Modal = function ($) {  /**   * ------------------------------------------------------------------------   * Constants   * ------------------------------------------------------------------------   */  var NAME = 'modal';  var VERSION = '4.0.0';  var DATA_KEY = 'bs.modal';  var EVENT_KEY = "." + DATA_KEY;  var DATA_API_KEY = '.data-api';  var JQUERY_NO_CONFLICT = $.fn[NAME];  var TRANSITION_DURATION = 300;  var BACKDROP_TRANSITION_DURATION = 150;  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key  var Default = {    backdrop: true,    keyboard: true,    focus: true,    show: true  };  var DefaultType = {    backdrop: '(boolean|string)',    keyboard: 'boolean',    focus: 'boolean',    show: 'boolean'  };  var Event = {    HIDE: "hide" + EVENT_KEY,    HIDDEN: "hidden" + EVENT_KEY,    SHOW: "show" + EVENT_KEY,    SHOWN: "shown" + EVENT_KEY,    FOCUSIN: "focusin" + EVENT_KEY,    RESIZE: "resize" + EVENT_KEY,    CLICK_DISMISS: "click.dismiss" + EVENT_KEY,    KEYDOWN_DISMISS: "keydown.dismiss" + EVENT_KEY,    MOUSEUP_DISMISS: "mouseup.dismiss" + EVENT_KEY,    MOUSEDOWN_DISMISS: "mousedown.dismiss" + EVENT_KEY,    CLICK_DATA_API: "click" + EVENT_KEY + DATA_API_KEY  };  var ClassName = {    SCROLLBAR_MEASURER: 'modal-scrollbar-measure',    BACKDROP: 'modal-backdrop',    OPEN: 'modal-open',    FADE: 'fade',    SHOW: 'show'  };  var Selector = {    DIALOG: '.modal-dialog',    DATA_TOGGLE: '[data-toggle="modal"]',    DATA_DISMISS: '[data-dismiss="modal"]',    FIXED_CONTENT: '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top',    STICKY_CONTENT: '.sticky-top',    NAVBAR_TOGGLER: '.navbar-toggler'    /**     * ------------------------------------------------------------------------     * Class Definition     * ------------------------------------------------------------------------     */  };  var Modal =  /*#__PURE__*/  function () {    function Modal(element, config) {      this._config = this._getConfig(config);      this._element = element;      this._dialog = $(element).find(Selector.DIALOG)[0];      this._backdrop = null;      this._isShown = false;      this._isBodyOverflowing = false;      this._ignoreBackdropClick = false;      this._originalBodyPadding = 0;      this._scrollbarWidth = 0;    } // Getters    var _proto = Modal.prototype;    // Public    _proto.toggle = function toggle(relatedTarget) {      return this._isShown ? this.hide() : this.show(relatedTarget);    };    _proto.show = function show(relatedTarget) {      var _this = this;      if (this._isTransitioning || this._isShown) {        return;      }      if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE)) {        this._isTransitioning = true;      }      var showEvent = $.Event(Event.SHOW, {        relatedTarget: relatedTarget      });      $(this._element).trigger(showEvent);      if (this._isShown || showEvent.isDefaultPrevented()) {        return;      }      this._isShown = true;      this._checkScrollbar();      this._setScrollbar();      this._adjustDialog();      $(document.body).addClass(ClassName.OPEN);      this._setEscapeEvent();      this._setResizeEvent();      $(this._element).on(Event.CLICK_DISMISS, Selector.DATA_DISMISS, function (event) {        return _this.hide(event);      });      $(this._dialog).on(Event.MOUSEDOWN_DISMISS, function () {        $(_this._element).one(Event.MOUSEUP_DISMISS, function (event) {          if ($(event.target).is(_this._element)) {            _this._ignoreBackdropClick = true;          }        });      });      this._showBackdrop(function () {        return _this._showElement(relatedTarget);      });    };    _proto.hide = function hide(event) {      var _this2 = this;      if (event) {        event.preventDefault();      }      if (this._isTransitioning || !this._isShown) {        return;      }      var hideEvent = $.Event(Event.HIDE);      $(this._element).trigger(hideEvent);      if (!this._isShown || hideEvent.isDefaultPrevented()) {        return;      }      this._isShown = false;      var transition = Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE);      if (transition) {        this._isTransitioning = true;      }      this._setEscapeEvent();      this._setResizeEvent();      $(document).off(Event.FOCUSIN);      $(this._element).removeClass(ClassName.SHOW);      $(this._element).off(Event.CLICK_DISMISS);      $(this._dialog).off(Event.MOUSEDOWN_DISMISS);      if (transition) {        $(this._element).one(Util.TRANSITION_END, function (event) {          return _this2._hideModal(event);        }).emulateTransitionEnd(TRANSITION_DURATION);      } else {        this._hideModal();      }    };    _proto.dispose = function dispose() {      $.removeData(this._element, DATA_KEY);      $(window, document, this._element, this._backdrop).off(EVENT_KEY);      this._config = null;      this._element = null;      this._dialog = null;      this._backdrop = null;      this._isShown = null;      this._isBodyOverflowing = null;      this._ignoreBackdropClick = null;      this._scrollbarWidth = null;    };    _proto.handleUpdate = function handleUpdate() {      this._adjustDialog();    }; // Private    _proto._getConfig = function _getConfig(config) {      config = _extends({}, Default, config);      Util.typeCheckConfig(NAME, config, DefaultType);      return config;    };    _proto._showElement = function _showElement(relatedTarget) {      var _this3 = this;      var transition = Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE);      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {        // Don't move modal's DOM position        document.body.appendChild(this._element);      }      this._element.style.display = 'block';      this._element.removeAttribute('aria-hidden');      this._element.scrollTop = 0;      if (transition) {        Util.reflow(this._element);      }      $(this._element).addClass(ClassName.SHOW);      if (this._config.focus) {        this._enforceFocus();      }      var shownEvent = $.Event(Event.SHOWN, {        relatedTarget: relatedTarget      });      var transitionComplete = function transitionComplete() {        if (_this3._config.focus) {          _this3._element.focus();        }        _this3._isTransitioning = false;        $(_this3._element).trigger(shownEvent);      };      if (transition) {        $(this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(TRANSITION_DURATION);      } else {        transitionComplete();      }    };    _proto._enforceFocus = function _enforceFocus() {      var _this4 = this;      $(document).off(Event.FOCUSIN) // Guard against infinite focus loop      .on(Event.FOCUSIN, function (event) {        if (document !== event.target && _this4._element !== event.target && $(_this4._element).has(event.target).length === 0) {          _this4._element.focus();        }      });    };    _proto._setEscapeEvent = function _setEscapeEvent() {      var _this5 = this;      if (this._isShown && this._config.keyboard) {        $(this._element).on(Event.KEYDOWN_DISMISS, function (event) {          if (event.which === ESCAPE_KEYCODE) {            event.preventDefault();            _this5.hide();          }        });      } else if (!this._isShown) {        $(this._element).off(Event.KEYDOWN_DISMISS);      }    };    _proto._setResizeEvent = function _setResizeEvent() {      var _this6 = this;      if (this._isShown) {        $(window).on(Event.RESIZE, function (event) {          return _this6.handleUpdate(event);        });      } else {        $(window).off(Event.RESIZE);      }    };    _proto._hideModal = function _hideModal() {      var _this7 = this;      this._element.style.display = 'none';      this._element.setAttribute('aria-hidden', true);      this._isTransitioning = false;      this._showBackdrop(function () {        $(document.body).removeClass(ClassName.OPEN);        _this7._resetAdjustments();        _this7._resetScrollbar();        $(_this7._element).trigger(Event.HIDDEN);      });    };    _proto._removeBackdrop = function _removeBackdrop() {      if (this._backdrop) {        $(this._backdrop).remove();        this._backdrop = null;      }    };    _proto._showBackdrop = function _showBackdrop(callback) {      var _this8 = this;      var animate = $(this._element).hasClass(ClassName.FADE) ? ClassName.FADE : '';      if (this._isShown && this._config.backdrop) {        var doAnimate = Util.supportsTransitionEnd() && animate;        this._backdrop = document.createElement('div');        this._backdrop.className = ClassName.BACKDROP;        if (animate) {          $(this._backdrop).addClass(animate);        }        $(this._backdrop).appendTo(document.body);        $(this._element).on(Event.CLICK_DISMISS, function (event) {          if (_this8._ignoreBackdropClick) {            _this8._ignoreBackdropClick = false;            return;          }          if (event.target !== event.currentTarget) {            return;          }          if (_this8._config.backdrop === 'static') {            _this8._element.focus();          } else {            _this8.hide();          }        });        if (doAnimate) {          Util.reflow(this._backdrop);        }        $(this._backdrop).addClass(ClassName.SHOW);        if (!callback) {          return;        }        if (!doAnimate) {          callback();          return;        }        $(this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);      } else if (!this._isShown && this._backdrop) {        $(this._backdrop).removeClass(ClassName.SHOW);        var callbackRemove = function callbackRemove() {          _this8._removeBackdrop();          if (callback) {            callback();          }        };        if (Util.supportsTransitionEnd() && $(this._element).hasClass(ClassName.FADE)) {          $(this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(BACKDROP_TRANSITION_DURATION);        } else {          callbackRemove();        }      } else if (callback) {        callback();      }    }; // ----------------------------------------------------------------------    // the following methods are used to handle overflowing modals    // todo (fat): these should probably be refactored out of modal.js    // ----------------------------------------------------------------------    _proto._adjustDialog = function _adjustDialog() {      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;      if (!this._isBodyOverflowing && isModalOverflowing) {        this._element.style.paddingLeft = this._scrollbarWidth + "px";      }      if (this._isBodyOverflowing && !isModalOverflowing) {        this._element.style.paddingRight = this._scrollbarWidth + "px";      }    };    _proto._resetAdjustments = function _resetAdjustments() {      this._element.style.paddingLeft = '';      this._element.style.paddingRight = '';    };    _proto._checkScrollbar = function _checkScrollbar() {      var rect = document.body.getBoundingClientRect();      this._isBodyOverflowing = rect.left + rect.right < window.innerWidth;      this._scrollbarWidth = this._getScrollbarWidth();    };    _proto._setScrollbar = function _setScrollbar() {      var _this9 = this;      if (this._isBodyOverflowing) {        // Note: DOMNode.style.paddingRight returns the actual value or '' if not set        //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set        // Adjust fixed content padding        $(Selector.FIXED_CONTENT).each(function (index, element) {          var actualPadding = $(element)[0].style.paddingRight;          var calculatedPadding = $(element).css('padding-right');          $(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this9._scrollbarWidth + "px");        }); // Adjust sticky content margin        $(Selector.STICKY_CONTENT).each(function (index, element) {          var actualMargin = $(element)[0].style.marginRight;          var calculatedMargin = $(element).css('margin-right');          $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this9._scrollbarWidth + "px");        }); // Adjust navbar-toggler margin        $(Selector.NAVBAR_TOGGLER).each(function (index, element) {          var actualMargin = $(element)[0].style.marginRight;          var calculatedMargin = $(element).css('margin-right');          $(element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) + _this9._scrollbarWidth + "px");        }); // Adjust body padding        var actualPadding = document.body.style.paddingRight;        var calculatedPadding = $('body').css('padding-right');        $('body').data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + "px");      }    };    _proto._resetScrollbar = function _resetScrollbar() {      // Restore fixed content padding      $(Selector.FIXED_CONTENT).each(function (index, element) {        var padding = $(element).data('padding-right');        if (typeof padding !== 'undefined') {          $(element).css('padding-right', padding).removeData('padding-right');        }      }); // Restore sticky content and navbar-toggler margin      $(Selector.STICKY_CONTENT + ", " + Selector.NAVBAR_TOGGLER).each(function (index, element) {        var margin = $(element).data('margin-right');        if (typeof margin !== 'undefined') {          $(element).css('margin-right', margin).removeData('margin-right');        }      }); // Restore body padding      var padding = $('body').data('padding-right');      if (typeof padding !== 'undefined') {        $('body').css('padding-right', padding).removeData('padding-right');      }    };    _proto._getScrollbarWidth = function _getScrollbarWidth() {      // thx d.walsh      var scrollDiv = document.createElement('div');      scrollDiv.className = ClassName.SCROLLBAR_MEASURER;      document.body.appendChild(scrollDiv);      var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;      document.body.removeChild(scrollDiv);      return scrollbarWidth;    }; // Static    Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {      return this.each(function () {        var data = $(this).data(DATA_KEY);        var _config = _extends({}, Modal.Default, $(this).data(), typeof config === 'object' && config);        if (!data) {          data = new Modal(this, _config);          $(this).data(DATA_KEY, data);        }        if (typeof config === 'string') {          if (typeof data[config] === 'undefined') {            throw new TypeError("No method named \"" + config + "\"");          }          data[config](relatedTarget);        } else if (_config.show) {          data.show(relatedTarget);        }      });    };    _createClass(Modal, null, [{      key: "VERSION",      get: function get() {        return VERSION;      }    }, {      key: "Default",      get: function get() {        return Default;      }    }]);    return Modal;  }();  /**   * ------------------------------------------------------------------------   * Data Api implementation   * ------------------------------------------------------------------------   */  $(document).on(Event.CLICK_DATA_API, Selector.DATA_TOGGLE, function (event) {    var _this10 = this;    var target;    var selector = Util.getSelectorFromElement(this);    if (selector) {      target = $(selector)[0];    }    var config = $(target).data(DATA_KEY) ? 'toggle' : _extends({}, $(target).data(), $(this).data());    if (this.tagName === 'A' || this.tagName === 'AREA') {      event.preventDefault();    }    var $target = $(target).one(Event.SHOW, function (showEvent) {      if (showEvent.isDefaultPrevented()) {        // Only register focus restorer if modal will actually get shown        return;      }      $target.one(Event.HIDDEN, function () {        if ($(_this10).is(':visible')) {          _this10.focus();        }      });    });    Modal._jQueryInterface.call($(target), config, this);  });  /**   * ------------------------------------------------------------------------   * jQuery   * ------------------------------------------------------------------------   */  $.fn[NAME] = Modal._jQueryInterface;  $.fn[NAME].Constructor = Modal;  $.fn[NAME].noConflict = function () {    $.fn[NAME] = JQUERY_NO_CONFLICT;    return Modal._jQueryInterface;  };  return Modal;}($);//# sourceMappingURL=modal.js.map/*!  * Bootstrap scrollspy.js v4.3.1 (https://getbootstrap.com/)  * Copyright 2011-2019 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)  */(function (global, factory) {  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('jquery'), require('./util.js')) :  typeof define === 'function' && define.amd ? define(['jquery', './util.js'], factory) :  (global = global || self, global.ScrollSpy = factory(global.jQuery, global.Util));}(this, function ($, Util) { 'use strict';  $ = $ && $.hasOwnProperty('default') ? $['default'] : $;  Util = Util && Util.hasOwnProperty('default') ? Util['default'] : Util;  function _defineProperties(target, props) {    for (var i = 0; i < props.length; i++) {      var descriptor = props[i];      descriptor.enumerable = descriptor.enumerable || false;      descriptor.configurable = true;      if ("value" in descriptor) descriptor.writable = true;      Object.defineProperty(target, descriptor.key, descriptor);    }  }  function _createClass(Constructor, protoProps, staticProps) {    if (protoProps) _defineProperties(Constructor.prototype, protoProps);    if (staticProps) _defineProperties(Constructor, staticProps);    return Constructor;  }  function _defineProperty(obj, key, value) {    if (key in obj) {      Object.defineProperty(obj, key, {        value: value,        enumerable: true,        configurable: true,        writable: true      });    } else {      obj[key] = value;    }    return obj;  }  function _objectSpread(target) {    for (var i = 1; i < arguments.length; i++) {      var source = arguments[i] != null ? arguments[i] : {};      var ownKeys = Object.keys(source);      if (typeof Object.getOwnPropertySymbols === 'function') {        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {          return Object.getOwnPropertyDescriptor(source, sym).enumerable;        }));      }      ownKeys.forEach(function (key) {        _defineProperty(target, key, source[key]);      });    }    return target;  }  /**   * ------------------------------------------------------------------------   * Constants   * ------------------------------------------------------------------------   */  var NAME = 'scrollspy';  var VERSION = '4.3.1';  var DATA_KEY = 'bs.scrollspy';  var EVENT_KEY = "." + DATA_KEY;  var DATA_API_KEY = '.data-api';  var JQUERY_NO_CONFLICT = $.fn[NAME];  var Default = {    offset: 10,    method: 'auto',    target: ''  };  var DefaultType = {    offset: 'number',    method: 'string',    target: '(string|element)'  };  var Event = {    ACTIVATE: "activate" + EVENT_KEY,    SCROLL: "scroll" + EVENT_KEY,    LOAD_DATA_API: "load" + EVENT_KEY + DATA_API_KEY  };  var ClassName = {    DROPDOWN_ITEM: 'dropdown-item',    DROPDOWN_MENU: 'dropdown-menu',    ACTIVE: 'active'  };  var Selector = {    DATA_SPY: '[data-spy="scroll"]',    ACTIVE: '.active',    NAV_LIST_GROUP: '.nav, .list-group',    NAV_LINKS: '.nav-link, .menu__link',    NAV_ITEMS: '.nav-item, .menu__item',    LIST_ITEMS: '.list-group-item',    DROPDOWN: '.dropdown',    DROPDOWN_ITEMS: '.dropdown-item',    DROPDOWN_TOGGLE: '.dropdown-toggle'  };  var OffsetMethod = {    OFFSET: 'offset',    POSITION: 'position'    /**     * ------------------------------------------------------------------------     * Class Definition     * ------------------------------------------------------------------------     */  };  var ScrollSpy =  /*#__PURE__*/  function () {    function ScrollSpy(element, config) {      var _this = this;      this._element = element;      this._scrollElement = element.tagName === 'BODY' ? window : element;      this._config = this._getConfig(config);      this._selector = this._config.target + " " + Selector.NAV_LINKS + "," + (this._config.target + " " + Selector.LIST_ITEMS + ",") + (this._config.target + " " + Selector.DROPDOWN_ITEMS);      this._offsets = [];      this._targets = [];      this._activeTarget = null;      this._scrollHeight = 0;      $(this._scrollElement).on(Event.SCROLL, function (event) {        return _this._process(event);      });      this.refresh();      this._process();    } // Getters    var _proto = ScrollSpy.prototype;    // Public    _proto.refresh = function refresh() {      var _this2 = this;      var autoMethod = this._scrollElement === this._scrollElement.window ? OffsetMethod.OFFSET : OffsetMethod.POSITION;      var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;      var offsetBase = offsetMethod === OffsetMethod.POSITION ? this._getScrollTop() : 0;      this._offsets = [];      this._targets = [];      this._scrollHeight = this._getScrollHeight();      var targets = [].slice.call(document.querySelectorAll(this._selector));      targets.map(function (element) {        var target;        var targetSelector = Util.getSelectorFromElement(element);        if (targetSelector) {          target = document.querySelector(targetSelector);        }        if (target) {          var targetBCR = target.getBoundingClientRect();          if (targetBCR.width || targetBCR.height) {            // TODO (fat): remove sketch reliance on jQuery position/offset            return [$(target)[offsetMethod]().top + offsetBase, targetSelector];          }        }        return null;      }).filter(function (item) {        return item;      }).sort(function (a, b) {        return a[0] - b[0];      }).forEach(function (item) {        _this2._offsets.push(item[0]);        _this2._targets.push(item[1]);      });    };    _proto.dispose = function dispose() {      $.removeData(this._element, DATA_KEY);      $(this._scrollElement).off(EVENT_KEY);      this._element = null;      this._scrollElement = null;      this._config = null;      this._selector = null;      this._offsets = null;      this._targets = null;      this._activeTarget = null;      this._scrollHeight = null;    } // Private    ;    _proto._getConfig = function _getConfig(config) {      config = _objectSpread({}, Default, typeof config === 'object' && config ? config : {});      if (typeof config.target !== 'string') {        var id = $(config.target).attr('id');        if (!id) {          id = Util.getUID(NAME);          $(config.target).attr('id', id);        }        config.target = "#" + id;      }      Util.typeCheckConfig(NAME, config, DefaultType);      return config;    };    _proto._getScrollTop = function _getScrollTop() {      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;    };    _proto._getScrollHeight = function _getScrollHeight() {      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);    };    _proto._getOffsetHeight = function _getOffsetHeight() {      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;    };    _proto._process = function _process() {      var scrollTop = this._getScrollTop() + this._config.offset;      var scrollHeight = this._getScrollHeight();      var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();      if (this._scrollHeight !== scrollHeight) {        this.refresh();      }      if (scrollTop >= maxScroll) {        var target = this._targets[this._targets.length - 1];        if (this._activeTarget !== target) {          this._activate(target);        }        return;      }      if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {        this._activeTarget = null;        this._clear();        return;      }      var offsetLength = this._offsets.length;      for (var i = offsetLength; i--;) {        var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);        if (isActiveTarget) {          this._activate(this._targets[i]);        }      }    };    _proto._activate = function _activate(target) {      this._activeTarget = target;      this._clear();      var queries = this._selector.split(',').map(function (selector) {        return selector + "[data-target=\"" + target + "\"]," + selector + "[href=\"" + target + "\"]";      });      var $link = $([].slice.call(document.querySelectorAll(queries.join(','))));      if ($link.hasClass(ClassName.DROPDOWN_ITEM)) {        $link.closest(Selector.DROPDOWN).find(Selector.DROPDOWN_TOGGLE).addClass(ClassName.ACTIVE);        $link.addClass(ClassName.ACTIVE);      } else {        // Set triggered link as active        $link.addClass(ClassName.ACTIVE); // Set triggered links parents as active        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor        $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_LINKS + ", " + Selector.LIST_ITEMS).addClass(ClassName.ACTIVE); // Handle special case when .nav-link is inside .nav-item        $link.parents(Selector.NAV_LIST_GROUP).prev(Selector.NAV_ITEMS).children(Selector.NAV_LINKS).addClass(ClassName.ACTIVE);      }      $(this._scrollElement).trigger(Event.ACTIVATE, {        relatedTarget: target      });    };    _proto._clear = function _clear() {      [].slice.call(document.querySelectorAll(this._selector)).filter(function (node) {        return node.classList.contains(ClassName.ACTIVE);      }).forEach(function (node) {        return node.classList.remove(ClassName.ACTIVE);      });    } // Static    ;    ScrollSpy._jQueryInterface = function _jQueryInterface(config) {      return this.each(function () {        var data = $(this).data(DATA_KEY);        var _config = typeof config === 'object' && config;        if (!data) {          data = new ScrollSpy(this, _config);          $(this).data(DATA_KEY, data);        }        if (typeof config === 'string') {          if (typeof data[config] === 'undefined') {            throw new TypeError("No method named \"" + config + "\"");          }          data[config]();        }      });    };    _createClass(ScrollSpy, null, [{      key: "VERSION",      get: function get() {        return VERSION;      }    }, {      key: "Default",      get: function get() {        return Default;      }    }]);    return ScrollSpy;  }();  /**   * ------------------------------------------------------------------------   * Data Api implementation   * ------------------------------------------------------------------------   */  $(window).on(Event.LOAD_DATA_API, function () {    var scrollSpys = [].slice.call(document.querySelectorAll(Selector.DATA_SPY));    var scrollSpysLength = scrollSpys.length;    for (var i = scrollSpysLength; i--;) {      var $spy = $(scrollSpys[i]);      ScrollSpy._jQueryInterface.call($spy, $spy.data());    }  });  /**   * ------------------------------------------------------------------------   * jQuery   * ------------------------------------------------------------------------   */  $.fn[NAME] = ScrollSpy._jQueryInterface;  $.fn[NAME].Constructor = ScrollSpy;  $.fn[NAME].noConflict = function () {    $.fn[NAME] = JQUERY_NO_CONFLICT;    return ScrollSpy._jQueryInterface;  };  return ScrollSpy;}));//# sourceMappingURL=scrollspy.js.map/* lazysizes - v4.1.5 */!function(a,b){var c=b(a,a.document);a.lazySizes=c,"object"==typeof module&&module.exports&&(module.exports=c)}(window,function(a,b){"use strict";if(b.getElementsByClassName){var c,d,e=b.documentElement,f=a.Date,g=a.HTMLPictureElement,h="addEventListener",i="getAttribute",j=a[h],k=a.setTimeout,l=a.requestAnimationFrame||k,m=a.requestIdleCallback,n=/^picture$/i,o=["load","error","lazyincluded","_lazyloaded"],p={},q=Array.prototype.forEach,r=function(a,b){return p[b]||(p[b]=new RegExp("(\\s|^)"+b+"(\\s|$)")),p[b].test(a[i]("class")||"")&&p[b]},s=function(a,b){r(a,b)||a.setAttribute("class",(a[i]("class")||"").trim()+" "+b)},t=function(a,b){var c;(c=r(a,b))&&a.setAttribute("class",(a[i]("class")||"").replace(c," "))},u=function(a,b,c){var d=c?h:"removeEventListener";c&&u(a,b),o.forEach(function(c){a[d](c,b)})},v=function(a,d,e,f,g){var h=b.createEvent("Event");return e||(e={}),e.instance=c,h.initEvent(d,!f,!g),h.detail=e,a.dispatchEvent(h),h},w=function(b,c){var e;!g&&(e=a.picturefill||d.pf)?(c&&c.src&&!b[i]("srcset")&&b.setAttribute("srcset",c.src),e({reevaluate:!0,elements:[b]})):c&&c.src&&(b.src=c.src)},x=function(a,b){return(getComputedStyle(a,null)||{})[b]},y=function(a,b,c){for(c=c||a.offsetWidth;c<d.minSize&&b&&!a._lazysizesWidth;)c=b.offsetWidth,b=b.parentNode;return c},z=function(){var a,c,d=[],e=[],f=d,g=function(){var b=f;for(f=d.length?e:d,a=!0,c=!1;b.length;)b.shift()();a=!1},h=function(d,e){a&&!e?d.apply(this,arguments):(f.push(d),c||(c=!0,(b.hidden?k:l)(g)))};return h._lsFlush=g,h}(),A=function(a,b){return b?function(){z(a)}:function(){var b=this,c=arguments;z(function(){a.apply(b,c)})}},B=function(a){var b,c=0,e=d.throttleDelay,g=d.ricTimeout,h=function(){b=!1,c=f.now(),a()},i=m&&g>49?function(){m(h,{timeout:g}),g!==d.ricTimeout&&(g=d.ricTimeout)}:A(function(){k(h)},!0);return function(a){var d;(a=!0===a)&&(g=33),b||(b=!0,d=e-(f.now()-c),d<0&&(d=0),a||d<9?i():k(i,d))}},C=function(a){var b,c,d=99,e=function(){b=null,a()},g=function(){var a=f.now()-c;a<d?k(g,d-a):(m||e)(e)};return function(){c=f.now(),b||(b=k(g,d))}};!function(){var b,c={lazyClass:"lazyload",loadedClass:"lazyloaded",loadingClass:"lazyloading",preloadClass:"lazypreload",errorClass:"lazyerror",autosizesClass:"lazyautosizes",srcAttr:"data-src",srcsetAttr:"data-srcset",sizesAttr:"data-sizes",minSize:40,customMedia:{},init:!0,expFactor:1.5,hFac:.8,loadMode:2,loadHidden:!0,ricTimeout:0,throttleDelay:125};d=a.lazySizesConfig||a.lazysizesConfig||{};for(b in c)b in d||(d[b]=c[b]);a.lazySizesConfig=d,k(function(){d.init&&F()})}();var D=function(){var g,l,m,o,p,y,D,F,G,H,I,J=/^img$/i,K=/^iframe$/i,L="onscroll"in a&&!/(gle|ing)bot/.test(navigator.userAgent),M=0,N=0,O=0,P=-1,Q=function(a){O--,a&&a.target&&u(a.target,Q),(!a||O<0||!a.target)&&(O=0)},R=function(a,c){var d,f=a,g="hidden"==x(b.body,"visibility")||"hidden"!=x(a.parentNode,"visibility")&&"hidden"!=x(a,"visibility");for(F-=c,I+=c,G-=c,H+=c;g&&(f=f.offsetParent)&&f!=b.body&&f!=e;)(g=(x(f,"opacity")||1)>0)&&"visible"!=x(f,"overflow")&&(d=f.getBoundingClientRect(),g=H>d.left&&G<d.right&&I>d.top-1&&F<d.bottom+1);return g},S=function(){var a,f,h,j,k,m,n,p,q,r,s,t,u=c.elements;if((o=d.loadMode)&&O<8&&(a=u.length)){for(f=0,P++,r=!d.expand||d.expand<1?e.clientHeight>500&&e.clientWidth>500?500:370:d.expand,s=r*d.expFactor,t=d.hFac,N<s&&O<1&&P>2&&o>2&&!b.hidden?(N=s,P=0):N=o>1&&P>1&&O<6?r:M;f<a;f++)if(u[f]&&!u[f]._lazyRace)if(L)if((p=u[f][i]("data-expand"))&&(m=1*p)||(m=N),q!==m&&(y=innerWidth+m*t,D=innerHeight+m,n=-1*m,q=m),h=u[f].getBoundingClientRect(),(I=h.bottom)>=n&&(F=h.top)<=D&&(H=h.right)>=n*t&&(G=h.left)<=y&&(I||H||G||F)&&(d.loadHidden||"hidden"!=x(u[f],"visibility"))&&(l&&O<3&&!p&&(o<3||P<4)||R(u[f],m))){if($(u[f]),k=!0,O>9)break}else!k&&l&&!j&&O<4&&P<4&&o>2&&(g[0]||d.preloadAfterLoad)&&(g[0]||!p&&(I||H||G||F||"auto"!=u[f][i](d.sizesAttr)))&&(j=g[0]||u[f]);else $(u[f]);j&&!k&&$(j)}},T=B(S),U=function(a){s(a.target,d.loadedClass),t(a.target,d.loadingClass),u(a.target,W),v(a.target,"lazyloaded")},V=A(U),W=function(a){V({target:a.target})},X=function(a,b){try{a.contentWindow.location.replace(b)}catch(c){a.src=b}},Y=function(a){var b,c=a[i](d.srcsetAttr);(b=d.customMedia[a[i]("data-media")||a[i]("media")])&&a.setAttribute("media",b),c&&a.setAttribute("srcset",c)},Z=A(function(a,b,c,e,f){var g,h,j,l,o,p;(o=v(a,"lazybeforeunveil",b)).defaultPrevented||(e&&(c?s(a,d.autosizesClass):a.setAttribute("sizes",e)),h=a[i](d.srcsetAttr),g=a[i](d.srcAttr),f&&(j=a.parentNode,l=j&&n.test(j.nodeName||"")),p=b.firesLoad||"src"in a&&(h||g||l),o={target:a},p&&(u(a,Q,!0),clearTimeout(m),m=k(Q,2500),s(a,d.loadingClass),u(a,W,!0)),l&&q.call(j.getElementsByTagName("source"),Y),h?a.setAttribute("srcset",h):g&&!l&&(K.test(a.nodeName)?X(a,g):a.src=g),f&&(h||l)&&w(a,{src:g})),a._lazyRace&&delete a._lazyRace,t(a,d.lazyClass),z(function(){(!p||a.complete&&a.naturalWidth>1)&&(p?Q(o):O--,U(o))},!0)}),$=function(a){var b,c=J.test(a.nodeName),e=c&&(a[i](d.sizesAttr)||a[i]("sizes")),f="auto"==e;(!f&&l||!c||!a[i]("src")&&!a.srcset||a.complete||r(a,d.errorClass)||!r(a,d.lazyClass))&&(b=v(a,"lazyunveilread").detail,f&&E.updateElem(a,!0,a.offsetWidth),a._lazyRace=!0,O++,Z(a,b,f,e,c))},_=function(){if(!l){if(f.now()-p<999)return void k(_,999);var a=C(function(){d.loadMode=3,T()});l=!0,d.loadMode=3,T(),j("scroll",function(){3==d.loadMode&&(d.loadMode=2),a()},!0)}};return{_:function(){p=f.now(),c.elements=b.getElementsByClassName(d.lazyClass),g=b.getElementsByClassName(d.lazyClass+" "+d.preloadClass),j("scroll",T,!0),j("resize",T,!0),a.MutationObserver?new MutationObserver(T).observe(e,{childList:!0,subtree:!0,attributes:!0}):(e[h]("DOMNodeInserted",T,!0),e[h]("DOMAttrModified",T,!0),setInterval(T,999)),j("hashchange",T,!0),["focus","mouseover","click","load","transitionend","animationend","webkitAnimationEnd"].forEach(function(a){b[h](a,T,!0)}),/d$|^c/.test(b.readyState)?_():(j("load",_),b[h]("DOMContentLoaded",T),k(_,2e4)),c.elements.length?(S(),z._lsFlush()):T()},checkElems:T,unveil:$}}(),E=function(){var a,c=A(function(a,b,c,d){var e,f,g;if(a._lazysizesWidth=d,d+="px",a.setAttribute("sizes",d),n.test(b.nodeName||""))for(e=b.getElementsByTagName("source"),f=0,g=e.length;f<g;f++)e[f].setAttribute("sizes",d);c.detail.dataAttr||w(a,c.detail)}),e=function(a,b,d){var e,f=a.parentNode;f&&(d=y(a,f,d),e=v(a,"lazybeforesizes",{width:d,dataAttr:!!b}),e.defaultPrevented||(d=e.detail.width)&&d!==a._lazysizesWidth&&c(a,f,e,d))},f=function(){var b,c=a.length;if(c)for(b=0;b<c;b++)e(a[b])},g=C(f);return{_:function(){a=b.getElementsByClassName(d.autosizesClass),j("resize",g)},checkElems:g,updateElem:e}}(),F=function(){F.i||(F.i=!0,E._(),D._())};return c={cfg:d,autoSizer:E,loader:D,init:F,uP:w,aC:s,rC:t,hC:r,fire:v,gW:y,rAF:z}}});/*! lightgallery - v1.6.11 - 2018-05-22* http://sachinchoolur.github.io/lightGallery/* Copyright (c) 2018 Sachin N; Licensed GPLv3 *//*! lightgallery - v1.6.11 - 2018-05-22* http://sachinchoolur.github.io/lightGallery/* Copyright (c) 2018 Sachin N; Licensed GPLv3 */(function (root, factory) {    if (typeof define === 'function' && define.amd) {        // AMD. Register as an anonymous module unless amdModuleId is set        define(['jquery'], function (a0) {            return (factory(a0));        });    } else if (typeof module === 'object' && module.exports) {        // Node. Does not work with strict CommonJS, but        // only CommonJS-like environments that support module.exports,        // like Node.        module.exports = factory(require('jquery'));    } else {        factory(root["jQuery"]);    }}(this, function ($) {    (function() {        'use strict';        var defaults = {            mode: 'lg-slide',            // Ex : 'ease'            cssEasing: 'ease',            //'for jquery animation'            easing: 'linear',            speed: 600,            height: '100%',            width: '100%',            addClass: '',            startClass: 'lg-start-zoom',            backdropDuration: 150,            hideBarsDelay: 6000,            useLeft: false,            closable: true,            loop: true,            escKey: true,            keyPress: true,            controls: true,            slideEndAnimatoin: true,            hideControlOnEnd: false,            mousewheel: true,            getCaptionFromTitleOrAlt: true,            // .lg-item || '.lg-sub-html'            appendSubHtmlTo: '.lg-sub-html',            subHtmlSelectorRelative: false,            /**             * @desc number of preload slides             * will exicute only after the current slide is fully loaded.             *             * @ex you clicked on 4th image and if preload = 1 then 3rd slide and 5th             * slide will be loaded in the background after the 4th slide is fully loaded..             * if preload is 2 then 2nd 3rd 5th 6th slides will be preloaded.. ... ...             *             */            preload: 1,            showAfterLoad: true,            selector: '',            selectWithin: '',            nextHtml: '',            prevHtml: '',            // 0, 1            index: false,            iframeMaxWidth: '100%',            download: true,            counter: true,            appendCounterTo: '.lg-toolbar',            swipeThreshold: 50,            enableSwipe: true,            enableDrag: true,            dynamic: false,            dynamicEl: [],            galleryId: 1        };        function Plugin(element, options) {            // Current lightGallery element            this.el = element;            // Current jquery element            this.$el = $(element);            // lightGallery settings            this.s = $.extend({}, defaults, options);            // When using dynamic mode, ensure dynamicEl is an array            if (this.s.dynamic && this.s.dynamicEl !== 'undefined' && this.s.dynamicEl.constructor === Array && !this.s.dynamicEl.length) {                throw ('When using dynamic mode, you must also define dynamicEl as an Array.');            }            // lightGallery modules            this.modules = {};            // false when lightgallery complete first slide;            this.lGalleryOn = false;            this.lgBusy = false;            // Timeout function for hiding controls;            this.hideBartimeout = false;            // To determine browser supports for touch events;            this.isTouch = ('ontouchstart' in document.documentElement);            // Disable hideControlOnEnd if sildeEndAnimation is true            if (this.s.slideEndAnimatoin) {                this.s.hideControlOnEnd = false;            }            // Gallery items            if (this.s.dynamic) {                this.$items = this.s.dynamicEl;            } else {                if (this.s.selector === 'this') {                    this.$items = this.$el;                } else if (this.s.selector !== '') {                    if (this.s.selectWithin) {                        this.$items = $(this.s.selectWithin).find(this.s.selector);                    } else {                        this.$items = this.$el.find($(this.s.selector));                    }                } else {                    this.$items = this.$el.children();                }            }            // .lg-item            this.$slide = '';            // .lg-outer            this.$outer = '';            this.init();            return this;        }        Plugin.prototype.init = function() {            var _this = this;            // s.preload should not be more than $item.length            if (_this.s.preload > _this.$items.length) {                _this.s.preload = _this.$items.length;            }            // if dynamic option is enabled execute immediately            var _hash = window.location.hash;            if (_hash.indexOf('lg=' + this.s.galleryId) > 0) {                _this.index = parseInt(_hash.split('&slide=')[1], 10);                $('body').addClass('lg-from-hash');                if (!$('body').hasClass('lg-on')) {                    setTimeout(function() {                        _this.build(_this.index);                    });                    $('body').addClass('lg-on');                }            }            if (_this.s.dynamic) {                _this.$el.trigger('onBeforeOpen.lg');                _this.index = _this.s.index || 0;                // prevent accidental double execution                if (!$('body').hasClass('lg-on')) {                    setTimeout(function() {                        _this.build(_this.index);                        $('body').addClass('lg-on');                    });                }            } else {                // Using different namespace for click because click event should not unbind if selector is same object('this')                _this.$items.on('click.lgcustom', function(event) {                    // For IE8                    try {                        event.preventDefault();                        event.preventDefault();                    } catch (er) {                        event.returnValue = false;                    }                    _this.$el.trigger('onBeforeOpen.lg');                    _this.index = _this.s.index || _this.$items.index(this);                    // prevent accidental double execution                    if (!$('body').hasClass('lg-on')) {                        _this.build(_this.index);                        $('body').addClass('lg-on');                    }                });            }        };        Plugin.prototype.build = function(index) {            var _this = this;            _this.structure();            // module constructor            $.each($.fn.lightGallery.modules, function(key) {                _this.modules[key] = new $.fn.lightGallery.modules[key](_this.el);            });            // initiate slide function            _this.slide(index, false, false, false);            if (_this.s.keyPress) {                _this.keyPress();            }            if (_this.$items.length > 1) {                _this.arrow();                setTimeout(function() {                    _this.enableDrag();                    _this.enableSwipe();                }, 50);                if (_this.s.mousewheel) {                    _this.mousewheel();                }            } else {                _this.$slide.on('click.lg', function() {                    _this.$el.trigger('onSlideClick.lg');                });            }            _this.counter();            _this.closeGallery();            _this.$el.trigger('onAfterOpen.lg');            // Hide controllers if mouse doesn't move for some period            _this.$outer.on('mousemove.lg click.lg touchstart.lg', function() {                _this.$outer.removeClass('lg-hide-items');                clearTimeout(_this.hideBartimeout);                // Timeout will be cleared on each slide movement also                _this.hideBartimeout = setTimeout(function() {                    _this.$outer.addClass('lg-hide-items');                }, _this.s.hideBarsDelay);            });            _this.$outer.trigger('mousemove.lg');        };        Plugin.prototype.structure = function() {            var list = '';            var controls = '';            var i = 0;            var subHtmlCont = '';            var template;            var _this = this;            $('body').append('<div class="lg-backdrop"></div>');            $('.lg-backdrop').css('transition-duration', this.s.backdropDuration + 'ms');            // Create gallery items            for (i = 0; i < this.$items.length; i++) {                list += '<div class="lg-item"></div>';            }            // Create controlls            if (this.s.controls && this.$items.length > 1) {                controls = '<div class="lg-actions">' +                    '<button class="lg-prev lg-icon">' + this.s.prevHtml + '</button>' +                    '<button class="lg-next lg-icon">' + this.s.nextHtml + '</button>' +                    '</div>';            }            if (this.s.appendSubHtmlTo === '.lg-sub-html') {                subHtmlCont = '<div class="lg-sub-html"></div>';            }            template = '<div class="lg-outer ' + this.s.addClass + ' ' + this.s.startClass + '">' +                '<div class="lg" style="width:' + this.s.width + '; height:' + this.s.height + '">' +                '<div class="lg-inner">' + list + '</div>' +                '<div class="lg-toolbar lg-group">' +                '<span class="lg-close lg-icon"></span>' +                '</div>' +                controls +                subHtmlCont +                '</div>' +                '</div>';            $('body').append(template);            this.$outer = $('.lg-outer');            this.$slide = this.$outer.find('.lg-item');            if (this.s.useLeft) {                this.$outer.addClass('lg-use-left');                // Set mode lg-slide if use left is true;                this.s.mode = 'lg-slide';            } else {                this.$outer.addClass('lg-use-css3');            }            // For fixed height gallery            _this.setTop();            $(window).on('resize.lg orientationchange.lg', function() {                setTimeout(function() {                    _this.setTop();                }, 100);            });            // add class lg-current to remove initial transition            this.$slide.eq(this.index).addClass('lg-current');            // add Class for css support and transition mode            if (this.doCss()) {                this.$outer.addClass('lg-css3');            } else {                this.$outer.addClass('lg-css');                // Set speed 0 because no animation will happen if browser doesn't support css3                this.s.speed = 0;            }            this.$outer.addClass(this.s.mode);            if (this.s.enableDrag && this.$items.length > 1) {                this.$outer.addClass('lg-grab');            }            if (this.s.showAfterLoad) {                this.$outer.addClass('lg-show-after-load');            }            if (this.doCss()) {                var $inner = this.$outer.find('.lg-inner');                $inner.css('transition-timing-function', this.s.cssEasing);                $inner.css('transition-duration', this.s.speed + 'ms');            }            setTimeout(function() {                $('.lg-backdrop').addClass('in');            });            setTimeout(function() {                _this.$outer.addClass('lg-visible');            }, this.s.backdropDuration);            if (this.s.download) {                this.$outer.find('.lg-toolbar').append('<a id="lg-download" target="_blank" download class="lg-download lg-icon"></a>');            }            // Store the current scroll top value to scroll back after closing the gallery..            this.prevScrollTop = $(window).scrollTop();        };        // For fixed height gallery        Plugin.prototype.setTop = function() {            if (this.s.height !== '100%') {                var wH = $(window).height();                var top = (wH - parseInt(this.s.height, 10)) / 2;                var $lGallery = this.$outer.find('.lg');                if (wH >= parseInt(this.s.height, 10)) {                    $lGallery.css('top', top + 'px');                } else {                    $lGallery.css('top', '0px');                }            }        };        // Find css3 support        Plugin.prototype.doCss = function() {            // check for css animation support            var support = function() {                var transition = ['transition', 'MozTransition', 'WebkitTransition', 'OTransition', 'msTransition', 'KhtmlTransition'];                var root = document.documentElement;                var i = 0;                for (i = 0; i < transition.length; i++) {                    if (transition[i] in root.style) {                        return true;                    }                }            };            if (support()) {                return true;            }            return false;        };        /**         *  @desc Check the given src is video         *  @param {String} src         *  @return {Object} video type         *  Ex:{ youtube  :  ["//www.youtube.com/watch?v=c0asJgSyxcY", "c0asJgSyxcY"] }         */        Plugin.prototype.isVideo = function(src, index) {            var html;            if (this.s.dynamic) {                html = this.s.dynamicEl[index].html;            } else {                html = this.$items.eq(index).attr('data-html');            }            if (!src) {                if(html) {                    return {                        html5: true                    };                } else {                    console.error('lightGallery :- data-src is not pvovided on slide item ' + (index + 1) + '. Please make sure the selector property is properly configured. More info - http://sachinchoolur.github.io/lightGallery/demos/html-markup.html');                    return false;                }            }            var youtube = src.match(/\/\/(?:www\.)?youtu(?:\.be|be\.com|be-nocookie\.com)\/(?:watch\?v=|embed\/)?([a-z0-9\-\_\%]+)/i);            var vimeo = src.match(/\/\/(?:www\.)?vimeo.com\/([0-9a-z\-_]+)/i);            var dailymotion = src.match(/\/\/(?:www\.)?dai.ly\/([0-9a-z\-_]+)/i);            var vk = src.match(/\/\/(?:www\.)?(?:vk\.com|vkontakte\.ru)\/(?:video_ext\.php\?)(.*)/i);            if (youtube) {                return {                    youtube: youtube                };            } else if (vimeo) {                return {                    vimeo: vimeo                };            } else if (dailymotion) {                return {                    dailymotion: dailymotion                };            } else if (vk) {                return {                    vk: vk                };            }        };        /**         *  @desc Create image counter         *  Ex: 1/10         */        Plugin.prototype.counter = function() {            if (this.s.counter) {                $(this.s.appendCounterTo).append('<div id="lg-counter"><span id="lg-counter-current">' + (parseInt(this.index, 10) + 1) + '</span> / <span id="lg-counter-all">' + this.$items.length + '</span></div>');            }        };        /**         *  @desc add sub-html into the slide         *  @param {Number} index - index of the slide         */        Plugin.prototype.addHtml = function(index) {            var subHtml = null;            var subHtmlUrl;            var $currentEle;            if (this.s.dynamic) {                if (this.s.dynamicEl[index].subHtmlUrl) {                    subHtmlUrl = this.s.dynamicEl[index].subHtmlUrl;                } else {                    subHtml = this.s.dynamicEl[index].subHtml;                }            } else {                $currentEle = this.$items.eq(index);                if ($currentEle.attr('data-sub-html-url')) {                    subHtmlUrl = $currentEle.attr('data-sub-html-url');                } else {                    subHtml = $currentEle.attr('data-sub-html');                    if (this.s.getCaptionFromTitleOrAlt && !subHtml) {                        subHtml = $currentEle.attr('title') || $currentEle.find('img').first().attr('alt');                    }                }            }            if (!subHtmlUrl) {                if (typeof subHtml !== 'undefined' && subHtml !== null) {                    // get first letter of subhtml                    // if first letter starts with . or # get the html form the jQuery object                    var fL = subHtml.substring(0, 1);                    if (fL === '.' || fL === '#') {                        if (this.s.subHtmlSelectorRelative && !this.s.dynamic) {                            subHtml = $currentEle.find(subHtml).html();                        } else {                            subHtml = $(subHtml).html();                        }                    }                } else {                    subHtml = '';                }            }            if (this.s.appendSubHtmlTo === '.lg-sub-html') {                if (subHtmlUrl) {                    this.$outer.find(this.s.appendSubHtmlTo).load(subHtmlUrl);                } else {                    this.$outer.find(this.s.appendSubHtmlTo).html(subHtml);                }            } else {                if (subHtmlUrl) {                    this.$slide.eq(index).load(subHtmlUrl);                } else {                    this.$slide.eq(index).append(subHtml);                }            }            // Add lg-empty-html class if title doesn't exist            if (typeof subHtml !== 'undefined' && subHtml !== null) {                if (subHtml === '') {                    this.$outer.find(this.s.appendSubHtmlTo).addClass('lg-empty-html');                } else {                    this.$outer.find(this.s.appendSubHtmlTo).removeClass('lg-empty-html');                }            }            this.$el.trigger('onAfterAppendSubHtml.lg', [index]);        };        /**         *  @desc Preload slides         *  @param {Number} index - index of the slide         */        Plugin.prototype.preload = function(index) {            var i = 1;            var j = 1;            for (i = 1; i <= this.s.preload; i++) {                if (i >= this.$items.length - index) {                    break;                }                this.loadContent(index + i, false, 0);            }            for (j = 1; j <= this.s.preload; j++) {                if (index - j < 0) {                    break;                }                this.loadContent(index - j, false, 0);            }        };        /**         *  @desc Load slide content into slide.         *  @param {Number} index - index of the slide.         *  @param {Boolean} rec - if true call loadcontent() function again.         *  @param {Boolean} delay - delay for adding complete class. it is 0 except first time.         */        Plugin.prototype.loadContent = function(index, rec, delay) {            var _this = this;            var _hasPoster = false;            var _$img;            var _src;            var _poster;            var _srcset;            var _sizes;            var _html;            var getResponsiveSrc = function(srcItms) {                var rsWidth = [];                var rsSrc = [];                for (var i = 0; i < srcItms.length; i++) {                    var __src = srcItms[i].split(' ');                    // Manage empty space                    if (__src[0] === '') {                        __src.splice(0, 1);                    }                    rsSrc.push(__src[0]);                    rsWidth.push(__src[1]);                }                var wWidth = $(window).width();                for (var j = 0; j < rsWidth.length; j++) {                    if (parseInt(rsWidth[j], 10) > wWidth) {                        _src = rsSrc[j];                        break;                    }                }            };            if (_this.s.dynamic) {                if (_this.s.dynamicEl[index].poster) {                    _hasPoster = true;                    _poster = _this.s.dynamicEl[index].poster;                }                _html = _this.s.dynamicEl[index].html;                _src = _this.s.dynamicEl[index].src;                if (_this.s.dynamicEl[index].responsive) {                    var srcDyItms = _this.s.dynamicEl[index].responsive.split(',');                    getResponsiveSrc(srcDyItms);                }                _srcset = _this.s.dynamicEl[index].srcset;                _sizes = _this.s.dynamicEl[index].sizes;            } else {                if (_this.$items.eq(index).attr('data-poster')) {                    _hasPoster = true;                    _poster = _this.$items.eq(index).attr('data-poster');                }                _html = _this.$items.eq(index).attr('data-html');                _src = _this.$items.eq(index).attr('href') || _this.$items.eq(index).attr('data-src');                if (_this.$items.eq(index).attr('data-responsive')) {                    var srcItms = _this.$items.eq(index).attr('data-responsive').split(',');                    getResponsiveSrc(srcItms);                }                _srcset = _this.$items.eq(index).attr('data-srcset');                _sizes = _this.$items.eq(index).attr('data-sizes');            }            //if (_src || _srcset || _sizes || _poster) {            var iframe = false;            if (_this.s.dynamic) {                if (_this.s.dynamicEl[index].iframe) {                    iframe = true;                }            } else {                if (_this.$items.eq(index).attr('data-iframe') === 'true') {                    iframe = true;                }            }            var _isVideo = _this.isVideo(_src, index);            if (!_this.$slide.eq(index).hasClass('lg-loaded')) {                if (iframe) {                    _this.$slide.eq(index).prepend('<div class="lg-video-cont lg-has-iframe" style="max-width:' + _this.s.iframeMaxWidth + '"><div class="lg-video"><iframe class="lg-object" frameborder="0" src="' + _src + '"  allowfullscreen="true"></iframe></div></div>');                } else if (_hasPoster) {                    var videoClass = '';                    if (_isVideo && _isVideo.youtube) {                        videoClass = 'lg-has-youtube';                    } else if (_isVideo && _isVideo.vimeo) {                        videoClass = 'lg-has-vimeo';                    } else {                        videoClass = 'lg-has-html5';                    }                    _this.$slide.eq(index).prepend('<div class="lg-video-cont ' + videoClass + ' "><div class="lg-video"><span class="lg-video-play"></span><img class="lg-object lg-has-poster" src="' + _poster + '" /></div></div>');                } else if (_isVideo) {                    _this.$slide.eq(index).prepend('<div class="lg-video-cont "><div class="lg-video"></div></div>');                    _this.$el.trigger('hasVideo.lg', [index, _src, _html]);                } else {                    _this.$slide.eq(index).prepend('<div class="lg-img-wrap"><img class="lg-object lg-image" src="' + _src + '" /></div>');                }                _this.$el.trigger('onAferAppendSlide.lg', [index]);                _$img = _this.$slide.eq(index).find('.lg-object');                if (_sizes) {                    _$img.attr('sizes', _sizes);                }                if (_srcset) {                    _$img.attr('srcset', _srcset);                    try {                        picturefill({                            elements: [_$img[0]]                        });                    } catch (e) {                        console.warn('lightGallery :- If you want srcset to be supported for older browser please include picturefil version 2 javascript library in your document.');                    }                }                if (this.s.appendSubHtmlTo !== '.lg-sub-html') {                    _this.addHtml(index);                }                _this.$slide.eq(index).addClass('lg-loaded');            }            _this.$slide.eq(index).find('.lg-object').on('load.lg error.lg', function() {                // For first time add some delay for displaying the start animation.                var _speed = 0;                // Do not change the delay value because it is required for zoom plugin.                // If gallery opened from direct url (hash) speed value should be 0                if (delay && !$('body').hasClass('lg-from-hash')) {                    _speed = delay;                }                setTimeout(function() {                    _this.$slide.eq(index).addClass('lg-complete');                    _this.$el.trigger('onSlideItemLoad.lg', [index, delay || 0]);                }, _speed);            });            // @todo check load state for html5 videos            if (_isVideo && _isVideo.html5 && !_hasPoster) {                _this.$slide.eq(index).addClass('lg-complete');            }            if (rec === true) {                if (!_this.$slide.eq(index).hasClass('lg-complete')) {                    _this.$slide.eq(index).find('.lg-object').on('load.lg error.lg', function() {                        _this.preload(index);                    });                } else {                    _this.preload(index);                }            }            //}        };        /**         *   @desc slide function for lightgallery         ** Slide() gets call on start         ** ** Set lg.on true once slide() function gets called.         ** Call loadContent() on slide() function inside setTimeout         ** ** On first slide we do not want any animation like slide of fade         ** ** So on first slide( if lg.on if false that is first slide) loadContent() should start loading immediately         ** ** Else loadContent() should wait for the transition to complete.         ** ** So set timeout s.speed + 50         <=> ** loadContent() will load slide content in to the particular slide         ** ** It has recursion (rec) parameter. if rec === true loadContent() will call preload() function.         ** ** preload will execute only when the previous slide is fully loaded (images iframe)         ** ** avoid simultaneous image load         <=> ** Preload() will check for s.preload value and call loadContent() again accoring to preload value         ** loadContent()  <====> Preload();         *   @param {Number} index - index of the slide         *   @param {Boolean} fromTouch - true if slide function called via touch event or mouse drag         *   @param {Boolean} fromThumb - true if slide function called via thumbnail click         *   @param {String} direction - Direction of the slide(next/prev)         */        Plugin.prototype.slide = function(index, fromTouch, fromThumb, direction) {            var _prevIndex = this.$outer.find('.lg-current').index();            var _this = this;            // Prevent if multiple call            // Required for hsh plugin            if (_this.lGalleryOn && (_prevIndex === index)) {                return;            }            var _length = this.$slide.length;            var _time = _this.lGalleryOn ? this.s.speed : 0;            if (!_this.lgBusy) {                if (this.s.download) {                    var _src;                    if (_this.s.dynamic) {                        _src = _this.s.dynamicEl[index].downloadUrl !== false && (_this.s.dynamicEl[index].downloadUrl || _this.s.dynamicEl[index].src);                    } else {                        _src = _this.$items.eq(index).attr('data-download-url') !== 'false' && (_this.$items.eq(index).attr('data-download-url') || _this.$items.eq(index).attr('href') || _this.$items.eq(index).attr('data-src'));                    }                    if (_src) {                        $('#lg-download').attr('href', _src);                        _this.$outer.removeClass('lg-hide-download');                    } else {                        _this.$outer.addClass('lg-hide-download');                    }                }                this.$el.trigger('onBeforeSlide.lg', [_prevIndex, index, fromTouch, fromThumb]);                _this.lgBusy = true;                clearTimeout(_this.hideBartimeout);                // Add title if this.s.appendSubHtmlTo === lg-sub-html                if (this.s.appendSubHtmlTo === '.lg-sub-html') {                    // wait for slide animation to complete                    setTimeout(function() {                        _this.addHtml(index);                    }, _time);                }                this.arrowDisable(index);                if (!direction) {                    if (index < _prevIndex) {                        direction = 'prev';                    } else if (index > _prevIndex) {                        direction = 'next';                    }                }                if (!fromTouch) {                    // remove all transitions                    _this.$outer.addClass('lg-no-trans');                    this.$slide.removeClass('lg-prev-slide lg-next-slide');                    if (direction === 'prev') {                        //prevslide                        this.$slide.eq(index).addClass('lg-prev-slide');                        this.$slide.eq(_prevIndex).addClass('lg-next-slide');                    } else {                        // next slide                        this.$slide.eq(index).addClass('lg-next-slide');                        this.$slide.eq(_prevIndex).addClass('lg-prev-slide');                    }                    // give 50 ms for browser to add/remove class                    setTimeout(function() {                        _this.$slide.removeClass('lg-current');                        //_this.$slide.eq(_prevIndex).removeClass('lg-current');                        _this.$slide.eq(index).addClass('lg-current');                        // reset all transitions                        _this.$outer.removeClass('lg-no-trans');                    }, 50);                } else {                    this.$slide.removeClass('lg-prev-slide lg-current lg-next-slide');                    var touchPrev;                    var touchNext;                    if (_length > 2) {                        touchPrev = index - 1;                        touchNext = index + 1;                        if ((index === 0) && (_prevIndex === _length - 1)) {                            // next slide                            touchNext = 0;                            touchPrev = _length - 1;                        } else if ((index === _length - 1) && (_prevIndex === 0)) {                            // prev slide                            touchNext = 0;                            touchPrev = _length - 1;                        }                    } else {                        touchPrev = 0;                        touchNext = 1;                    }                    if (direction === 'prev') {                        _this.$slide.eq(touchNext).addClass('lg-next-slide');                    } else {                        _this.$slide.eq(touchPrev).addClass('lg-prev-slide');                    }                    _this.$slide.eq(index).addClass('lg-current');                }                if (_this.lGalleryOn) {                    setTimeout(function() {                        _this.loadContent(index, true, 0);                    }, this.s.speed + 50);                    setTimeout(function() {                        _this.lgBusy = false;                        _this.$el.trigger('onAfterSlide.lg', [_prevIndex, index, fromTouch, fromThumb]);                    }, this.s.speed);                } else {                    _this.loadContent(index, true, _this.s.backdropDuration);                    _this.lgBusy = false;                    _this.$el.trigger('onAfterSlide.lg', [_prevIndex, index, fromTouch, fromThumb]);                }                _this.lGalleryOn = true;                if (this.s.counter) {                    $('#lg-counter-current').text(index + 1);                }            }            _this.index = index;        };        /**         *  @desc Go to next slide         *  @param {Boolean} fromTouch - true if slide function called via touch event         */        Plugin.prototype.goToNextSlide = function(fromTouch) {            var _this = this;            var _loop = _this.s.loop;            if (fromTouch && _this.$slide.length < 3) {                _loop = false;            }            if (!_this.lgBusy) {                if ((_this.index + 1) < _this.$slide.length) {                    _this.index++;                    _this.$el.trigger('onBeforeNextSlide.lg', [_this.index]);                    _this.slide(_this.index, fromTouch, false, 'next');                } else {                    if (_loop) {                        _this.index = 0;                        _this.$el.trigger('onBeforeNextSlide.lg', [_this.index]);                        _this.slide(_this.index, fromTouch, false, 'next');                    } else if (_this.s.slideEndAnimatoin && !fromTouch) {                        _this.$outer.addClass('lg-right-end');                        setTimeout(function() {                            _this.$outer.removeClass('lg-right-end');                        }, 400);                    }                }            }        };        /**         *  @desc Go to previous slide         *  @param {Boolean} fromTouch - true if slide function called via touch event         */        Plugin.prototype.goToPrevSlide = function(fromTouch) {            var _this = this;            var _loop = _this.s.loop;            if (fromTouch && _this.$slide.length < 3) {                _loop = false;            }            if (!_this.lgBusy) {                if (_this.index > 0) {                    _this.index--;                    _this.$el.trigger('onBeforePrevSlide.lg', [_this.index, fromTouch]);                    _this.slide(_this.index, fromTouch, false, 'prev');                } else {                    if (_loop) {                        _this.index = _this.$items.length - 1;                        _this.$el.trigger('onBeforePrevSlide.lg', [_this.index, fromTouch]);                        _this.slide(_this.index, fromTouch, false, 'prev');                    } else if (_this.s.slideEndAnimatoin && !fromTouch) {                        _this.$outer.addClass('lg-left-end');                        setTimeout(function() {                            _this.$outer.removeClass('lg-left-end');                        }, 400);                    }                }            }        };        Plugin.prototype.keyPress = function() {            var _this = this;            if (this.$items.length > 1) {                $(window).on('keyup.lg', function(e) {                    if (_this.$items.length > 1) {                        if (e.keyCode === 37) {                            e.preventDefault();                            _this.goToPrevSlide();                        }                        if (e.keyCode === 39) {                            e.preventDefault();                            _this.goToNextSlide();                        }                    }                });            }            $(window).on('keydown.lg', function(e) {                if (_this.s.escKey === true && e.keyCode === 27) {                    e.preventDefault();                    if (!_this.$outer.hasClass('lg-thumb-open')) {                        _this.destroy();                    } else {                        _this.$outer.removeClass('lg-thumb-open');                    }                }            });        };        Plugin.prototype.arrow = function() {            var _this = this;            this.$outer.find('.lg-prev').on('click.lg', function() {                _this.goToPrevSlide();            });            this.$outer.find('.lg-next').on('click.lg', function() {                _this.goToNextSlide();            });        };        Plugin.prototype.arrowDisable = function(index) {            // Disable arrows if s.hideControlOnEnd is true            if (!this.s.loop && this.s.hideControlOnEnd) {                if ((index + 1) < this.$slide.length) {                    this.$outer.find('.lg-next').removeAttr('disabled').removeClass('disabled');                } else {                    this.$outer.find('.lg-next').attr('disabled', 'disabled').addClass('disabled');                }                if (index > 0) {                    this.$outer.find('.lg-prev').removeAttr('disabled').removeClass('disabled');                } else {                    this.$outer.find('.lg-prev').attr('disabled', 'disabled').addClass('disabled');                }            }        };        Plugin.prototype.setTranslate = function($el, xValue, yValue) {            // jQuery supports Automatic CSS prefixing since jQuery 1.8.0            if (this.s.useLeft) {                $el.css('left', xValue);            } else {                $el.css({                    transform: 'translate3d(' + (xValue) + 'px, ' + yValue + 'px, 0px)'                });            }        };        Plugin.prototype.touchMove = function(startCoords, endCoords) {            var distance = endCoords - startCoords;            if (Math.abs(distance) > 15) {                // reset opacity and transition duration                this.$outer.addClass('lg-dragging');                // move current slide                this.setTranslate(this.$slide.eq(this.index), distance, 0);                // move next and prev slide with current slide                this.setTranslate($('.lg-prev-slide'), -this.$slide.eq(this.index).width() + distance, 0);                this.setTranslate($('.lg-next-slide'), this.$slide.eq(this.index).width() + distance, 0);            }        };        Plugin.prototype.touchEnd = function(distance) {            var _this = this;            // keep slide animation for any mode while dragg/swipe            if (_this.s.mode !== 'lg-slide') {                _this.$outer.addClass('lg-slide');            }            this.$slide.not('.lg-current, .lg-prev-slide, .lg-next-slide').css('opacity', '0');            // set transition duration            setTimeout(function() {                _this.$outer.removeClass('lg-dragging');                if ((distance < 0) && (Math.abs(distance) > _this.s.swipeThreshold)) {                    _this.goToNextSlide(true);                } else if ((distance > 0) && (Math.abs(distance) > _this.s.swipeThreshold)) {                    _this.goToPrevSlide(true);                } else if (Math.abs(distance) < 5) {                    // Trigger click if distance is less than 5 pix                    _this.$el.trigger('onSlideClick.lg');                }                _this.$slide.removeAttr('style');            });            // remove slide class once drag/swipe is completed if mode is not slide            setTimeout(function() {                if (!_this.$outer.hasClass('lg-dragging') && _this.s.mode !== 'lg-slide') {                    _this.$outer.removeClass('lg-slide');                }            }, _this.s.speed + 100);        };        Plugin.prototype.enableSwipe = function() {            var _this = this;            var startCoords = 0;            var endCoords = 0;            var isMoved = false;            if (_this.s.enableSwipe && _this.doCss()) {                _this.$slide.on('touchstart.lg', function(e) {                    if (!_this.$outer.hasClass('lg-zoomed') && !_this.lgBusy) {                        e.preventDefault();                        _this.manageSwipeClass();                        startCoords = e.originalEvent.targetTouches[0].pageX;                    }                });                _this.$slide.on('touchmove.lg', function(e) {                    if (!_this.$outer.hasClass('lg-zoomed')) {                        e.preventDefault();                        endCoords = e.originalEvent.targetTouches[0].pageX;                        _this.touchMove(startCoords, endCoords);                        isMoved = true;                    }                });                _this.$slide.on('touchend.lg', function() {                    if (!_this.$outer.hasClass('lg-zoomed')) {                        if (isMoved) {                            isMoved = false;                            _this.touchEnd(endCoords - startCoords);                        } else {                            _this.$el.trigger('onSlideClick.lg');                        }                    }                });            }        };        Plugin.prototype.enableDrag = function() {            var _this = this;            var startCoords = 0;            var endCoords = 0;            var isDraging = false;            var isMoved = false;            if (_this.s.enableDrag && _this.doCss()) {                _this.$slide.on('mousedown.lg', function(e) {                    if (!_this.$outer.hasClass('lg-zoomed') && !_this.lgBusy && !$(e.target).text().trim()) {                        e.preventDefault();                        _this.manageSwipeClass();                        startCoords = e.pageX;                        isDraging = true;                        // ** Fix for webkit cursor issue https://code.google.com/p/chromium/issues/detail?id=26723                        _this.$outer.scrollLeft += 1;                        _this.$outer.scrollLeft -= 1;                        // *                        _this.$outer.removeClass('lg-grab').addClass('lg-grabbing');                        _this.$el.trigger('onDragstart.lg');                    }                });                $(window).on('mousemove.lg', function(e) {                    if (isDraging) {                        isMoved = true;                        endCoords = e.pageX;                        _this.touchMove(startCoords, endCoords);                        _this.$el.trigger('onDragmove.lg');                    }                });                $(window).on('mouseup.lg', function(e) {                    if (isMoved) {                        isMoved = false;                        _this.touchEnd(endCoords - startCoords);                        _this.$el.trigger('onDragend.lg');                    } else if ($(e.target).hasClass('lg-object') || $(e.target).hasClass('lg-video-play')) {                        _this.$el.trigger('onSlideClick.lg');                    }                    // Prevent execution on click                    if (isDraging) {                        isDraging = false;                        _this.$outer.removeClass('lg-grabbing').addClass('lg-grab');                    }                });            }        };        Plugin.prototype.manageSwipeClass = function() {            var _touchNext = this.index + 1;            var _touchPrev = this.index - 1;            if (this.s.loop && this.$slide.length > 2) {                if (this.index === 0) {                    _touchPrev = this.$slide.length - 1;                } else if (this.index === this.$slide.length - 1) {                    _touchNext = 0;                }            }            this.$slide.removeClass('lg-next-slide lg-prev-slide');            if (_touchPrev > -1) {                this.$slide.eq(_touchPrev).addClass('lg-prev-slide');            }            this.$slide.eq(_touchNext).addClass('lg-next-slide');        };        Plugin.prototype.mousewheel = function() {            var _this = this;            _this.$outer.on('mousewheel.lg', function(e) {                if (!e.deltaY) {                    return;                }                if (e.deltaY > 0) {                    _this.goToPrevSlide();                } else {                    _this.goToNextSlide();                }                e.preventDefault();            });        };        Plugin.prototype.closeGallery = function() {            var _this = this;            var mousedown = false;            this.$outer.find('.lg-close').on('click.lg', function() {                _this.destroy();            });            if (_this.s.closable) {                // If you drag the slide and release outside gallery gets close on chrome                // for preventing this check mousedown and mouseup happened on .lg-item or lg-outer                _this.$outer.on('mousedown.lg', function(e) {                    if ($(e.target).is('.lg-outer') || $(e.target).is('.lg-item ') || $(e.target).is('.lg-img-wrap')) {                        mousedown = true;                    } else {                        mousedown = false;                    }                });                _this.$outer.on('mousemove.lg', function() {                    mousedown = false;                });                _this.$outer.on('mouseup.lg', function(e) {                    if ($(e.target).is('.lg-outer') || $(e.target).is('.lg-item ') || $(e.target).is('.lg-img-wrap') && mousedown) {                        if (!_this.$outer.hasClass('lg-dragging')) {                            _this.destroy();                        }                    }                });            }        };        Plugin.prototype.destroy = function(d) {            var _this = this;            if (!d) {                _this.$el.trigger('onBeforeClose.lg');                $(window).scrollTop(_this.prevScrollTop);            }            /**             * if d is false or undefined destroy will only close the gallery             * plugins instance remains with the element             *             * if d is true destroy will completely remove the plugin             */            if (d) {                if (!_this.s.dynamic) {                    // only when not using dynamic mode is $items a jquery collection                    this.$items.off('click.lg click.lgcustom');                }                $.removeData(_this.el, 'lightGallery');            }            // Unbind all events added by lightGallery            this.$el.off('.lg.tm');            // Distroy all lightGallery modules            $.each($.fn.lightGallery.modules, function(key) {                if (_this.modules[key]) {                    _this.modules[key].destroy();                }            });            this.lGalleryOn = false;            clearTimeout(_this.hideBartimeout);            this.hideBartimeout = false;            $(window).off('.lg');            $('body').removeClass('lg-on lg-from-hash');            if (_this.$outer) {                _this.$outer.removeClass('lg-visible');            }            $('.lg-backdrop').removeClass('in');            setTimeout(function() {                if (_this.$outer) {                    _this.$outer.remove();                }                $('.lg-backdrop').remove();                if (!d) {                    _this.$el.trigger('onCloseAfter.lg');                }            }, _this.s.backdropDuration + 50);        };        $.fn.lightGallery = function(options) {            return this.each(function() {                if (!$.data(this, 'lightGallery')) {                    $.data(this, 'lightGallery', new Plugin(this, options));                } else {                    try {                        $(this).data('lightGallery').init();                    } catch (err) {                        console.error('lightGallery has not initiated properly');                    }                }            });        };        $.fn.lightGallery.modules = {};    })();}));/*! lg-autoplay - v1.0.4 - 2017-03-28* http://sachinchoolur.github.io/lightGallery* Copyright (c) 2017 Sachin N; Licensed GPLv3 */(function (root, factory) {    if (typeof define === 'function' && define.amd) {        // AMD. Register as an anonymous module unless amdModuleId is set        define(['jquery'], function (a0) {            return (factory(a0));        });    } else if (typeof exports === 'object') {        // Node. Does not work with strict CommonJS, but        // only CommonJS-like environments that support module.exports,        // like Node.        module.exports = factory(require('jquery'));    } else {        factory(jQuery);    }}(this, function ($) {    (function() {        'use strict';        var defaults = {            autoplay: false,            pause: 5000,            progressBar: true,            fourceAutoplay: false,            autoplayControls: true,            appendAutoplayControlsTo: '.lg-toolbar'        };        /**         * Creates the autoplay plugin.         * @param {object} element - lightGallery element         */        var Autoplay = function(element) {            this.core = $(element).data('lightGallery');            this.$el = $(element);            // Execute only if items are above 1            if (this.core.$items.length < 2) {                return false;            }            this.core.s = $.extend({}, defaults, this.core.s);            this.interval = false;            // Identify if slide happened from autoplay            this.fromAuto = true;            // Identify if autoplay canceled from touch/drag            this.canceledOnTouch = false;            // save fourceautoplay value            this.fourceAutoplayTemp = this.core.s.fourceAutoplay;            // do not allow progress bar if browser does not support css3 transitions            if (!this.core.doCss()) {                this.core.s.progressBar = false;            }            this.init();            return this;        };        Autoplay.prototype.init = function() {            var _this = this;            // append autoplay controls            if (_this.core.s.autoplayControls) {                _this.controls();            }            // Create progress bar            if (_this.core.s.progressBar) {                _this.core.$outer.find('.lg').append('<div class="lg-progress-bar"><div class="lg-progress"></div></div>');            }            // set progress            _this.progress();            // Start autoplay            if (_this.core.s.autoplay) {                _this.$el.one('onSlideItemLoad.lg.tm', function() {                    _this.startlAuto();                });            }            // cancel interval on touchstart and dragstart            _this.$el.on('onDragstart.lg.tm touchstart.lg.tm', function() {                if (_this.interval) {                    _this.cancelAuto();                    _this.canceledOnTouch = true;                }            });            // restore autoplay if autoplay canceled from touchstart / dragstart            _this.$el.on('onDragend.lg.tm touchend.lg.tm onSlideClick.lg.tm', function() {                if (!_this.interval && _this.canceledOnTouch) {                    _this.startlAuto();                    _this.canceledOnTouch = false;                }            });        };        Autoplay.prototype.progress = function() {            var _this = this;            var _$progressBar;            var _$progress;            _this.$el.on('onBeforeSlide.lg.tm', function() {                // start progress bar animation                if (_this.core.s.progressBar && _this.fromAuto) {                    _$progressBar = _this.core.$outer.find('.lg-progress-bar');                    _$progress = _this.core.$outer.find('.lg-progress');                    if (_this.interval) {                        _$progress.removeAttr('style');                        _$progressBar.removeClass('lg-start');                        setTimeout(function() {                            _$progress.css('transition', 'width ' + (_this.core.s.speed + _this.core.s.pause) + 'ms ease 0s');                            _$progressBar.addClass('lg-start');                        }, 20);                    }                }                // Remove setinterval if slide is triggered manually and fourceautoplay is false                if (!_this.fromAuto && !_this.core.s.fourceAutoplay) {                    _this.cancelAuto();                }                _this.fromAuto = false;            });        };        // Manage autoplay via play/stop buttons        Autoplay.prototype.controls = function() {            var _this = this;            var _html = '<span class="lg-autoplay-button lg-icon"></span>';            // Append autoplay controls            $(this.core.s.appendAutoplayControlsTo).append(_html);            _this.core.$outer.find('.lg-autoplay-button').on('click.lg', function() {                if ($(_this.core.$outer).hasClass('lg-show-autoplay')) {                    _this.cancelAuto();                    _this.core.s.fourceAutoplay = false;                } else {                    if (!_this.interval) {                        _this.startlAuto();                        _this.core.s.fourceAutoplay = _this.fourceAutoplayTemp;                    }                }            });        };        // Autostart gallery        Autoplay.prototype.startlAuto = function() {            var _this = this;            _this.core.$outer.find('.lg-progress').css('transition', 'width ' + (_this.core.s.speed + _this.core.s.pause) + 'ms ease 0s');            _this.core.$outer.addClass('lg-show-autoplay');            _this.core.$outer.find('.lg-progress-bar').addClass('lg-start');            _this.interval = setInterval(function() {                if (_this.core.index + 1 < _this.core.$items.length) {                    _this.core.index++;                } else {                    _this.core.index = 0;                }                _this.fromAuto = true;                _this.core.slide(_this.core.index, false, false, 'next');            }, _this.core.s.speed + _this.core.s.pause);        };        // cancel Autostart        Autoplay.prototype.cancelAuto = function() {            clearInterval(this.interval);            this.interval = false;            this.core.$outer.find('.lg-progress').removeAttr('style');            this.core.$outer.removeClass('lg-show-autoplay');            this.core.$outer.find('.lg-progress-bar').removeClass('lg-start');        };        Autoplay.prototype.destroy = function() {            this.cancelAuto();            this.core.$outer.find('.lg-progress-bar').remove();        };        $.fn.lightGallery.modules.autoplay = Autoplay;    })();}));/*! lg-fullscreen - v1.0.1 - 2016-09-30* http://sachinchoolur.github.io/lightGallery* Copyright (c) 2016 Sachin N; Licensed GPLv3 */(function (root, factory) {    if (typeof define === 'function' && define.amd) {        // AMD. Register as an anonymous module unless amdModuleId is set        define(['jquery'], function (a0) {            return (factory(a0));        });    } else if (typeof exports === 'object') {        // Node. Does not work with strict CommonJS, but        // only CommonJS-like environments that support module.exports,        // like Node.        module.exports = factory(require('jquery'));    } else {        factory(jQuery);    }}(this, function ($) {    (function() {        'use strict';        var defaults = {            fullScreen: true        };        var Fullscreen = function(element) {            // get lightGallery core plugin data            this.core = $(element).data('lightGallery');            this.$el = $(element);            // extend module defalut settings with lightGallery core settings            this.core.s = $.extend({}, defaults, this.core.s);            this.init();            return this;        };        Fullscreen.prototype.init = function() {            var fullScreen = '';            if (this.core.s.fullScreen) {                // check for fullscreen browser support                if (!document.fullscreenEnabled && !document.webkitFullscreenEnabled &&                    !document.mozFullScreenEnabled && !document.msFullscreenEnabled) {                    return;                } else {                    fullScreen = '<span class="lg-fullscreen lg-icon"></span>';                    this.core.$outer.find('.lg-toolbar').append(fullScreen);                    this.fullScreen();                }            }        };        Fullscreen.prototype.requestFullscreen = function() {            var el = document.documentElement;            if (el.requestFullscreen) {                el.requestFullscreen();            } else if (el.msRequestFullscreen) {                el.msRequestFullscreen();            } else if (el.mozRequestFullScreen) {                el.mozRequestFullScreen();            } else if (el.webkitRequestFullscreen) {                el.webkitRequestFullscreen();            }        };        Fullscreen.prototype.exitFullscreen = function() {            if (document.fullscreenElement) {                document.exitFullscreen();            } else if (document.msExitFullscreen) {                document.msExitFullscreen();            } else if (document.mozCancelFullScreen) {                document.mozCancelFullScreen();            } else if (document.webkitExitFullscreen) {                document.webkitExitFullscreen();            }        };        // https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Using_full_screen_mode        Fullscreen.prototype.fullScreen = function() {            var _this = this;            $(document).on('fullscreenchange.lg webkitfullscreenchange.lg mozfullscreenchange.lg MSFullscreenChange.lg', function() {                _this.core.$outer.toggleClass('lg-fullscreen-on');            });            this.core.$outer.find('.lg-fullscreen').on('click.lg', function() {                if (!document.fullscreenElement &&                    !document.mozFullScreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {                    _this.requestFullscreen();                } else {                    _this.exitFullscreen();                }            });        };        Fullscreen.prototype.destroy = function() {            // exit from fullscreen if activated            this.exitFullscreen();            $(document).off('fullscreenchange.lg webkitfullscreenchange.lg mozfullscreenchange.lg MSFullscreenChange.lg');        };        $.fn.lightGallery.modules.fullscreen = Fullscreen;    })();}));/*! lg-pager - v1.0.2 - 2017-01-22* http://sachinchoolur.github.io/lightGallery* Copyright (c) 2017 Sachin N; Licensed GPLv3 */(function (root, factory) {    if (typeof define === 'function' && define.amd) {        // AMD. Register as an anonymous module unless amdModuleId is set        define(['jquery'], function (a0) {            return (factory(a0));        });    } else if (typeof exports === 'object') {        // Node. Does not work with strict CommonJS, but        // only CommonJS-like environments that support module.exports,        // like Node.        module.exports = factory(require('jquery'));    } else {        factory(jQuery);    }}(this, function ($) {    (function() {        'use strict';        var defaults = {            pager: false        };        var Pager = function(element) {            this.core = $(element).data('lightGallery');            this.$el = $(element);            this.core.s = $.extend({}, defaults, this.core.s);            if (this.core.s.pager && this.core.$items.length > 1) {                this.init();            }            return this;        };        Pager.prototype.init = function() {            var _this = this;            var pagerList = '';            var $pagerCont;            var $pagerOuter;            var timeout;            _this.core.$outer.find('.lg').append('<div class="lg-pager-outer"></div>');            if (_this.core.s.dynamic) {                for (var i = 0; i < _this.core.s.dynamicEl.length; i++) {                    pagerList += '<span class="lg-pager-cont"> <span class="lg-pager"></span><div class="lg-pager-thumb-cont"><span class="lg-caret"></span> <img src="' + _this.core.s.dynamicEl[i].thumb + '" /></div></span>';                }            } else {                _this.core.$items.each(function() {                    if (!_this.core.s.exThumbImage) {                        pagerList += '<span class="lg-pager-cont"> <span class="lg-pager"></span><div class="lg-pager-thumb-cont"><span class="lg-caret"></span> <img src="' + $(this).find('img').attr('src') + '" /></div></span>';                    } else {                        pagerList += '<span class="lg-pager-cont"> <span class="lg-pager"></span><div class="lg-pager-thumb-cont"><span class="lg-caret"></span> <img src="' + $(this).attr(_this.core.s.exThumbImage) + '" /></div></span>';                    }                });            }            $pagerOuter = _this.core.$outer.find('.lg-pager-outer');            $pagerOuter.html(pagerList);            $pagerCont = _this.core.$outer.find('.lg-pager-cont');            $pagerCont.on('click.lg touchend.lg', function() {                var _$this = $(this);                _this.core.index = _$this.index();                _this.core.slide(_this.core.index, false, true, false);            });            $pagerOuter.on('mouseover.lg', function() {                clearTimeout(timeout);                $pagerOuter.addClass('lg-pager-hover');            });            $pagerOuter.on('mouseout.lg', function() {                timeout = setTimeout(function() {                    $pagerOuter.removeClass('lg-pager-hover');                });            });            _this.core.$el.on('onBeforeSlide.lg.tm', function(e, prevIndex, index) {                $pagerCont.removeClass('lg-pager-active');                $pagerCont.eq(index).addClass('lg-pager-active');            });        };        Pager.prototype.destroy = function() {        };        $.fn.lightGallery.modules.pager = Pager;    })();}));/*! lg-thumbnail - v1.1.0 - 2017-08-08* http://sachinchoolur.github.io/lightGallery* Copyright (c) 2017 Sachin N; Licensed GPLv3 */(function (root, factory) {    if (typeof define === 'function' && define.amd) {        // AMD. Register as an anonymous module unless amdModuleId is set        define(['jquery'], function (a0) {            return (factory(a0));        });    } else if (typeof exports === 'object') {        // Node. Does not work with strict CommonJS, but        // only CommonJS-like environments that support module.exports,        // like Node.        module.exports = factory(require('jquery'));    } else {        factory(jQuery);    }}(this, function ($) {    (function() {        'use strict';        var defaults = {            thumbnail: true,            animateThumb: true,            currentPagerPosition: 'middle',            thumbWidth: 100,            thumbHeight: '80px',            thumbContHeight: 100,            thumbMargin: 5,            exThumbImage: false,            showThumbByDefault: true,            toogleThumb: true,            pullCaptionUp: true,            enableThumbDrag: true,            enableThumbSwipe: true,            swipeThreshold: 50,            loadYoutubeThumbnail: true,            youtubeThumbSize: 1,            loadVimeoThumbnail: true,            vimeoThumbSize: 'thumbnail_small',            loadDailymotionThumbnail: true        };        var Thumbnail = function(element) {            // get lightGallery core plugin data            this.core = $(element).data('lightGallery');            // extend module default settings with lightGallery core settings            this.core.s = $.extend({}, defaults, this.core.s);            this.$el = $(element);            this.$thumbOuter = null;            this.thumbOuterWidth = 0;            this.thumbTotalWidth = (this.core.$items.length * (this.core.s.thumbWidth + this.core.s.thumbMargin));            this.thumbIndex = this.core.index;            if (this.core.s.animateThumb) {                this.core.s.thumbHeight = '100%';            }            // Thumbnail animation value            this.left = 0;            this.init();            return this;        };        Thumbnail.prototype.init = function() {            var _this = this;            if (this.core.s.thumbnail && this.core.$items.length > 1) {                if (this.core.s.showThumbByDefault) {                    setTimeout(function(){                        _this.core.$outer.addClass('lg-thumb-open');                    }, 700);                }                if (this.core.s.pullCaptionUp) {                    this.core.$outer.addClass('lg-pull-caption-up');                }                this.build();                if (this.core.s.animateThumb && this.core.doCss()) {                    if (this.core.s.enableThumbDrag) {                        this.enableThumbDrag();                    }                    if (this.core.s.enableThumbSwipe) {                        this.enableThumbSwipe();                    }                    this.thumbClickable = false;                } else {                    this.thumbClickable = true;                }                this.toogle();                this.thumbkeyPress();            }        };        Thumbnail.prototype.build = function() {            var _this = this;            var thumbList = '';            var vimeoErrorThumbSize = '';            var $thumb;            var html = '<div class="lg-thumb-outer">' +                '<div class="lg-thumb lg-group">' +                '</div>' +                '</div>';            switch (this.core.s.vimeoThumbSize) {                case 'thumbnail_large':                    vimeoErrorThumbSize = '640';                    break;                case 'thumbnail_medium':                    vimeoErrorThumbSize = '200x150';                    break;                case 'thumbnail_small':                    vimeoErrorThumbSize = '100x75';            }            _this.core.$outer.addClass('lg-has-thumb');            _this.core.$outer.find('.lg').append(html);            _this.$thumbOuter = _this.core.$outer.find('.lg-thumb-outer');            _this.thumbOuterWidth = _this.$thumbOuter.width();            if (_this.core.s.animateThumb) {                _this.core.$outer.find('.lg-thumb').css({                    width: _this.thumbTotalWidth + 'px',                    position: 'relative'                });            }            if (this.core.s.animateThumb) {                _this.$thumbOuter.css('height', _this.core.s.thumbContHeight + 'px');            }            function getThumb(src, thumb, index) {                var isVideo = _this.core.isVideo(src, index) || {};                var thumbImg;                var vimeoId = '';                if (isVideo.youtube || isVideo.vimeo || isVideo.dailymotion) {                    if (isVideo.youtube) {                        if (_this.core.s.loadYoutubeThumbnail) {                            thumbImg = '//img.youtube.com/vi/' + isVideo.youtube[1] + '/' + _this.core.s.youtubeThumbSize + '.jpg';                        } else {                            thumbImg = thumb;                        }                    } else if (isVideo.vimeo) {                        if (_this.core.s.loadVimeoThumbnail) {                            thumbImg = '//i.vimeocdn.com/video/error_' + vimeoErrorThumbSize + '.jpg';                            vimeoId = isVideo.vimeo[1];                        } else {                            thumbImg = thumb;                        }                    } else if (isVideo.dailymotion) {                        if (_this.core.s.loadDailymotionThumbnail) {                            thumbImg = '//www.dailymotion.com/thumbnail/video/' + isVideo.dailymotion[1];                        } else {                            thumbImg = thumb;                        }                    }                } else {                    thumbImg = thumb;                }                thumbList += '<div data-vimeo-id="' + vimeoId + '" class="lg-thumb-item" style="width:' + _this.core.s.thumbWidth + 'px; height: ' + _this.core.s.thumbHeight + '; margin-right: ' + _this.core.s.thumbMargin + 'px"><img src="' + thumbImg + '" /></div>';                vimeoId = '';            }            if (_this.core.s.dynamic) {                for (var i = 0; i < _this.core.s.dynamicEl.length; i++) {                    getThumb(_this.core.s.dynamicEl[i].src, _this.core.s.dynamicEl[i].thumb, i);                }            } else {                _this.core.$items.each(function(i) {                    if (!_this.core.s.exThumbImage) {                        getThumb($(this).attr('href') || $(this).attr('data-src'), $(this).find('img').attr('src'), i);                    } else {                        getThumb($(this).attr('href') || $(this).attr('data-src'), $(this).attr(_this.core.s.exThumbImage), i);                    }                });            }            _this.core.$outer.find('.lg-thumb').html(thumbList);            $thumb = _this.core.$outer.find('.lg-thumb-item');            // Load vimeo thumbnails            $thumb.each(function() {                var $this = $(this);                var vimeoVideoId = $this.attr('data-vimeo-id');                if (vimeoVideoId) {                    $.getJSON('//www.vimeo.com/api/v2/video/' + vimeoVideoId + '.json?callback=?', {                        format: 'json'                    }, function(data) {                        $this.find('img').attr('src', data[0][_this.core.s.vimeoThumbSize]);                    });                }            });            // manage active class for thumbnail            $thumb.eq(_this.core.index).addClass('active');            _this.core.$el.on('onBeforeSlide.lg.tm', function() {                $thumb.removeClass('active');                $thumb.eq(_this.core.index).addClass('active');            });            $thumb.on('click.lg touchend.lg', function() {                var _$this = $(this);                setTimeout(function() {                    // In IE9 and bellow touch does not support                    // Go to slide if browser does not support css transitions                    if ((_this.thumbClickable && !_this.core.lgBusy) || !_this.core.doCss()) {                        _this.core.index = _$this.index();                        _this.core.slide(_this.core.index, false, true, false);                    }                }, 50);            });            _this.core.$el.on('onBeforeSlide.lg.tm', function() {                _this.animateThumb(_this.core.index);            });            $(window).on('resize.lg.thumb orientationchange.lg.thumb', function() {                setTimeout(function() {                    _this.animateThumb(_this.core.index);                    _this.thumbOuterWidth = _this.$thumbOuter.width();                }, 200);            });        };        Thumbnail.prototype.setTranslate = function(value) {            // jQuery supports Automatic CSS prefixing since jQuery 1.8.0            this.core.$outer.find('.lg-thumb').css({                transform: 'translate3d(-' + (value) + 'px, 0px, 0px)'            });        };        Thumbnail.prototype.animateThumb = function(index) {            var $thumb = this.core.$outer.find('.lg-thumb');            if (this.core.s.animateThumb) {                var position;                switch (this.core.s.currentPagerPosition) {                    case 'left':                        position = 0;                        break;                    case 'middle':                        position = (this.thumbOuterWidth / 2) - (this.core.s.thumbWidth / 2);                        break;                    case 'right':                        position = this.thumbOuterWidth - this.core.s.thumbWidth;                }                this.left = ((this.core.s.thumbWidth + this.core.s.thumbMargin) * index - 1) - position;                if (this.left > (this.thumbTotalWidth - this.thumbOuterWidth)) {                    this.left = this.thumbTotalWidth - this.thumbOuterWidth;                }                if (this.left < 0) {                    this.left = 0;                }                if (this.core.lGalleryOn) {                    if (!$thumb.hasClass('on')) {                        this.core.$outer.find('.lg-thumb').css('transition-duration', this.core.s.speed + 'ms');                    }                    if (!this.core.doCss()) {                        $thumb.animate({                            left: -this.left + 'px'                        }, this.core.s.speed);                    }                } else {                    if (!this.core.doCss()) {                        $thumb.css('left', -this.left + 'px');                    }                }                this.setTranslate(this.left);            }        };        // Enable thumbnail dragging and swiping        Thumbnail.prototype.enableThumbDrag = function() {            var _this = this;            var startCoords = 0;            var endCoords = 0;            var isDraging = false;            var isMoved = false;            var tempLeft = 0;            _this.$thumbOuter.addClass('lg-grab');            _this.core.$outer.find('.lg-thumb').on('mousedown.lg.thumb', function(e) {                if (_this.thumbTotalWidth > _this.thumbOuterWidth) {                    // execute only on .lg-object                    e.preventDefault();                    startCoords = e.pageX;                    isDraging = true;                    // ** Fix for webkit cursor issue https://code.google.com/p/chromium/issues/detail?id=26723                    _this.core.$outer.scrollLeft += 1;                    _this.core.$outer.scrollLeft -= 1;                    // *                    _this.thumbClickable = false;                    _this.$thumbOuter.removeClass('lg-grab').addClass('lg-grabbing');                }            });            $(window).on('mousemove.lg.thumb', function(e) {                if (isDraging) {                    tempLeft = _this.left;                    isMoved = true;                    endCoords = e.pageX;                    _this.$thumbOuter.addClass('lg-dragging');                    tempLeft = tempLeft - (endCoords - startCoords);                    if (tempLeft > (_this.thumbTotalWidth - _this.thumbOuterWidth)) {                        tempLeft = _this.thumbTotalWidth - _this.thumbOuterWidth;                    }                    if (tempLeft < 0) {                        tempLeft = 0;                    }                    // move current slide                    _this.setTranslate(tempLeft);                }            });            $(window).on('mouseup.lg.thumb', function() {                if (isMoved) {                    isMoved = false;                    _this.$thumbOuter.removeClass('lg-dragging');                    _this.left = tempLeft;                    if (Math.abs(endCoords - startCoords) < _this.core.s.swipeThreshold) {                        _this.thumbClickable = true;                    }                } else {                    _this.thumbClickable = true;                }                if (isDraging) {                    isDraging = false;                    _this.$thumbOuter.removeClass('lg-grabbing').addClass('lg-grab');                }            });        };        Thumbnail.prototype.enableThumbSwipe = function() {            var _this = this;            var startCoords = 0;            var endCoords = 0;            var isMoved = false;            var tempLeft = 0;            _this.core.$outer.find('.lg-thumb').on('touchstart.lg', function(e) {                if (_this.thumbTotalWidth > _this.thumbOuterWidth) {                    e.preventDefault();                    startCoords = e.originalEvent.targetTouches[0].pageX;                    _this.thumbClickable = false;                }            });            _this.core.$outer.find('.lg-thumb').on('touchmove.lg', function(e) {                if (_this.thumbTotalWidth > _this.thumbOuterWidth) {                    e.preventDefault();                    endCoords = e.originalEvent.targetTouches[0].pageX;                    isMoved = true;                    _this.$thumbOuter.addClass('lg-dragging');                    tempLeft = _this.left;                    tempLeft = tempLeft - (endCoords - startCoords);                    if (tempLeft > (_this.thumbTotalWidth - _this.thumbOuterWidth)) {                        tempLeft = _this.thumbTotalWidth - _this.thumbOuterWidth;                    }                    if (tempLeft < 0) {                        tempLeft = 0;                    }                    // move current slide                    _this.setTranslate(tempLeft);                }            });            _this.core.$outer.find('.lg-thumb').on('touchend.lg', function() {                if (_this.thumbTotalWidth > _this.thumbOuterWidth) {                    if (isMoved) {                        isMoved = false;                        _this.$thumbOuter.removeClass('lg-dragging');                        if (Math.abs(endCoords - startCoords) < _this.core.s.swipeThreshold) {                            _this.thumbClickable = true;                        }                        _this.left = tempLeft;                    } else {                        _this.thumbClickable = true;                    }                } else {                    _this.thumbClickable = true;                }            });        };        Thumbnail.prototype.toogle = function() {            var _this = this;            if (_this.core.s.toogleThumb) {                _this.core.$outer.addClass('lg-can-toggle');                _this.$thumbOuter.append('<span class="lg-toogle-thumb lg-icon"></span>');                _this.core.$outer.find('.lg-toogle-thumb').on('click.lg', function() {                    _this.core.$outer.toggleClass('lg-thumb-open');                });            }        };        Thumbnail.prototype.thumbkeyPress = function() {            var _this = this;            $(window).on('keydown.lg.thumb', function(e) {                if (e.keyCode === 38) {                    e.preventDefault();                    _this.core.$outer.addClass('lg-thumb-open');                } else if (e.keyCode === 40) {                    e.preventDefault();                    _this.core.$outer.removeClass('lg-thumb-open');                }            });        };        Thumbnail.prototype.destroy = function() {            if (this.core.s.thumbnail && this.core.$items.length > 1) {                $(window).off('resize.lg.thumb orientationchange.lg.thumb keydown.lg.thumb');                this.$thumbOuter.remove();                this.core.$outer.removeClass('lg-has-thumb');            }        };        $.fn.lightGallery.modules.Thumbnail = Thumbnail;    })();}));/*! lg-video - v1.2.2 - 2018-05-01* http://sachinchoolur.github.io/lightGallery* Copyright (c) 2018 Sachin N; Licensed GPLv3 */(function (root, factory) {    if (typeof define === 'function' && define.amd) {        // AMD. Register as an anonymous module unless amdModuleId is set        define(['jquery'], function (a0) {            return (factory(a0));        });    } else if (typeof module === 'object' && module.exports) {        // Node. Does not work with strict CommonJS, but        // only CommonJS-like environments that support module.exports,        // like Node.        module.exports = factory(require('jquery'));    } else {        factory(root["jQuery"]);    }}(this, function ($) {    (function() {        'use strict';        var defaults = {            videoMaxWidth: '855px',            autoplayFirstVideo: true,            youtubePlayerParams: false,            vimeoPlayerParams: false,            dailymotionPlayerParams: false,            vkPlayerParams: false,            videojs: false,            videojsOptions: {}        };        var Video = function(element) {            this.core = $(element).data('lightGallery');            this.$el = $(element);            this.core.s = $.extend({}, defaults, this.core.s);            this.videoLoaded = false;            this.init();            return this;        };        Video.prototype.init = function() {            var _this = this;            // Event triggered when video url found without poster            _this.core.$el.on('hasVideo.lg.tm', onHasVideo.bind(this));            // Set max width for video            _this.core.$el.on('onAferAppendSlide.lg.tm', onAferAppendSlide.bind(this));            if (_this.core.doCss() && (_this.core.$items.length > 1) && (_this.core.s.enableSwipe || _this.core.s.enableDrag)) {                _this.core.$el.on('onSlideClick.lg.tm', function() {                    var $el = _this.core.$slide.eq(_this.core.index);                    _this.loadVideoOnclick($el);                });            } else {                // For IE 9 and bellow                _this.core.$slide.on('click.lg', function() {                    _this.loadVideoOnclick($(this));                });            }            _this.core.$el.on('onBeforeSlide.lg.tm', onBeforeSlide.bind(this));            _this.core.$el.on('onAfterSlide.lg.tm', function(event, prevIndex) {                _this.core.$slide.eq(prevIndex).removeClass('lg-video-playing');            });            if (_this.core.s.autoplayFirstVideo) {                _this.core.$el.on('onAferAppendSlide.lg.tm', function (e, index) {                    if (!_this.core.lGalleryOn) {                        var $el = _this.core.$slide.eq(index);                        setTimeout(function () {                            _this.loadVideoOnclick($el);                        }, 100);                    }                });            }        };        Video.prototype.loadVideo = function(src, addClass, noPoster, index, html) {            var video = '';            var autoplay = 1;            var a = '';            var isVideo = this.core.isVideo(src, index) || {};            // Enable autoplay based on setting for first video if poster doesn't exist            if (noPoster) {                if (this.videoLoaded) {                    autoplay = 0;                } else {                    autoplay = this.core.s.autoplayFirstVideo ? 1 : 0;                }            }            if (isVideo.youtube) {                a = '?wmode=opaque&autoplay=' + autoplay + '&enablejsapi=1';                if (this.core.s.youtubePlayerParams) {                    a = a + '&' + $.param(this.core.s.youtubePlayerParams);                }                video = '<iframe class="lg-video-object lg-youtube ' + addClass + '" width="560" height="315" src="//www.youtube.com/embed/' + isVideo.youtube[1] + a + '" frameborder="0" allowfullscreen></iframe>';            } else if (isVideo.vimeo) {                a = '?autoplay=' + autoplay + '&api=1';                if (this.core.s.vimeoPlayerParams) {                    a = a + '&' + $.param(this.core.s.vimeoPlayerParams);                }                video = '<iframe class="lg-video-object lg-vimeo ' + addClass + '" width="560" height="315"  src="//player.vimeo.com/video/' + isVideo.vimeo[1] + a + '" frameborder="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>';            } else if (isVideo.dailymotion) {                a = '?wmode=opaque&autoplay=' + autoplay + '&api=postMessage';                if (this.core.s.dailymotionPlayerParams) {                    a = a + '&' + $.param(this.core.s.dailymotionPlayerParams);                }                video = '<iframe class="lg-video-object lg-dailymotion ' + addClass + '" width="560" height="315" src="//www.dailymotion.com/embed/video/' + isVideo.dailymotion[1] + a + '" frameborder="0" allowfullscreen></iframe>';            } else if (isVideo.html5) {                var fL = html.substring(0, 1);                if (fL === '.' || fL === '#') {                    html = $(html).html();                }                video = html;            } else if (isVideo.vk) {                a = '&autoplay=' + autoplay;                if (this.core.s.vkPlayerParams) {                    a = a + '&' + $.param(this.core.s.vkPlayerParams);                }                video = '<iframe class="lg-video-object lg-vk ' + addClass + '" width="560" height="315" src="//vk.com/video_ext.php?' + isVideo.vk[1] + a + '" frameborder="0" allowfullscreen></iframe>';            }            return video;        };        Video.prototype.loadVideoOnclick = function($el){            var _this = this;            // check slide has poster            if ($el.find('.lg-object').hasClass('lg-has-poster') && $el.find('.lg-object').is(':visible')) {                // check already video element present                if (!$el.hasClass('lg-has-video')) {                    $el.addClass('lg-video-playing lg-has-video');                    var _src;                    var _html;                    var _loadVideo = function(_src, _html) {                        $el.find('.lg-video').append(_this.loadVideo(_src, '', false, _this.core.index, _html));                        if (_html) {                            if (_this.core.s.videojs) {                                try {                                    videojs(_this.core.$slide.eq(_this.core.index).find('.lg-html5').get(0), _this.core.s.videojsOptions, function() {                                        this.play();                                    });                                } catch (e) {                                    console.error('Make sure you have included videojs');                                }                            } else {                                _this.core.$slide.eq(_this.core.index).find('.lg-html5').get(0).play();                            }                        }                    };                    if (_this.core.s.dynamic) {                        _src = _this.core.s.dynamicEl[_this.core.index].src;                        _html = _this.core.s.dynamicEl[_this.core.index].html;                        _loadVideo(_src, _html);                    } else {                        _src = _this.core.$items.eq(_this.core.index).attr('href') || _this.core.$items.eq(_this.core.index).attr('data-src');                        _html = _this.core.$items.eq(_this.core.index).attr('data-html');                        _loadVideo(_src, _html);                    }                    var $tempImg = $el.find('.lg-object');                    $el.find('.lg-video').append($tempImg);                    // @todo loading icon for html5 videos also                    // for showing the loading indicator while loading video                    if (!$el.find('.lg-video-object').hasClass('lg-html5')) {                        $el.removeClass('lg-complete');                        $el.find('.lg-video-object').on('load.lg error.lg', function() {                            $el.addClass('lg-complete');                        });                    }                } else {                    var youtubePlayer = $el.find('.lg-youtube').get(0);                    var vimeoPlayer = $el.find('.lg-vimeo').get(0);                    var dailymotionPlayer = $el.find('.lg-dailymotion').get(0);                    var html5Player = $el.find('.lg-html5').get(0);                    if (youtubePlayer) {                        youtubePlayer.contentWindow.postMessage('{"event":"command","func":"playVideo","args":""}', '*');                    } else if (vimeoPlayer) {                        try {                            $f(vimeoPlayer).api('play');                        } catch (e) {                            console.error('Make sure you have included froogaloop2 js');                        }                    } else if (dailymotionPlayer) {                        dailymotionPlayer.contentWindow.postMessage('play', '*');                    } else if (html5Player) {                        if (_this.core.s.videojs) {                            try {                                videojs(html5Player).play();                            } catch (e) {                                console.error('Make sure you have included videojs');                            }                        } else {                            html5Player.play();                        }                    }                    $el.addClass('lg-video-playing');                }            }        };        Video.prototype.destroy = function() {            this.videoLoaded = false;        };        function onHasVideo(event, index, src, html) {            /*jshint validthis:true */            var _this = this;            _this.core.$slide.eq(index).find('.lg-video').append(_this.loadVideo(src, 'lg-object', true, index, html));            if (html) {                if (_this.core.s.videojs) {                    try {                        videojs(_this.core.$slide.eq(index).find('.lg-html5').get(0), _this.core.s.videojsOptions, function() {                            if (!_this.videoLoaded && _this.core.s.autoplayFirstVideo) {                                this.play();                            }                        });                    } catch (e) {                        console.error('Make sure you have included videojs');                    }                } else {                    if(!_this.videoLoaded && _this.core.s.autoplayFirstVideo) {                        _this.core.$slide.eq(index).find('.lg-html5').get(0).play();                    }                }            }        }        function onAferAppendSlide(event, index) {            /*jshint validthis:true */            var $videoCont = this.core.$slide.eq(index).find('.lg-video-cont');            if (!$videoCont.hasClass('lg-has-iframe')) {                $videoCont.css('max-width', this.core.s.videoMaxWidth);                this.videoLoaded = true;            }        }        function onBeforeSlide(event, prevIndex, index) {            /*jshint validthis:true */            var _this = this;            var $videoSlide = _this.core.$slide.eq(prevIndex);            var youtubePlayer = $videoSlide.find('.lg-youtube').get(0);            var vimeoPlayer = $videoSlide.find('.lg-vimeo').get(0);            var dailymotionPlayer = $videoSlide.find('.lg-dailymotion').get(0);            var vkPlayer = $videoSlide.find('.lg-vk').get(0);            var html5Player = $videoSlide.find('.lg-html5').get(0);            if (youtubePlayer) {                youtubePlayer.contentWindow.postMessage('{"event":"command","func":"pauseVideo","args":""}', '*');            } else if (vimeoPlayer) {                try {                    $f(vimeoPlayer).api('pause');                } catch (e) {                    console.error('Make sure you have included froogaloop2 js');                }            } else if (dailymotionPlayer) {                dailymotionPlayer.contentWindow.postMessage('pause', '*');            } else if (html5Player) {                if (_this.core.s.videojs) {                    try {                        videojs(html5Player).pause();                    } catch (e) {                        console.error('Make sure you have included videojs');                    }                } else {                    html5Player.pause();                }            } if (vkPlayer) {                $(vkPlayer).attr('src', $(vkPlayer).attr('src').replace('&autoplay', '&noplay'));            }            var _src;            if (_this.core.s.dynamic) {                _src = _this.core.s.dynamicEl[index].src;            } else {                _src = _this.core.$items.eq(index).attr('href') || _this.core.$items.eq(index).attr('data-src');            }            var _isVideo = _this.core.isVideo(_src, index) || {};            if (_isVideo.youtube || _isVideo.vimeo || _isVideo.dailymotion || _isVideo.vk) {                _this.core.$outer.addClass('lg-hide-download');            }        }        $.fn.lightGallery.modules.video = Video;    })();}));/*! lg-zoom - v1.1.0 - 2017-08-08* http://sachinchoolur.github.io/lightGallery* Copyright (c) 2017 Sachin N; Licensed GPLv3 */(function (root, factory) {    if (typeof define === 'function' && define.amd) {        // AMD. Register as an anonymous module unless amdModuleId is set        define(['jquery'], function (a0) {            return (factory(a0));        });    } else if (typeof exports === 'object') {        // Node. Does not work with strict CommonJS, but        // only CommonJS-like environments that support module.exports,        // like Node.        module.exports = factory(require('jquery'));    } else {        factory(jQuery);    }}(this, function ($) {    (function() {        'use strict';        var getUseLeft = function() {            var useLeft = false;            var isChrome = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);            if (isChrome && parseInt(isChrome[2], 10) < 54) {                useLeft = true;            }            return useLeft;        };        var defaults = {            scale: 1,            zoom: true,            actualSize: true,            enableZoomAfter: 300,            useLeftForZoom: getUseLeft()        };        var Zoom = function(element) {            this.core = $(element).data('lightGallery');            this.core.s = $.extend({}, defaults, this.core.s);            if (this.core.s.zoom && this.core.doCss()) {                this.init();                // Store the zoomable timeout value just to clear it while closing                this.zoomabletimeout = false;                // Set the initial value center                this.pageX = $(window).width() / 2;                this.pageY = ($(window).height() / 2) + $(window).scrollTop();            }            return this;        };        Zoom.prototype.init = function() {            var _this = this;            var zoomIcons = '<span id="lg-zoom-in" class="lg-icon"></span><span id="lg-zoom-out" class="lg-icon"></span>';            if (_this.core.s.actualSize) {                zoomIcons += '<span id="lg-actual-size" class="lg-icon"></span>';            }            if (_this.core.s.useLeftForZoom) {                _this.core.$outer.addClass('lg-use-left-for-zoom');            } else {                _this.core.$outer.addClass('lg-use-transition-for-zoom');            }            this.core.$outer.find('.lg-toolbar').append(zoomIcons);            // Add zoomable class            _this.core.$el.on('onSlideItemLoad.lg.tm.zoom', function(event, index, delay) {                // delay will be 0 except first time                var _speed = _this.core.s.enableZoomAfter + delay;                // set _speed value 0 if gallery opened from direct url and if it is first slide                if ($('body').hasClass('lg-from-hash') && delay) {                    // will execute only once                    _speed = 0;                } else {                    // Remove lg-from-hash to enable starting animation.                    $('body').removeClass('lg-from-hash');                }                _this.zoomabletimeout = setTimeout(function() {                    _this.core.$slide.eq(index).addClass('lg-zoomable');                }, _speed + 30);            });            var scale = 1;            /**             * @desc Image zoom             * Translate the wrap and scale the image to get better user experience             *             * @param {String} scaleVal - Zoom decrement/increment value             */            var zoom = function(scaleVal) {                var $image = _this.core.$outer.find('.lg-current .lg-image');                var _x;                var _y;                // Find offset manually to avoid issue after zoom                var offsetX = ($(window).width() - $image.prop('offsetWidth')) / 2;                var offsetY = (($(window).height() - $image.prop('offsetHeight')) / 2) + $(window).scrollTop();                _x = _this.pageX - offsetX;                _y = _this.pageY - offsetY;                var x = (scaleVal - 1) * (_x);                var y = (scaleVal - 1) * (_y);                $image.css('transform', 'scale3d(' + scaleVal + ', ' + scaleVal + ', 1)').attr('data-scale', scaleVal);                if (_this.core.s.useLeftForZoom) {                    $image.parent().css({                        left: -x + 'px',                        top: -y + 'px'                    }).attr('data-x', x).attr('data-y', y);                } else {                    $image.parent().css('transform', 'translate3d(-' + x + 'px, -' + y + 'px, 0)').attr('data-x', x).attr('data-y', y);                }            };            var callScale = function() {                if (scale > 1) {                    _this.core.$outer.addClass('lg-zoomed');                } else {                    _this.resetZoom();                }                if (scale < 1) {                    scale = 1;                }                zoom(scale);            };            var actualSize = function(event, $image, index, fromIcon) {                var w = $image.prop('offsetWidth');                var nw;                if (_this.core.s.dynamic) {                    nw = _this.core.s.dynamicEl[index].width || $image[0].naturalWidth || w;                } else {                    nw = _this.core.$items.eq(index).attr('data-width') || $image[0].naturalWidth || w;                }                var _scale;                if (_this.core.$outer.hasClass('lg-zoomed')) {                    scale = 1;                } else {                    if (nw > w) {                        _scale = nw / w;                        scale = _scale || 2;                    }                }                if (fromIcon) {                    _this.pageX = $(window).width() / 2;                    _this.pageY = ($(window).height() / 2) + $(window).scrollTop();                } else {                    _this.pageX = event.pageX || event.originalEvent.targetTouches[0].pageX;                    _this.pageY = event.pageY || event.originalEvent.targetTouches[0].pageY;                }                callScale();                setTimeout(function() {                    _this.core.$outer.removeClass('lg-grabbing').addClass('lg-grab');                }, 10);            };            var tapped = false;            // event triggered after appending slide content            _this.core.$el.on('onAferAppendSlide.lg.tm.zoom', function(event, index) {                // Get the current element                var $image = _this.core.$slide.eq(index).find('.lg-image');                $image.on('dblclick', function(event) {                    actualSize(event, $image, index);                });                $image.on('touchstart', function(event) {                    if (!tapped) {                        tapped = setTimeout(function() {                            tapped = null;                        }, 300);                    } else {                        clearTimeout(tapped);                        tapped = null;                        actualSize(event, $image, index);                    }                    event.preventDefault();                });            });            // Update zoom on resize and orientationchange            $(window).on('resize.lg.zoom scroll.lg.zoom orientationchange.lg.zoom', function() {                _this.pageX = $(window).width() / 2;                _this.pageY = ($(window).height() / 2) + $(window).scrollTop();                zoom(scale);            });            $('#lg-zoom-out').on('click.lg', function() {                if (_this.core.$outer.find('.lg-current .lg-image').length) {                    scale -= _this.core.s.scale;                    callScale();                }            });            $('#lg-zoom-in').on('click.lg', function() {                if (_this.core.$outer.find('.lg-current .lg-image').length) {                    scale += _this.core.s.scale;                    callScale();                }            });            $('#lg-actual-size').on('click.lg', function(event) {                actualSize(event, _this.core.$slide.eq(_this.core.index).find('.lg-image'), _this.core.index, true);            });            // Reset zoom on slide change            _this.core.$el.on('onBeforeSlide.lg.tm', function() {                scale = 1;                _this.resetZoom();            });            // Drag option after zoom            _this.zoomDrag();            _this.zoomSwipe();        };        // Reset zoom effect        Zoom.prototype.resetZoom = function() {            this.core.$outer.removeClass('lg-zoomed');            this.core.$slide.find('.lg-img-wrap').removeAttr('style data-x data-y');            this.core.$slide.find('.lg-image').removeAttr('style data-scale');            // Reset pagx pagy values to center            this.pageX = $(window).width() / 2;            this.pageY = ($(window).height() / 2) + $(window).scrollTop();        };        Zoom.prototype.zoomSwipe = function() {            var _this = this;            var startCoords = {};            var endCoords = {};            var isMoved = false;            // Allow x direction drag            var allowX = false;            // Allow Y direction drag            var allowY = false;            _this.core.$slide.on('touchstart.lg', function(e) {                if (_this.core.$outer.hasClass('lg-zoomed')) {                    var $image = _this.core.$slide.eq(_this.core.index).find('.lg-object');                    allowY = $image.prop('offsetHeight') * $image.attr('data-scale') > _this.core.$outer.find('.lg').height();                    allowX = $image.prop('offsetWidth') * $image.attr('data-scale') > _this.core.$outer.find('.lg').width();                    if ((allowX || allowY)) {                        e.preventDefault();                        startCoords = {                            x: e.originalEvent.targetTouches[0].pageX,                            y: e.originalEvent.targetTouches[0].pageY                        };                    }                }            });            _this.core.$slide.on('touchmove.lg', function(e) {                if (_this.core.$outer.hasClass('lg-zoomed')) {                    var _$el = _this.core.$slide.eq(_this.core.index).find('.lg-img-wrap');                    var distanceX;                    var distanceY;                    e.preventDefault();                    isMoved = true;                    endCoords = {                        x: e.originalEvent.targetTouches[0].pageX,                        y: e.originalEvent.targetTouches[0].pageY                    };                    // reset opacity and transition duration                    _this.core.$outer.addClass('lg-zoom-dragging');                    if (allowY) {                        distanceY = (-Math.abs(_$el.attr('data-y'))) + (endCoords.y - startCoords.y);                    } else {                        distanceY = -Math.abs(_$el.attr('data-y'));                    }                    if (allowX) {                        distanceX = (-Math.abs(_$el.attr('data-x'))) + (endCoords.x - startCoords.x);                    } else {                        distanceX = -Math.abs(_$el.attr('data-x'));                    }                    if ((Math.abs(endCoords.x - startCoords.x) > 15) || (Math.abs(endCoords.y - startCoords.y) > 15)) {                        if (_this.core.s.useLeftForZoom) {                            _$el.css({                                left: distanceX + 'px',                                top: distanceY + 'px'                            });                        } else {                            _$el.css('transform', 'translate3d(' + distanceX + 'px, ' + distanceY + 'px, 0)');                        }                    }                }            });            _this.core.$slide.on('touchend.lg', function() {                if (_this.core.$outer.hasClass('lg-zoomed')) {                    if (isMoved) {                        isMoved = false;                        _this.core.$outer.removeClass('lg-zoom-dragging');                        _this.touchendZoom(startCoords, endCoords, allowX, allowY);                    }                }            });        };        Zoom.prototype.zoomDrag = function() {            var _this = this;            var startCoords = {};            var endCoords = {};            var isDraging = false;            var isMoved = false;            // Allow x direction drag            var allowX = false;            // Allow Y direction drag            var allowY = false;            _this.core.$slide.on('mousedown.lg.zoom', function(e) {                // execute only on .lg-object                var $image = _this.core.$slide.eq(_this.core.index).find('.lg-object');                allowY = $image.prop('offsetHeight') * $image.attr('data-scale') > _this.core.$outer.find('.lg').height();                allowX = $image.prop('offsetWidth') * $image.attr('data-scale') > _this.core.$outer.find('.lg').width();                if (_this.core.$outer.hasClass('lg-zoomed')) {                    if ($(e.target).hasClass('lg-object') && (allowX || allowY)) {                        e.preventDefault();                        startCoords = {                            x: e.pageX,                            y: e.pageY                        };                        isDraging = true;                        // ** Fix for webkit cursor issue https://code.google.com/p/chromium/issues/detail?id=26723                        _this.core.$outer.scrollLeft += 1;                        _this.core.$outer.scrollLeft -= 1;                        _this.core.$outer.removeClass('lg-grab').addClass('lg-grabbing');                    }                }            });            $(window).on('mousemove.lg.zoom', function(e) {                if (isDraging) {                    var _$el = _this.core.$slide.eq(_this.core.index).find('.lg-img-wrap');                    var distanceX;                    var distanceY;                    isMoved = true;                    endCoords = {                        x: e.pageX,                        y: e.pageY                    };                    // reset opacity and transition duration                    _this.core.$outer.addClass('lg-zoom-dragging');                    if (allowY) {                        distanceY = (-Math.abs(_$el.attr('data-y'))) + (endCoords.y - startCoords.y);                    } else {                        distanceY = -Math.abs(_$el.attr('data-y'));                    }                    if (allowX) {                        distanceX = (-Math.abs(_$el.attr('data-x'))) + (endCoords.x - startCoords.x);                    } else {                        distanceX = -Math.abs(_$el.attr('data-x'));                    }                    if (_this.core.s.useLeftForZoom) {                        _$el.css({                            left: distanceX + 'px',                            top: distanceY + 'px'                        });                    } else {                        _$el.css('transform', 'translate3d(' + distanceX + 'px, ' + distanceY + 'px, 0)');                    }                }            });            $(window).on('mouseup.lg.zoom', function(e) {                if (isDraging) {                    isDraging = false;                    _this.core.$outer.removeClass('lg-zoom-dragging');                    // Fix for chrome mouse move on click                    if (isMoved && ((startCoords.x !== endCoords.x) || (startCoords.y !== endCoords.y))) {                        endCoords = {                            x: e.pageX,                            y: e.pageY                        };                        _this.touchendZoom(startCoords, endCoords, allowX, allowY);                    }                    isMoved = false;                }                _this.core.$outer.removeClass('lg-grabbing').addClass('lg-grab');            });        };        Zoom.prototype.touchendZoom = function(startCoords, endCoords, allowX, allowY) {            var _this = this;            var _$el = _this.core.$slide.eq(_this.core.index).find('.lg-img-wrap');            var $image = _this.core.$slide.eq(_this.core.index).find('.lg-object');            var distanceX = (-Math.abs(_$el.attr('data-x'))) + (endCoords.x - startCoords.x);            var distanceY = (-Math.abs(_$el.attr('data-y'))) + (endCoords.y - startCoords.y);            var minY = (_this.core.$outer.find('.lg').height() - $image.prop('offsetHeight')) / 2;            var maxY = Math.abs(($image.prop('offsetHeight') * Math.abs($image.attr('data-scale'))) - _this.core.$outer.find('.lg').height() + minY);            var minX = (_this.core.$outer.find('.lg').width() - $image.prop('offsetWidth')) / 2;            var maxX = Math.abs(($image.prop('offsetWidth') * Math.abs($image.attr('data-scale'))) - _this.core.$outer.find('.lg').width() + minX);            if ((Math.abs(endCoords.x - startCoords.x) > 15) || (Math.abs(endCoords.y - startCoords.y) > 15)) {                if (allowY) {                    if (distanceY <= -maxY) {                        distanceY = -maxY;                    } else if (distanceY >= -minY) {                        distanceY = -minY;                    }                }                if (allowX) {                    if (distanceX <= -maxX) {                        distanceX = -maxX;                    } else if (distanceX >= -minX) {                        distanceX = -minX;                    }                }                if (allowY) {                    _$el.attr('data-y', Math.abs(distanceY));                } else {                    distanceY = -Math.abs(_$el.attr('data-y'));                }                if (allowX) {                    _$el.attr('data-x', Math.abs(distanceX));                } else {                    distanceX = -Math.abs(_$el.attr('data-x'));                }                if (_this.core.s.useLeftForZoom) {                    _$el.css({                        left: distanceX + 'px',                        top: distanceY + 'px'                    });                } else {                    _$el.css('transform', 'translate3d(' + distanceX + 'px, ' + distanceY + 'px, 0)');                }            }        };        Zoom.prototype.destroy = function() {            var _this = this;            // Unbind all events added by lightGallery zoom plugin            _this.core.$el.off('.lg.zoom');            $(window).off('.lg.zoom');            _this.core.$slide.off('.lg.zoom');            _this.core.$el.off('.lg.tm.zoom');            _this.resetZoom();            clearTimeout(_this.zoomabletimeout);            _this.zoomabletimeout = false;        };        $.fn.lightGallery.modules.zoom = Zoom;    })();}));/*! lg-hash - v1.0.4 - 2017-12-20* http://sachinchoolur.github.io/lightGallery* Copyright (c) 2017 Sachin N; Licensed GPLv3 */(function (root, factory) {    if (typeof define === 'function' && define.amd) {        // AMD. Register as an anonymous module unless amdModuleId is set        define(['jquery'], function (a0) {            return (factory(a0));        });    } else if (typeof exports === 'object') {        // Node. Does not work with strict CommonJS, but        // only CommonJS-like environments that support module.exports,        // like Node.        module.exports = factory(require('jquery'));    } else {        factory(jQuery);    }}(this, function ($) {    (function() {        'use strict';        var defaults = {            hash: true        };        var Hash = function(element) {            this.core = $(element).data('lightGallery');            this.core.s = $.extend({}, defaults, this.core.s);            if (this.core.s.hash) {                this.oldHash = window.location.hash;                this.init();            }            return this;        };        Hash.prototype.init = function() {            var _this = this;            var _hash;            // Change hash value on after each slide transition            _this.core.$el.on('onAfterSlide.lg.tm', function(event, prevIndex, index) {                if (history.replaceState) {                    history.replaceState(null, null, window.location.pathname + window.location.search + '#lg=' + _this.core.s.galleryId + '&slide=' + index);                } else {                    window.location.hash = 'lg=' + _this.core.s.galleryId + '&slide=' + index;                }            });            // Listen hash change and change the slide according to slide value            $(window).on('hashchange.lg.hash', function() {                _hash = window.location.hash;                var _idx = parseInt(_hash.split('&slide=')[1], 10);                // it galleryId doesn't exist in the url close the gallery                if ((_hash.indexOf('lg=' + _this.core.s.galleryId) > -1)) {                    _this.core.slide(_idx, false, false);                } else if (_this.core.lGalleryOn) {                    _this.core.destroy();                }            });        };        Hash.prototype.destroy = function() {            if (!this.core.s.hash) {                return;            }            // Reset to old hash value            if (this.oldHash && this.oldHash.indexOf('lg=' + this.core.s.galleryId) < 0) {                if (history.replaceState) {                    history.replaceState(null, null, this.oldHash);                } else {                    window.location.hash = this.oldHash;                }            } else {                if (history.replaceState) {                    history.replaceState(null, document.title, window.location.pathname + window.location.search);                } else {                    window.location.hash = '';                }            }            this.core.$el.off('.lg.hash');        };        $.fn.lightGallery.modules.hash = Hash;    })();}));/*! lg-share - v1.1.0 - 2017-10-03* http://sachinchoolur.github.io/lightGallery* Copyright (c) 2017 Sachin N; Licensed GPLv3 */(function (root, factory) {    if (typeof define === 'function' && define.amd) {        // AMD. Register as an anonymous module unless amdModuleId is set        define(['jquery'], function (a0) {            return (factory(a0));        });    } else if (typeof exports === 'object') {        // Node. Does not work with strict CommonJS, but        // only CommonJS-like environments that support module.exports,        // like Node.        module.exports = factory(require('jquery'));    } else {        factory(jQuery);    }}(this, function ($) {    (function() {        'use strict';        var defaults = {            share: true,            facebook: true,            facebookDropdownText: 'Facebook',            twitter: true,            twitterDropdownText: 'Twitter',            googlePlus: true,            googlePlusDropdownText: 'GooglePlus',            pinterest: true,            pinterestDropdownText: 'Pinterest'        };        var Share = function(element) {            this.core = $(element).data('lightGallery');            this.core.s = $.extend({}, defaults, this.core.s);            if (this.core.s.share) {                this.init();            }            return this;        };        Share.prototype.init = function() {            var _this = this;            var shareHtml = '<span id="lg-share" class="lg-icon">' +                '<ul class="lg-dropdown" style="position: absolute;">';            shareHtml += _this.core.s.facebook ? '<li><a id="lg-share-facebook" target="_blank"><span class="lg-icon"></span><span class="lg-dropdown-text">' + this.core.s.facebookDropdownText + '</span></a></li>' : '';            shareHtml += _this.core.s.twitter ? '<li><a id="lg-share-twitter" target="_blank"><span class="lg-icon"></span><span class="lg-dropdown-text">' + this.core.s.twitterDropdownText + '</span></a></li>' : '';            shareHtml += _this.core.s.googlePlus ? '<li><a id="lg-share-googleplus" target="_blank"><span class="lg-icon"></span><span class="lg-dropdown-text">' + this.core.s.googlePlusDropdownText + '</span></a></li>' : '';            shareHtml += _this.core.s.pinterest ? '<li><a id="lg-share-pinterest" target="_blank"><span class="lg-icon"></span><span class="lg-dropdown-text">' + this.core.s.pinterestDropdownText + '</span></a></li>' : '';            shareHtml += '</ul></span>';            this.core.$outer.find('.lg-toolbar').append(shareHtml);            this.core.$outer.find('.lg').append('<div id="lg-dropdown-overlay"></div>');            $('#lg-share').on('click.lg', function(){                _this.core.$outer.toggleClass('lg-dropdown-active');            });            $('#lg-dropdown-overlay').on('click.lg', function(){                _this.core.$outer.removeClass('lg-dropdown-active');            });            _this.core.$el.on('onAfterSlide.lg.tm', function(event, prevIndex, index) {                setTimeout(function() {                    $('#lg-share-facebook').attr('href', 'https://www.facebook.com/sharer/sharer.php?u=' + (encodeURIComponent(_this.getSahreProps(index, 'facebookShareUrl') || window.location.href)));                    $('#lg-share-twitter').attr('href', 'https://twitter.com/intent/tweet?text=' + _this.getSahreProps(index, 'tweetText') + '&url=' + (encodeURIComponent(_this.getSahreProps(index, 'twitterShareUrl') || window.location.href)));                    $('#lg-share-googleplus').attr('href', 'https://plus.google.com/share?url=' + (encodeURIComponent(_this.getSahreProps(index, 'googleplusShareUrl') || window.location.href)));                    $('#lg-share-pinterest').attr('href', 'http://www.pinterest.com/pin/create/button/?url=' + (encodeURIComponent(_this.getSahreProps(index, 'pinterestShareUrl') || window.location.href)) + '&media=' + encodeURIComponent(_this.getSahreProps(index, 'src')) + '&description=' + _this.getSahreProps(index, 'pinterestText'));                }, 100);            });        };        Share.prototype.getSahreProps = function(index, prop){            var shareProp = '';            if(this.core.s.dynamic) {                shareProp = this.core.s.dynamicEl[index][prop];            } else {                var _href = this.core.$items.eq(index).attr('href');                var _prop = this.core.$items.eq(index).data(prop);                shareProp = prop === 'src' ? _href || _prop : _prop;            }            return shareProp;        };        Share.prototype.destroy = function() {        };        $.fn.lightGallery.modules.share = Share;    })();}));/** * @license * Lodash (Custom Build) <https://lodash.com/> * Build: `lodash include="debounce,throttle"` * Copyright JS Foundation and other contributors <https://js.foundation/> * Released under MIT license <https://lodash.com/license> * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE> * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors */;(function() {  /** Used as a safe reference for `undefined` in pre-ES5 environments. */  var undefined;  /** Used as the semantic version number. */  var VERSION = '4.17.5';  /** Error message constants. */  var FUNC_ERROR_TEXT = 'Expected a function';  /** Used as references for various `Number` constants. */  var NAN = 0 / 0;  /** `Object#toString` result references. */  var nullTag = '[object Null]',      symbolTag = '[object Symbol]',      undefinedTag = '[object Undefined]';  /** Used to match leading and trailing whitespace. */  var reTrim = /^\s+|\s+$/g;  /** Used to detect bad signed hexadecimal string values. */  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;  /** Used to detect binary string values. */  var reIsBinary = /^0b[01]+$/i;  /** Used to detect octal string values. */  var reIsOctal = /^0o[0-7]+$/i;  /** Built-in method references without a dependency on `root`. */  var freeParseInt = parseInt;  /** Detect free variable `global` from Node.js. */  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;  /** Detect free variable `self`. */  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;  /** Used as a reference to the global object. */  var root = freeGlobal || freeSelf || Function('return this')();  /** Detect free variable `exports`. */  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;  /** Detect free variable `module`. */  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;  /*--------------------------------------------------------------------------*/  /** Used for built-in method references. */  var objectProto = Object.prototype;  /** Used to check objects for own properties. */  var hasOwnProperty = objectProto.hasOwnProperty;  /**   * Used to resolve the   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)   * of values.   */  var nativeObjectToString = objectProto.toString;  /** Built-in value references. */  var Symbol = root.Symbol,      symToStringTag = Symbol ? Symbol.toStringTag : undefined;  /* Built-in method references for those with the same name as other `lodash` methods. */  var nativeMax = Math.max,      nativeMin = Math.min;  /** Used to lookup unminified function names. */  var realNames = {};  /*------------------------------------------------------------------------*/  /**   * Creates a `lodash` object which wraps `value` to enable implicit method   * chain sequences. Methods that operate on and return arrays, collections,   * and functions can be chained together. Methods that retrieve a single value   * or may return a primitive value will automatically end the chain sequence   * and return the unwrapped value. Otherwise, the value must be unwrapped   * with `_#value`.   *   * Explicit chain sequences, which must be unwrapped with `_#value`, may be   * enabled using `_.chain`.   *   * The execution of chained methods is lazy, that is, it's deferred until   * `_#value` is implicitly or explicitly called.   *   * Lazy evaluation allows several methods to support shortcut fusion.   * Shortcut fusion is an optimization to merge iteratee calls; this avoids   * the creation of intermediate arrays and can greatly reduce the number of   * iteratee executions. Sections of a chain sequence qualify for shortcut   * fusion if the section is applied to an array and iteratees accept only   * one argument. The heuristic for whether a section qualifies for shortcut   * fusion is subject to change.   *   * Chaining is supported in custom builds as long as the `_#value` method is   * directly or indirectly included in the build.   *   * In addition to lodash methods, wrappers have `Array` and `String` methods.   *   * The wrapper `Array` methods are:   * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`   *   * The wrapper `String` methods are:   * `replace` and `split`   *   * The wrapper methods that support shortcut fusion are:   * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,   * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,   * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`   *   * The chainable wrapper methods are:   * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,   * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,   * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,   * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,   * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,   * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,   * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,   * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,   * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,   * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,   * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,   * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,   * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,   * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,   * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,   * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,   * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,   * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,   * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,   * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,   * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,   * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,   * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,   * `zipObject`, `zipObjectDeep`, and `zipWith`   *   * The wrapper methods that are **not** chainable by default are:   * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,   * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,   * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,   * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,   * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,   * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,   * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,   * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,   * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,   * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,   * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,   * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,   * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,   * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,   * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,   * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,   * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,   * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,   * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,   * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,   * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,   * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,   * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,   * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,   * `upperFirst`, `value`, and `words`   *   * @name _   * @constructor   * @category Seq   * @param {*} value The value to wrap in a `lodash` instance.   * @returns {Object} Returns the new `lodash` wrapper instance.   * @example   *   * function square(n) {   *   return n * n;   * }   *   * var wrapped = _([1, 2, 3]);   *   * // Returns an unwrapped value.   * wrapped.reduce(_.add);   * // => 6   *   * // Returns a wrapped value.   * var squares = wrapped.map(square);   *   * _.isArray(squares);   * // => false   *   * _.isArray(squares.value());   * // => true   */  function lodash() {    // No operation performed.  }  /*------------------------------------------------------------------------*/  /**   * The base implementation of `getTag` without fallbacks for buggy environments.   *   * @private   * @param {*} value The value to query.   * @returns {string} Returns the `toStringTag`.   */  function baseGetTag(value) {    if (value == null) {      return value === undefined ? undefinedTag : nullTag;    }    return (symToStringTag && symToStringTag in Object(value))      ? getRawTag(value)      : objectToString(value);  }  /**   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.   *   * @private   * @param {*} value The value to query.   * @returns {string} Returns the raw `toStringTag`.   */  function getRawTag(value) {    var isOwn = hasOwnProperty.call(value, symToStringTag),        tag = value[symToStringTag];    try {      value[symToStringTag] = undefined;      var unmasked = true;    } catch (e) {}    var result = nativeObjectToString.call(value);    if (unmasked) {      if (isOwn) {        value[symToStringTag] = tag;      } else {        delete value[symToStringTag];      }    }    return result;  }  /**   * Converts `value` to a string using `Object.prototype.toString`.   *   * @private   * @param {*} value The value to convert.   * @returns {string} Returns the converted string.   */  function objectToString(value) {    return nativeObjectToString.call(value);  }  /*------------------------------------------------------------------------*/  /**   * Gets the timestamp of the number of milliseconds that have elapsed since   * the Unix epoch (1 January 1970 00:00:00 UTC).   *   * @static   * @memberOf _   * @since 2.4.0   * @category Date   * @returns {number} Returns the timestamp.   * @example   *   * _.defer(function(stamp) {   *   console.log(_.now() - stamp);   * }, _.now());   * // => Logs the number of milliseconds it took for the deferred invocation.   */  var now = function() {    return root.Date.now();  };  /*------------------------------------------------------------------------*/  /**   * Creates a debounced function that delays invoking `func` until after `wait`   * milliseconds have elapsed since the last time the debounced function was   * invoked. The debounced function comes with a `cancel` method to cancel   * delayed `func` invocations and a `flush` method to immediately invoke them.   * Provide `options` to indicate whether `func` should be invoked on the   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked   * with the last arguments provided to the debounced function. Subsequent   * calls to the debounced function return the result of the last `func`   * invocation.   *   * **Note:** If `leading` and `trailing` options are `true`, `func` is   * invoked on the trailing edge of the timeout only if the debounced function   * is invoked more than once during the `wait` timeout.   *   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred   * until to the next tick, similar to `setTimeout` with a timeout of `0`.   *   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)   * for details over the differences between `_.debounce` and `_.throttle`.   *   * @static   * @memberOf _   * @since 0.1.0   * @category Function   * @param {Function} func The function to debounce.   * @param {number} [wait=0] The number of milliseconds to delay.   * @param {Object} [options={}] The options object.   * @param {boolean} [options.leading=false]   *  Specify invoking on the leading edge of the timeout.   * @param {number} [options.maxWait]   *  The maximum time `func` is allowed to be delayed before it's invoked.   * @param {boolean} [options.trailing=true]   *  Specify invoking on the trailing edge of the timeout.   * @returns {Function} Returns the new debounced function.   * @example   *   * // Avoid costly calculations while the window size is in flux.   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));   *   * // Invoke `sendMail` when clicked, debouncing subsequent calls.   * jQuery(element).on('click', _.debounce(sendMail, 300, {   *   'leading': true,   *   'trailing': false   * }));   *   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });   * var source = new EventSource('/stream');   * jQuery(source).on('message', debounced);   *   * // Cancel the trailing debounced invocation.   * jQuery(window).on('popstate', debounced.cancel);   */  function debounce(func, wait, options) {    var lastArgs,        lastThis,        maxWait,        result,        timerId,        lastCallTime,        lastInvokeTime = 0,        leading = false,        maxing = false,        trailing = true;    if (typeof func != 'function') {      throw new TypeError(FUNC_ERROR_TEXT);    }    wait = toNumber(wait) || 0;    if (isObject(options)) {      leading = !!options.leading;      maxing = 'maxWait' in options;      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;      trailing = 'trailing' in options ? !!options.trailing : trailing;    }    function invokeFunc(time) {      var args = lastArgs,          thisArg = lastThis;      lastArgs = lastThis = undefined;      lastInvokeTime = time;      result = func.apply(thisArg, args);      return result;    }    function leadingEdge(time) {      // Reset any `maxWait` timer.      lastInvokeTime = time;      // Start the timer for the trailing edge.      timerId = setTimeout(timerExpired, wait);      // Invoke the leading edge.      return leading ? invokeFunc(time) : result;    }    function remainingWait(time) {      var timeSinceLastCall = time - lastCallTime,          timeSinceLastInvoke = time - lastInvokeTime,          timeWaiting = wait - timeSinceLastCall;      return maxing        ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)        : timeWaiting;    }    function shouldInvoke(time) {      var timeSinceLastCall = time - lastCallTime,          timeSinceLastInvoke = time - lastInvokeTime;      // Either this is the first call, activity has stopped and we're at the      // trailing edge, the system time has gone backwards and we're treating      // it as the trailing edge, or we've hit the `maxWait` limit.      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));    }    function timerExpired() {      var time = now();      if (shouldInvoke(time)) {        return trailingEdge(time);      }      // Restart the timer.      timerId = setTimeout(timerExpired, remainingWait(time));    }    function trailingEdge(time) {      timerId = undefined;      // Only invoke if we have `lastArgs` which means `func` has been      // debounced at least once.      if (trailing && lastArgs) {        return invokeFunc(time);      }      lastArgs = lastThis = undefined;      return result;    }    function cancel() {      if (timerId !== undefined) {        clearTimeout(timerId);      }      lastInvokeTime = 0;      lastArgs = lastCallTime = lastThis = timerId = undefined;    }    function flush() {      return timerId === undefined ? result : trailingEdge(now());    }    function debounced() {      var time = now(),          isInvoking = shouldInvoke(time);      lastArgs = arguments;      lastThis = this;      lastCallTime = time;      if (isInvoking) {        if (timerId === undefined) {          return leadingEdge(lastCallTime);        }        if (maxing) {          // Handle invocations in a tight loop.          timerId = setTimeout(timerExpired, wait);          return invokeFunc(lastCallTime);        }      }      if (timerId === undefined) {        timerId = setTimeout(timerExpired, wait);      }      return result;    }    debounced.cancel = cancel;    debounced.flush = flush;    return debounced;  }  /**   * Creates a throttled function that only invokes `func` at most once per   * every `wait` milliseconds. The throttled function comes with a `cancel`   * method to cancel delayed `func` invocations and a `flush` method to   * immediately invoke them. Provide `options` to indicate whether `func`   * should be invoked on the leading and/or trailing edge of the `wait`   * timeout. The `func` is invoked with the last arguments provided to the   * throttled function. Subsequent calls to the throttled function return the   * result of the last `func` invocation.   *   * **Note:** If `leading` and `trailing` options are `true`, `func` is   * invoked on the trailing edge of the timeout only if the throttled function   * is invoked more than once during the `wait` timeout.   *   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred   * until to the next tick, similar to `setTimeout` with a timeout of `0`.   *   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)   * for details over the differences between `_.throttle` and `_.debounce`.   *   * @static   * @memberOf _   * @since 0.1.0   * @category Function   * @param {Function} func The function to throttle.   * @param {number} [wait=0] The number of milliseconds to throttle invocations to.   * @param {Object} [options={}] The options object.   * @param {boolean} [options.leading=true]   *  Specify invoking on the leading edge of the timeout.   * @param {boolean} [options.trailing=true]   *  Specify invoking on the trailing edge of the timeout.   * @returns {Function} Returns the new throttled function.   * @example   *   * // Avoid excessively updating the position while scrolling.   * jQuery(window).on('scroll', _.throttle(updatePosition, 100));   *   * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.   * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });   * jQuery(element).on('click', throttled);   *   * // Cancel the trailing throttled invocation.   * jQuery(window).on('popstate', throttled.cancel);   */  function throttle(func, wait, options) {    var leading = true,        trailing = true;    if (typeof func != 'function') {      throw new TypeError(FUNC_ERROR_TEXT);    }    if (isObject(options)) {      leading = 'leading' in options ? !!options.leading : leading;      trailing = 'trailing' in options ? !!options.trailing : trailing;    }    return debounce(func, wait, {      'leading': leading,      'maxWait': wait,      'trailing': trailing    });  }  /*------------------------------------------------------------------------*/  /**   * Checks if `value` is the   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)   *   * @static   * @memberOf _   * @since 0.1.0   * @category Lang   * @param {*} value The value to check.   * @returns {boolean} Returns `true` if `value` is an object, else `false`.   * @example   *   * _.isObject({});   * // => true   *   * _.isObject([1, 2, 3]);   * // => true   *   * _.isObject(_.noop);   * // => true   *   * _.isObject(null);   * // => false   */  function isObject(value) {    var type = typeof value;    return value != null && (type == 'object' || type == 'function');  }  /**   * Checks if `value` is object-like. A value is object-like if it's not `null`   * and has a `typeof` result of "object".   *   * @static   * @memberOf _   * @since 4.0.0   * @category Lang   * @param {*} value The value to check.   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.   * @example   *   * _.isObjectLike({});   * // => true   *   * _.isObjectLike([1, 2, 3]);   * // => true   *   * _.isObjectLike(_.noop);   * // => false   *   * _.isObjectLike(null);   * // => false   */  function isObjectLike(value) {    return value != null && typeof value == 'object';  }  /**   * Checks if `value` is classified as a `Symbol` primitive or object.   *   * @static   * @memberOf _   * @since 4.0.0   * @category Lang   * @param {*} value The value to check.   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.   * @example   *   * _.isSymbol(Symbol.iterator);   * // => true   *   * _.isSymbol('abc');   * // => false   */  function isSymbol(value) {    return typeof value == 'symbol' ||      (isObjectLike(value) && baseGetTag(value) == symbolTag);  }  /**   * Converts `value` to a number.   *   * @static   * @memberOf _   * @since 4.0.0   * @category Lang   * @param {*} value The value to process.   * @returns {number} Returns the number.   * @example   *   * _.toNumber(3.2);   * // => 3.2   *   * _.toNumber(Number.MIN_VALUE);   * // => 5e-324   *   * _.toNumber(Infinity);   * // => Infinity   *   * _.toNumber('3.2');   * // => 3.2   */  function toNumber(value) {    if (typeof value == 'number') {      return value;    }    if (isSymbol(value)) {      return NAN;    }    if (isObject(value)) {      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;      value = isObject(other) ? (other + '') : other;    }    if (typeof value != 'string') {      return value === 0 ? value : +value;    }    value = value.replace(reTrim, '');    var isBinary = reIsBinary.test(value);    return (isBinary || reIsOctal.test(value))      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)      : (reIsBadHex.test(value) ? NAN : +value);  }  /*------------------------------------------------------------------------*/  // Add methods that return wrapped values in chain sequences.  lodash.debounce = debounce;  lodash.throttle = throttle;  /*------------------------------------------------------------------------*/  // Add methods that return unwrapped values in chain sequences.  lodash.isObject = isObject;  lodash.isObjectLike = isObjectLike;  lodash.isSymbol = isSymbol;  lodash.now = now;  lodash.toNumber = toNumber;  /*------------------------------------------------------------------------*/  /**   * The semantic version number.   *   * @static   * @memberOf _   * @type {string}   */  lodash.VERSION = VERSION;  /*--------------------------------------------------------------------------*/  // Some AMD build optimizers, like r.js, check for condition patterns like:  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {    // Expose Lodash on the global object to prevent errors when Lodash is    // loaded by a script tag in the presence of an AMD loader.    // See http://requirejs.org/docs/errors.html#mismatch for more details.    // Use `_.noConflict` to remove Lodash from the global object.    root._ = lodash;    // Define as an anonymous module so, through path mapping, it can be    // referenced as the "underscore" module.    define(function() {      return lodash;    });  }  // Check for `exports` after `define` in case a build optimizer adds it.  else if (freeModule) {    // Export for Node.js.    (freeModule.exports = lodash)._ = lodash;    // Export for CommonJS support.    freeExports._ = lodash;  }  else {    // Export to the global object.    root._ = lodash;  }}.call(this));/** * Swiper 4.4.2 * Most modern mobile touch slider and framework with hardware accelerated transitions * http://www.idangero.us/swiper/ * * Copyright 2014-2018 Vladimir Kharlampidi * * Released under the MIT License * * Released on: November 1, 2018 */(function (global, factory) {  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  typeof define === 'function' && define.amd ? define(factory) :  (global.Swiper = factory());}(this, (function () { 'use strict';  /**   * SSR Window 1.0.1   * Better handling for window object in SSR environment   * https://github.com/nolimits4web/ssr-window   *   * Copyright 2018, Vladimir Kharlampidi   *   * Licensed under MIT   *   * Released on: July 18, 2018   */  var doc = (typeof document === 'undefined') ? {    body: {},    addEventListener: function addEventListener() {},    removeEventListener: function removeEventListener() {},    activeElement: {      blur: function blur() {},      nodeName: '',    },    querySelector: function querySelector() {      return null;    },    querySelectorAll: function querySelectorAll() {      return [];    },    getElementById: function getElementById() {      return null;    },    createEvent: function createEvent() {      return {        initEvent: function initEvent() {},      };    },    createElement: function createElement() {      return {        children: [],        childNodes: [],        style: {},        setAttribute: function setAttribute() {},        getElementsByTagName: function getElementsByTagName() {          return [];        },      };    },    location: { hash: '' },  } : document; // eslint-disable-line  var win = (typeof window === 'undefined') ? {    document: doc,    navigator: {      userAgent: '',    },    location: {},    history: {},    CustomEvent: function CustomEvent() {      return this;    },    addEventListener: function addEventListener() {},    removeEventListener: function removeEventListener() {},    getComputedStyle: function getComputedStyle() {      return {        getPropertyValue: function getPropertyValue() {          return '';        },      };    },    Image: function Image() {},    Date: function Date() {},    screen: {},    setTimeout: function setTimeout() {},    clearTimeout: function clearTimeout() {},  } : window; // eslint-disable-line  /**   * Dom7 2.1.2   * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API   * http://framework7.io/docs/dom.html   *   * Copyright 2018, Vladimir Kharlampidi   * The iDangero.us   * http://www.idangero.us/   *   * Licensed under MIT   *   * Released on: September 13, 2018   */  var Dom7 = function Dom7(arr) {    var self = this;    // Create array-like object    for (var i = 0; i < arr.length; i += 1) {      self[i] = arr[i];    }    self.length = arr.length;    // Return collection with methods    return this;  };  function $(selector, context) {    var arr = [];    var i = 0;    if (selector && !context) {      if (selector instanceof Dom7) {        return selector;      }    }    if (selector) {        // String      if (typeof selector === 'string') {        var els;        var tempParent;        var html = selector.trim();        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {          var toCreate = 'div';          if (html.indexOf('<li') === 0) { toCreate = 'ul'; }          if (html.indexOf('<tr') === 0) { toCreate = 'tbody'; }          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) { toCreate = 'tr'; }          if (html.indexOf('<tbody') === 0) { toCreate = 'table'; }          if (html.indexOf('<option') === 0) { toCreate = 'select'; }          tempParent = doc.createElement(toCreate);          tempParent.innerHTML = html;          for (i = 0; i < tempParent.childNodes.length; i += 1) {            arr.push(tempParent.childNodes[i]);          }        } else {          if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {            // Pure ID selector            els = [doc.getElementById(selector.trim().split('#')[1])];          } else {            // Other selectors            els = (context || doc).querySelectorAll(selector.trim());          }          for (i = 0; i < els.length; i += 1) {            if (els[i]) { arr.push(els[i]); }          }        }      } else if (selector.nodeType || selector === win || selector === doc) {        // Node/element        arr.push(selector);      } else if (selector.length > 0 && selector[0].nodeType) {        // Array of elements or instance of Dom        for (i = 0; i < selector.length; i += 1) {          arr.push(selector[i]);        }      }    }    return new Dom7(arr);  }  $.fn = Dom7.prototype;  $.Class = Dom7;  $.Dom7 = Dom7;  function unique(arr) {    var uniqueArray = [];    for (var i = 0; i < arr.length; i += 1) {      if (uniqueArray.indexOf(arr[i]) === -1) { uniqueArray.push(arr[i]); }    }    return uniqueArray;  }  // Classes and attributes  function addClass(className) {    if (typeof className === 'undefined') {      return this;    }    var classes = className.split(' ');    for (var i = 0; i < classes.length; i += 1) {      for (var j = 0; j < this.length; j += 1) {        if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') { this[j].classList.add(classes[i]); }      }    }    return this;  }  function removeClass(className) {    var classes = className.split(' ');    for (var i = 0; i < classes.length; i += 1) {      for (var j = 0; j < this.length; j += 1) {        if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') { this[j].classList.remove(classes[i]); }      }    }    return this;  }  function hasClass(className) {    if (!this[0]) { return false; }    return this[0].classList.contains(className);  }  function toggleClass(className) {    var classes = className.split(' ');    for (var i = 0; i < classes.length; i += 1) {      for (var j = 0; j < this.length; j += 1) {        if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') { this[j].classList.toggle(classes[i]); }      }    }    return this;  }  function attr(attrs, value) {    var arguments$1 = arguments;    if (arguments.length === 1 && typeof attrs === 'string') {      // Get attr      if (this[0]) { return this[0].getAttribute(attrs); }      return undefined;    }    // Set attrs    for (var i = 0; i < this.length; i += 1) {      if (arguments$1.length === 2) {        // String        this[i].setAttribute(attrs, value);      } else {        // Object        // eslint-disable-next-line        for (var attrName in attrs) {          this[i][attrName] = attrs[attrName];          this[i].setAttribute(attrName, attrs[attrName]);        }      }    }    return this;  }  // eslint-disable-next-line  function removeAttr(attr) {    for (var i = 0; i < this.length; i += 1) {      this[i].removeAttribute(attr);    }    return this;  }  function data(key, value) {    var el;    if (typeof value === 'undefined') {      el = this[0];      // Get value      if (el) {        if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {          return el.dom7ElementDataStorage[key];        }        var dataKey = el.getAttribute(("data-" + key));        if (dataKey) {          return dataKey;        }        return undefined;      }      return undefined;    }    // Set value    for (var i = 0; i < this.length; i += 1) {      el = this[i];      if (!el.dom7ElementDataStorage) { el.dom7ElementDataStorage = {}; }      el.dom7ElementDataStorage[key] = value;    }    return this;  }  // Transforms  // eslint-disable-next-line  function transform(transform) {    for (var i = 0; i < this.length; i += 1) {      var elStyle = this[i].style;      elStyle.webkitTransform = transform;      elStyle.transform = transform;    }    return this;  }  function transition(duration) {    if (typeof duration !== 'string') {      duration = duration + "ms"; // eslint-disable-line    }    for (var i = 0; i < this.length; i += 1) {      var elStyle = this[i].style;      elStyle.webkitTransitionDuration = duration;      elStyle.transitionDuration = duration;    }    return this;  }  // Events  function on() {    var assign;    var args = [], len = arguments.length;    while ( len-- ) args[ len ] = arguments[ len ];    var eventType = args[0];    var targetSelector = args[1];    var listener = args[2];    var capture = args[3];    if (typeof args[1] === 'function') {      (assign = args, eventType = assign[0], listener = assign[1], capture = assign[2]);      targetSelector = undefined;    }    if (!capture) { capture = false; }    function handleLiveEvent(e) {      var target = e.target;      if (!target) { return; }      var eventData = e.target.dom7EventData || [];      if (eventData.indexOf(e) < 0) {        eventData.unshift(e);      }      if ($(target).is(targetSelector)) { listener.apply(target, eventData); }      else {        var parents = $(target).parents(); // eslint-disable-line        for (var k = 0; k < parents.length; k += 1) {          if ($(parents[k]).is(targetSelector)) { listener.apply(parents[k], eventData); }        }      }    }    function handleEvent(e) {      var eventData = e && e.target ? e.target.dom7EventData || [] : [];      if (eventData.indexOf(e) < 0) {        eventData.unshift(e);      }      listener.apply(this, eventData);    }    var events = eventType.split(' ');    var j;    for (var i = 0; i < this.length; i += 1) {      var el = this[i];      if (!targetSelector) {        for (j = 0; j < events.length; j += 1) {          var event = events[j];          if (!el.dom7Listeners) { el.dom7Listeners = {}; }          if (!el.dom7Listeners[event]) { el.dom7Listeners[event] = []; }          el.dom7Listeners[event].push({            listener: listener,            proxyListener: handleEvent,          });          el.addEventListener(event, handleEvent, capture);        }      } else {        // Live events        for (j = 0; j < events.length; j += 1) {          var event$1 = events[j];          if (!el.dom7LiveListeners) { el.dom7LiveListeners = {}; }          if (!el.dom7LiveListeners[event$1]) { el.dom7LiveListeners[event$1] = []; }          el.dom7LiveListeners[event$1].push({            listener: listener,            proxyListener: handleLiveEvent,          });          el.addEventListener(event$1, handleLiveEvent, capture);        }      }    }    return this;  }  function off() {    var assign;    var args = [], len = arguments.length;    while ( len-- ) args[ len ] = arguments[ len ];    var eventType = args[0];    var targetSelector = args[1];    var listener = args[2];    var capture = args[3];    if (typeof args[1] === 'function') {      (assign = args, eventType = assign[0], listener = assign[1], capture = assign[2]);      targetSelector = undefined;    }    if (!capture) { capture = false; }    var events = eventType.split(' ');    for (var i = 0; i < events.length; i += 1) {      var event = events[i];      for (var j = 0; j < this.length; j += 1) {        var el = this[j];        var handlers = (void 0);        if (!targetSelector && el.dom7Listeners) {          handlers = el.dom7Listeners[event];        } else if (targetSelector && el.dom7LiveListeners) {          handlers = el.dom7LiveListeners[event];        }        if (handlers && handlers.length) {          for (var k = handlers.length - 1; k >= 0; k -= 1) {            var handler = handlers[k];            if (listener && handler.listener === listener) {              el.removeEventListener(event, handler.proxyListener, capture);              handlers.splice(k, 1);            } else if (!listener) {              el.removeEventListener(event, handler.proxyListener, capture);              handlers.splice(k, 1);            }          }        }      }    }    return this;  }  function trigger() {    var args = [], len = arguments.length;    while ( len-- ) args[ len ] = arguments[ len ];    var events = args[0].split(' ');    var eventData = args[1];    for (var i = 0; i < events.length; i += 1) {      var event = events[i];      for (var j = 0; j < this.length; j += 1) {        var el = this[j];        var evt = (void 0);        try {          evt = new win.CustomEvent(event, {            detail: eventData,            bubbles: true,            cancelable: true,          });        } catch (e) {          evt = doc.createEvent('Event');          evt.initEvent(event, true, true);          evt.detail = eventData;        }        // eslint-disable-next-line        el.dom7EventData = args.filter(function (data, dataIndex) { return dataIndex > 0; });        el.dispatchEvent(evt);        el.dom7EventData = [];        delete el.dom7EventData;      }    }    return this;  }  function transitionEnd(callback) {    var events = ['webkitTransitionEnd', 'transitionend'];    var dom = this;    var i;    function fireCallBack(e) {      /* jshint validthis:true */      if (e.target !== this) { return; }      callback.call(this, e);      for (i = 0; i < events.length; i += 1) {        dom.off(events[i], fireCallBack);      }    }    if (callback) {      for (i = 0; i < events.length; i += 1) {        dom.on(events[i], fireCallBack);      }    }    return this;  }  function outerWidth(includeMargins) {    if (this.length > 0) {      if (includeMargins) {        // eslint-disable-next-line        var styles = this.styles();        return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));      }      return this[0].offsetWidth;    }    return null;  }  function outerHeight(includeMargins) {    if (this.length > 0) {      if (includeMargins) {        // eslint-disable-next-line        var styles = this.styles();        return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));      }      return this[0].offsetHeight;    }    return null;  }  function offset() {    if (this.length > 0) {      var el = this[0];      var box = el.getBoundingClientRect();      var body = doc.body;      var clientTop = el.clientTop || body.clientTop || 0;      var clientLeft = el.clientLeft || body.clientLeft || 0;      var scrollTop = el === win ? win.scrollY : el.scrollTop;      var scrollLeft = el === win ? win.scrollX : el.scrollLeft;      return {        top: (box.top + scrollTop) - clientTop,        left: (box.left + scrollLeft) - clientLeft,      };    }    return null;  }  function styles() {    if (this[0]) { return win.getComputedStyle(this[0], null); }    return {};  }  function css(props, value) {    var i;    if (arguments.length === 1) {      if (typeof props === 'string') {        if (this[0]) { return win.getComputedStyle(this[0], null).getPropertyValue(props); }      } else {        for (i = 0; i < this.length; i += 1) {          // eslint-disable-next-line          for (var prop in props) {            this[i].style[prop] = props[prop];          }        }        return this;      }    }    if (arguments.length === 2 && typeof props === 'string') {      for (i = 0; i < this.length; i += 1) {        this[i].style[props] = value;      }      return this;    }    return this;  }  // Iterate over the collection passing elements to `callback`  function each(callback) {    // Don't bother continuing without a callback    if (!callback) { return this; }    // Iterate over the current collection    for (var i = 0; i < this.length; i += 1) {      // If the callback returns false      if (callback.call(this[i], i, this[i]) === false) {        // End the loop early        return this;      }    }    // Return `this` to allow chained DOM operations    return this;  }  // eslint-disable-next-line  function html(html) {    if (typeof html === 'undefined') {      return this[0] ? this[0].innerHTML : undefined;    }    for (var i = 0; i < this.length; i += 1) {      this[i].innerHTML = html;    }    return this;  }  // eslint-disable-next-line  function text(text) {    if (typeof text === 'undefined') {      if (this[0]) {        return this[0].textContent.trim();      }      return null;    }    for (var i = 0; i < this.length; i += 1) {      this[i].textContent = text;    }    return this;  }  function is(selector) {    var el = this[0];    var compareWith;    var i;    if (!el || typeof selector === 'undefined') { return false; }    if (typeof selector === 'string') {      if (el.matches) { return el.matches(selector); }      else if (el.webkitMatchesSelector) { return el.webkitMatchesSelector(selector); }      else if (el.msMatchesSelector) { return el.msMatchesSelector(selector); }      compareWith = $(selector);      for (i = 0; i < compareWith.length; i += 1) {        if (compareWith[i] === el) { return true; }      }      return false;    } else if (selector === doc) { return el === doc; }    else if (selector === win) { return el === win; }    if (selector.nodeType || selector instanceof Dom7) {      compareWith = selector.nodeType ? [selector] : selector;      for (i = 0; i < compareWith.length; i += 1) {        if (compareWith[i] === el) { return true; }      }      return false;    }    return false;  }  function index() {    var child = this[0];    var i;    if (child) {      i = 0;      // eslint-disable-next-line      while ((child = child.previousSibling) !== null) {        if (child.nodeType === 1) { i += 1; }      }      return i;    }    return undefined;  }  // eslint-disable-next-line  function eq(index) {    if (typeof index === 'undefined') { return this; }    var length = this.length;    var returnIndex;    if (index > length - 1) {      return new Dom7([]);    }    if (index < 0) {      returnIndex = length + index;      if (returnIndex < 0) { return new Dom7([]); }      return new Dom7([this[returnIndex]]);    }    return new Dom7([this[index]]);  }  function append() {    var args = [], len = arguments.length;    while ( len-- ) args[ len ] = arguments[ len ];    var newChild;    for (var k = 0; k < args.length; k += 1) {      newChild = args[k];      for (var i = 0; i < this.length; i += 1) {        if (typeof newChild === 'string') {          var tempDiv = doc.createElement('div');          tempDiv.innerHTML = newChild;          while (tempDiv.firstChild) {            this[i].appendChild(tempDiv.firstChild);          }        } else if (newChild instanceof Dom7) {          for (var j = 0; j < newChild.length; j += 1) {            this[i].appendChild(newChild[j]);          }        } else {          this[i].appendChild(newChild);        }      }    }    return this;  }  function prepend(newChild) {    var i;    var j;    for (i = 0; i < this.length; i += 1) {      if (typeof newChild === 'string') {        var tempDiv = doc.createElement('div');        tempDiv.innerHTML = newChild;        for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {          this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);        }      } else if (newChild instanceof Dom7) {        for (j = 0; j < newChild.length; j += 1) {          this[i].insertBefore(newChild[j], this[i].childNodes[0]);        }      } else {        this[i].insertBefore(newChild, this[i].childNodes[0]);      }    }    return this;  }  function next(selector) {    if (this.length > 0) {      if (selector) {        if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {          return new Dom7([this[0].nextElementSibling]);        }        return new Dom7([]);      }      if (this[0].nextElementSibling) { return new Dom7([this[0].nextElementSibling]); }      return new Dom7([]);    }    return new Dom7([]);  }  function nextAll(selector) {    var nextEls = [];    var el = this[0];    if (!el) { return new Dom7([]); }    while (el.nextElementSibling) {      var next = el.nextElementSibling; // eslint-disable-line      if (selector) {        if ($(next).is(selector)) { nextEls.push(next); }      } else { nextEls.push(next); }      el = next;    }    return new Dom7(nextEls);  }  function prev(selector) {    if (this.length > 0) {      var el = this[0];      if (selector) {        if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {          return new Dom7([el.previousElementSibling]);        }        return new Dom7([]);      }      if (el.previousElementSibling) { return new Dom7([el.previousElementSibling]); }      return new Dom7([]);    }    return new Dom7([]);  }  function prevAll(selector) {    var prevEls = [];    var el = this[0];    if (!el) { return new Dom7([]); }    while (el.previousElementSibling) {      var prev = el.previousElementSibling; // eslint-disable-line      if (selector) {        if ($(prev).is(selector)) { prevEls.push(prev); }      } else { prevEls.push(prev); }      el = prev;    }    return new Dom7(prevEls);  }  function parent(selector) {    var parents = []; // eslint-disable-line    for (var i = 0; i < this.length; i += 1) {      if (this[i].parentNode !== null) {        if (selector) {          if ($(this[i].parentNode).is(selector)) { parents.push(this[i].parentNode); }        } else {          parents.push(this[i].parentNode);        }      }    }    return $(unique(parents));  }  function parents(selector) {    var parents = []; // eslint-disable-line    for (var i = 0; i < this.length; i += 1) {      var parent = this[i].parentNode; // eslint-disable-line      while (parent) {        if (selector) {          if ($(parent).is(selector)) { parents.push(parent); }        } else {          parents.push(parent);        }        parent = parent.parentNode;      }    }    return $(unique(parents));  }  function closest(selector) {    var closest = this; // eslint-disable-line    if (typeof selector === 'undefined') {      return new Dom7([]);    }    if (!closest.is(selector)) {      closest = closest.parents(selector).eq(0);    }    return closest;  }  function find(selector) {    var foundElements = [];    for (var i = 0; i < this.length; i += 1) {      var found = this[i].querySelectorAll(selector);      for (var j = 0; j < found.length; j += 1) {        foundElements.push(found[j]);      }    }    return new Dom7(foundElements);  }  function children(selector) {    var children = []; // eslint-disable-line    for (var i = 0; i < this.length; i += 1) {      var childNodes = this[i].childNodes;      for (var j = 0; j < childNodes.length; j += 1) {        if (!selector) {          if (childNodes[j].nodeType === 1) { children.push(childNodes[j]); }        } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {          children.push(childNodes[j]);        }      }    }    return new Dom7(unique(children));  }  function remove() {    for (var i = 0; i < this.length; i += 1) {      if (this[i].parentNode) { this[i].parentNode.removeChild(this[i]); }    }    return this;  }  function add() {    var args = [], len = arguments.length;    while ( len-- ) args[ len ] = arguments[ len ];    var dom = this;    var i;    var j;    for (i = 0; i < args.length; i += 1) {      var toAdd = $(args[i]);      for (j = 0; j < toAdd.length; j += 1) {        dom[dom.length] = toAdd[j];        dom.length += 1;      }    }    return dom;  }  var Methods = {    addClass: addClass,    removeClass: removeClass,    hasClass: hasClass,    toggleClass: toggleClass,    attr: attr,    removeAttr: removeAttr,    data: data,    transform: transform,    transition: transition,    on: on,    off: off,    trigger: trigger,    transitionEnd: transitionEnd,    outerWidth: outerWidth,    outerHeight: outerHeight,    offset: offset,    css: css,    each: each,    html: html,    text: text,    is: is,    index: index,    eq: eq,    append: append,    prepend: prepend,    next: next,    nextAll: nextAll,    prev: prev,    prevAll: prevAll,    parent: parent,    parents: parents,    closest: closest,    find: find,    children: children,    remove: remove,    add: add,    styles: styles,  };  Object.keys(Methods).forEach(function (methodName) {    $.fn[methodName] = Methods[methodName];  });  var Utils = {    deleteProps: function deleteProps(obj) {      var object = obj;      Object.keys(object).forEach(function (key) {        try {          object[key] = null;        } catch (e) {          // no getter for object        }        try {          delete object[key];        } catch (e) {          // something got wrong        }      });    },    nextTick: function nextTick(callback, delay) {      if ( delay === void 0 ) delay = 0;      return setTimeout(callback, delay);    },    now: function now() {      return Date.now();    },    getTranslate: function getTranslate(el, axis) {      if ( axis === void 0 ) axis = 'x';      var matrix;      var curTransform;      var transformMatrix;      var curStyle = win.getComputedStyle(el, null);      if (win.WebKitCSSMatrix) {        curTransform = curStyle.transform || curStyle.webkitTransform;        if (curTransform.split(',').length > 6) {          curTransform = curTransform.split(', ').map(function (a) { return a.replace(',', '.'); }).join(', ');        }        // Some old versions of Webkit choke when 'none' is passed; pass        // empty string instead in this case        transformMatrix = new win.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);      } else {        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');        matrix = transformMatrix.toString().split(',');      }      if (axis === 'x') {        // Latest Chrome and webkits Fix        if (win.WebKitCSSMatrix) { curTransform = transformMatrix.m41; }        // Crazy IE10 Matrix        else if (matrix.length === 16) { curTransform = parseFloat(matrix[12]); }        // Normal Browsers        else { curTransform = parseFloat(matrix[4]); }      }      if (axis === 'y') {        // Latest Chrome and webkits Fix        if (win.WebKitCSSMatrix) { curTransform = transformMatrix.m42; }        // Crazy IE10 Matrix        else if (matrix.length === 16) { curTransform = parseFloat(matrix[13]); }        // Normal Browsers        else { curTransform = parseFloat(matrix[5]); }      }      return curTransform || 0;    },    parseUrlQuery: function parseUrlQuery(url) {      var query = {};      var urlToParse = url || win.location.href;      var i;      var params;      var param;      var length;      if (typeof urlToParse === 'string' && urlToParse.length) {        urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';        params = urlToParse.split('&').filter(function (paramsPart) { return paramsPart !== ''; });        length = params.length;        for (i = 0; i < length; i += 1) {          param = params[i].replace(/#\S+/g, '').split('=');          query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';        }      }      return query;    },    isObject: function isObject(o) {      return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;    },    extend: function extend() {      var args = [], len$1 = arguments.length;      while ( len$1-- ) args[ len$1 ] = arguments[ len$1 ];      var to = Object(args[0]);      for (var i = 1; i < args.length; i += 1) {        var nextSource = args[i];        if (nextSource !== undefined && nextSource !== null) {          var keysArray = Object.keys(Object(nextSource));          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {            var nextKey = keysArray[nextIndex];            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);            if (desc !== undefined && desc.enumerable) {              if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {                Utils.extend(to[nextKey], nextSource[nextKey]);              } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {                to[nextKey] = {};                Utils.extend(to[nextKey], nextSource[nextKey]);              } else {                to[nextKey] = nextSource[nextKey];              }            }          }        }      }      return to;    },  };  var Support = (function Support() {    var testDiv = doc.createElement('div');    return {      touch: (win.Modernizr && win.Modernizr.touch === true) || (function checkTouch() {        return !!(('ontouchstart' in win) || (win.DocumentTouch && doc instanceof win.DocumentTouch));      }()),      pointerEvents: !!(win.navigator.pointerEnabled || win.PointerEvent || ('maxTouchPoints' in win.navigator)),      prefixedPointerEvents: !!win.navigator.msPointerEnabled,      transition: (function checkTransition() {        var style = testDiv.style;        return ('transition' in style || 'webkitTransition' in style || 'MozTransition' in style);      }()),      transforms3d: (win.Modernizr && win.Modernizr.csstransforms3d === true) || (function checkTransforms3d() {        var style = testDiv.style;        return ('webkitPerspective' in style || 'MozPerspective' in style || 'OPerspective' in style || 'MsPerspective' in style || 'perspective' in style);      }()),      flexbox: (function checkFlexbox() {        var style = testDiv.style;        var styles = ('alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient').split(' ');        for (var i = 0; i < styles.length; i += 1) {          if (styles[i] in style) { return true; }        }        return false;      }()),      observer: (function checkObserver() {        return ('MutationObserver' in win || 'WebkitMutationObserver' in win);      }()),      passiveListener: (function checkPassiveListener() {        var supportsPassive = false;        try {          var opts = Object.defineProperty({}, 'passive', {            // eslint-disable-next-line            get: function get() {              supportsPassive = true;            },          });          win.addEventListener('testPassiveListener', null, opts);        } catch (e) {          // No support        }        return supportsPassive;      }()),      gestures: (function checkGestures() {        return 'ongesturestart' in win;      }()),    };  }());  var SwiperClass = function SwiperClass(params) {    if ( params === void 0 ) params = {};    var self = this;    self.params = params;    // Events    self.eventsListeners = {};    if (self.params && self.params.on) {      Object.keys(self.params.on).forEach(function (eventName) {        self.on(eventName, self.params.on[eventName]);      });    }  };  var staticAccessors = { components: { configurable: true } };  SwiperClass.prototype.on = function on (events, handler, priority) {    var self = this;    if (typeof handler !== 'function') { return self; }    var method = priority ? 'unshift' : 'push';    events.split(' ').forEach(function (event) {      if (!self.eventsListeners[event]) { self.eventsListeners[event] = []; }      self.eventsListeners[event][method](handler);    });    return self;  };  SwiperClass.prototype.once = function once (events, handler, priority) {    var self = this;    if (typeof handler !== 'function') { return self; }    function onceHandler() {        var args = [], len = arguments.length;        while ( len-- ) args[ len ] = arguments[ len ];      handler.apply(self, args);      self.off(events, onceHandler);    }    return self.on(events, onceHandler, priority);  };  SwiperClass.prototype.off = function off (events, handler) {    var self = this;    if (!self.eventsListeners) { return self; }    events.split(' ').forEach(function (event) {      if (typeof handler === 'undefined') {        self.eventsListeners[event] = [];      } else if (self.eventsListeners[event] && self.eventsListeners[event].length) {        self.eventsListeners[event].forEach(function (eventHandler, index) {          if (eventHandler === handler) {            self.eventsListeners[event].splice(index, 1);          }        });      }    });    return self;  };  SwiperClass.prototype.emit = function emit () {      var args = [], len = arguments.length;      while ( len-- ) args[ len ] = arguments[ len ];    var self = this;    if (!self.eventsListeners) { return self; }    var events;    var data;    var context;    if (typeof args[0] === 'string' || Array.isArray(args[0])) {      events = args[0];      data = args.slice(1, args.length);      context = self;    } else {      events = args[0].events;      data = args[0].data;      context = args[0].context || self;    }    var eventsArray = Array.isArray(events) ? events : events.split(' ');    eventsArray.forEach(function (event) {      if (self.eventsListeners && self.eventsListeners[event]) {        var handlers = [];        self.eventsListeners[event].forEach(function (eventHandler) {          handlers.push(eventHandler);        });        handlers.forEach(function (eventHandler) {          eventHandler.apply(context, data);        });      }    });    return self;  };  SwiperClass.prototype.useModulesParams = function useModulesParams (instanceParams) {    var instance = this;    if (!instance.modules) { return; }    Object.keys(instance.modules).forEach(function (moduleName) {      var module = instance.modules[moduleName];      // Extend params      if (module.params) {        Utils.extend(instanceParams, module.params);      }    });  };  SwiperClass.prototype.useModules = function useModules (modulesParams) {      if ( modulesParams === void 0 ) modulesParams = {};    var instance = this;    if (!instance.modules) { return; }    Object.keys(instance.modules).forEach(function (moduleName) {      var module = instance.modules[moduleName];      var moduleParams = modulesParams[moduleName] || {};      // Extend instance methods and props      if (module.instance) {        Object.keys(module.instance).forEach(function (modulePropName) {          var moduleProp = module.instance[modulePropName];          if (typeof moduleProp === 'function') {            instance[modulePropName] = moduleProp.bind(instance);          } else {            instance[modulePropName] = moduleProp;          }        });      }      // Add event listeners      if (module.on && instance.on) {        Object.keys(module.on).forEach(function (moduleEventName) {          instance.on(moduleEventName, module.on[moduleEventName]);        });      }      // Module create callback      if (module.create) {        module.create.bind(instance)(moduleParams);      }    });  };  staticAccessors.components.set = function (components) {    var Class = this;    if (!Class.use) { return; }    Class.use(components);  };  SwiperClass.installModule = function installModule (module) {      var params = [], len = arguments.length - 1;      while ( len-- > 0 ) params[ len ] = arguments[ len + 1 ];    var Class = this;    if (!Class.prototype.modules) { Class.prototype.modules = {}; }    var name = module.name || (((Object.keys(Class.prototype.modules).length) + "_" + (Utils.now())));    Class.prototype.modules[name] = module;    // Prototype    if (module.proto) {      Object.keys(module.proto).forEach(function (key) {        Class.prototype[key] = module.proto[key];      });    }    // Class    if (module.static) {      Object.keys(module.static).forEach(function (key) {        Class[key] = module.static[key];      });    }    // Callback    if (module.install) {      module.install.apply(Class, params);    }    return Class;  };  SwiperClass.use = function use (module) {      var params = [], len = arguments.length - 1;      while ( len-- > 0 ) params[ len ] = arguments[ len + 1 ];    var Class = this;    if (Array.isArray(module)) {      module.forEach(function (m) { return Class.installModule(m); });      return Class;    }    return Class.installModule.apply(Class, [ module ].concat( params ));  };  Object.defineProperties( SwiperClass, staticAccessors );  function updateSize () {    var swiper = this;    var width;    var height;    var $el = swiper.$el;    if (typeof swiper.params.width !== 'undefined') {      width = swiper.params.width;    } else {      width = $el[0].clientWidth;    }    if (typeof swiper.params.height !== 'undefined') {      height = swiper.params.height;    } else {      height = $el[0].clientHeight;    }    if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {      return;    }    // Subtract paddings    width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);    height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);    Utils.extend(swiper, {      width: width,      height: height,      size: swiper.isHorizontal() ? width : height,    });  }  function updateSlides () {    var swiper = this;    var params = swiper.params;    var $wrapperEl = swiper.$wrapperEl;    var swiperSize = swiper.size;    var rtl = swiper.rtlTranslate;    var wrongRTL = swiper.wrongRTL;    var isVirtual = swiper.virtual && params.virtual.enabled;    var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;    var slides = $wrapperEl.children(("." + (swiper.params.slideClass)));    var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;    var snapGrid = [];    var slidesGrid = [];    var slidesSizesGrid = [];    var offsetBefore = params.slidesOffsetBefore;    if (typeof offsetBefore === 'function') {      offsetBefore = params.slidesOffsetBefore.call(swiper);    }    var offsetAfter = params.slidesOffsetAfter;    if (typeof offsetAfter === 'function') {      offsetAfter = params.slidesOffsetAfter.call(swiper);    }    var previousSnapGridLength = swiper.snapGrid.length;    var previousSlidesGridLength = swiper.snapGrid.length;    var spaceBetween = params.spaceBetween;    var slidePosition = -offsetBefore;    var prevSlideSize = 0;    var index = 0;    if (typeof swiperSize === 'undefined') {      return;    }    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {      spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;    }    swiper.virtualSize = -spaceBetween;    // reset margins    if (rtl) { slides.css({ marginLeft: '', marginTop: '' }); }    else { slides.css({ marginRight: '', marginBottom: '' }); }    var slidesNumberEvenToRows;    if (params.slidesPerColumn > 1) {      if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {        slidesNumberEvenToRows = slidesLength;      } else {        slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;      }      if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {        slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);      }    }    // Calc slides    var slideSize;    var slidesPerColumn = params.slidesPerColumn;    var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;    var numFullColumns = slidesPerRow - ((params.slidesPerColumn * slidesPerRow) - slidesLength);    for (var i = 0; i < slidesLength; i += 1) {      slideSize = 0;      var slide = slides.eq(i);      if (params.slidesPerColumn > 1) {        // Set slides order        var newSlideOrderIndex = (void 0);        var column = (void 0);        var row = (void 0);        if (params.slidesPerColumnFill === 'column') {          column = Math.floor(i / slidesPerColumn);          row = i - (column * slidesPerColumn);          if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {            row += 1;            if (row >= slidesPerColumn) {              row = 0;              column += 1;            }          }          newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);          slide            .css({              '-webkit-box-ordinal-group': newSlideOrderIndex,              '-moz-box-ordinal-group': newSlideOrderIndex,              '-ms-flex-order': newSlideOrderIndex,              '-webkit-order': newSlideOrderIndex,              order: newSlideOrderIndex,            });        } else {          row = Math.floor(i / slidesPerRow);          column = i - (row * slidesPerRow);        }        slide          .css(            ("margin-" + (swiper.isHorizontal() ? 'top' : 'left')),            (row !== 0 && params.spaceBetween) && (((params.spaceBetween) + "px"))          )          .attr('data-swiper-column', column)          .attr('data-swiper-row', row);      }      if (slide.css('display') === 'none') { continue; } // eslint-disable-line      if (params.slidesPerView === 'auto') {        var slideStyles = win.getComputedStyle(slide[0], null);        var currentTransform = slide[0].style.transform;        var currentWebKitTransform = slide[0].style.webkitTransform;        if (currentTransform) {          slide[0].style.transform = 'none';        }        if (currentWebKitTransform) {          slide[0].style.webkitTransform = 'none';        }        if (params.roundLengths) {          slideSize = swiper.isHorizontal()            ? slide.outerWidth(true)            : slide.outerHeight(true);        } else {          // eslint-disable-next-line          if (swiper.isHorizontal()) {            slideSize = parseFloat(slideStyles.getPropertyValue('width'))              + parseFloat(slideStyles.getPropertyValue('margin-left'))              + parseFloat(slideStyles.getPropertyValue('margin-right'));          } else {            slideSize = parseFloat(slideStyles.getPropertyValue('height'))              + parseFloat(slideStyles.getPropertyValue('margin-top'))              + parseFloat(slideStyles.getPropertyValue('margin-bottom'));          }        }        if (currentTransform) {          slide[0].style.transform = currentTransform;        }        if (currentWebKitTransform) {          slide[0].style.webkitTransform = currentWebKitTransform;        }        if (params.roundLengths) { slideSize = Math.floor(slideSize); }      } else {        slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;        if (params.roundLengths) { slideSize = Math.floor(slideSize); }        if (slides[i]) {          if (swiper.isHorizontal()) {            slides[i].style.width = slideSize + "px";          } else {            slides[i].style.height = slideSize + "px";          }        }      }      if (slides[i]) {        slides[i].swiperSlideSize = slideSize;      }      slidesSizesGrid.push(slideSize);      if (params.centeredSlides) {        slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;        if (prevSlideSize === 0 && i !== 0) { slidePosition = slidePosition - (swiperSize / 2) - spaceBetween; }        if (i === 0) { slidePosition = slidePosition - (swiperSize / 2) - spaceBetween; }        if (Math.abs(slidePosition) < 1 / 1000) { slidePosition = 0; }        if (params.roundLengths) { slidePosition = Math.floor(slidePosition); }        if ((index) % params.slidesPerGroup === 0) { snapGrid.push(slidePosition); }        slidesGrid.push(slidePosition);      } else {        if (params.roundLengths) { slidePosition = Math.floor(slidePosition); }        if ((index) % params.slidesPerGroup === 0) { snapGrid.push(slidePosition); }        slidesGrid.push(slidePosition);        slidePosition = slidePosition + slideSize + spaceBetween;      }      swiper.virtualSize += slideSize + spaceBetween;      prevSlideSize = slideSize;      index += 1;    }    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;    var newSlidesGrid;    if (      rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {      $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + "px") });    }    if (!Support.flexbox || params.setWrapperSize) {      if (swiper.isHorizontal()) { $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + "px") }); }      else { $wrapperEl.css({ height: ((swiper.virtualSize + params.spaceBetween) + "px") }); }    }    if (params.slidesPerColumn > 1) {      swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;      swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;      if (swiper.isHorizontal()) { $wrapperEl.css({ width: ((swiper.virtualSize + params.spaceBetween) + "px") }); }      else { $wrapperEl.css({ height: ((swiper.virtualSize + params.spaceBetween) + "px") }); }      if (params.centeredSlides) {        newSlidesGrid = [];        for (var i$1 = 0; i$1 < snapGrid.length; i$1 += 1) {          var slidesGridItem = snapGrid[i$1];          if (params.roundLengths) { slidesGridItem = Math.floor(slidesGridItem); }          if (snapGrid[i$1] < swiper.virtualSize + snapGrid[0]) { newSlidesGrid.push(slidesGridItem); }        }        snapGrid = newSlidesGrid;      }    }    // Remove last grid elements depending on width    if (!params.centeredSlides) {      newSlidesGrid = [];      for (var i$2 = 0; i$2 < snapGrid.length; i$2 += 1) {        var slidesGridItem$1 = snapGrid[i$2];        if (params.roundLengths) { slidesGridItem$1 = Math.floor(slidesGridItem$1); }        if (snapGrid[i$2] <= swiper.virtualSize - swiperSize) {          newSlidesGrid.push(slidesGridItem$1);        }      }      snapGrid = newSlidesGrid;      if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {        snapGrid.push(swiper.virtualSize - swiperSize);      }    }    if (snapGrid.length === 0) { snapGrid = [0]; }    if (params.spaceBetween !== 0) {      if (swiper.isHorizontal()) {        if (rtl) { slides.css({ marginLeft: (spaceBetween + "px") }); }        else { slides.css({ marginRight: (spaceBetween + "px") }); }      } else { slides.css({ marginBottom: (spaceBetween + "px") }); }    }    if (params.centerInsufficientSlides) {      var allSlidesSize = 0;      slidesSizesGrid.forEach(function (slideSizeValue) {        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);      });      allSlidesSize -= params.spaceBetween;      if (allSlidesSize < swiperSize) {        var allSlidesOffset = (swiperSize - allSlidesSize) / 2;        snapGrid.forEach(function (snap, snapIndex) {          snapGrid[snapIndex] = snap - allSlidesOffset;        });        slidesGrid.forEach(function (snap, snapIndex) {          slidesGrid[snapIndex] = snap + allSlidesOffset;        });      }    }    Utils.extend(swiper, {      slides: slides,      snapGrid: snapGrid,      slidesGrid: slidesGrid,      slidesSizesGrid: slidesSizesGrid,    });    if (slidesLength !== previousSlidesLength) {      swiper.emit('slidesLengthChange');    }    if (snapGrid.length !== previousSnapGridLength) {      if (swiper.params.watchOverflow) { swiper.checkOverflow(); }      swiper.emit('snapGridLengthChange');    }    if (slidesGrid.length !== previousSlidesGridLength) {      swiper.emit('slidesGridLengthChange');    }    if (params.watchSlidesProgress || params.watchSlidesVisibility) {      swiper.updateSlidesOffset();    }  }  function updateAutoHeight (speed) {    var swiper = this;    var activeSlides = [];    var newHeight = 0;    var i;    if (typeof speed === 'number') {      swiper.setTransition(speed);    } else if (speed === true) {      swiper.setTransition(swiper.params.speed);    }    // Find slides currently in view    if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {      for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {        var index = swiper.activeIndex + i;        if (index > swiper.slides.length) { break; }        activeSlides.push(swiper.slides.eq(index)[0]);      }    } else {      activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);    }    // Find new height from highest slide in view    for (i = 0; i < activeSlides.length; i += 1) {      if (typeof activeSlides[i] !== 'undefined') {        var height = activeSlides[i].offsetHeight;        newHeight = height > newHeight ? height : newHeight;      }    }    // Update Height    if (newHeight) { swiper.$wrapperEl.css('height', (newHeight + "px")); }  }  function updateSlidesOffset () {    var swiper = this;    var slides = swiper.slides;    for (var i = 0; i < slides.length; i += 1) {      slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;    }  }  function updateSlidesProgress (translate) {    if ( translate === void 0 ) translate = (this && this.translate) || 0;    var swiper = this;    var params = swiper.params;    var slides = swiper.slides;    var rtl = swiper.rtlTranslate;    if (slides.length === 0) { return; }    if (typeof slides[0].swiperSlideOffset === 'undefined') { swiper.updateSlidesOffset(); }    var offsetCenter = -translate;    if (rtl) { offsetCenter = translate; }    // Visible Slides    slides.removeClass(params.slideVisibleClass);    swiper.visibleSlidesIndexes = [];    swiper.visibleSlides = [];    for (var i = 0; i < slides.length; i += 1) {      var slide = slides[i];      var slideProgress = (        (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset      ) / (slide.swiperSlideSize + params.spaceBetween);      if (params.watchSlidesVisibility) {        var slideBefore = -(offsetCenter - slide.swiperSlideOffset);        var slideAfter = slideBefore + swiper.slidesSizesGrid[i];        var isVisible = (slideBefore >= 0 && slideBefore < swiper.size)                  || (slideAfter > 0 && slideAfter <= swiper.size)                  || (slideBefore <= 0 && slideAfter >= swiper.size);        if (isVisible) {          swiper.visibleSlides.push(slide);          swiper.visibleSlidesIndexes.push(i);          slides.eq(i).addClass(params.slideVisibleClass);        }      }      slide.progress = rtl ? -slideProgress : slideProgress;    }    swiper.visibleSlides = $(swiper.visibleSlides);  }  function updateProgress (translate) {    if ( translate === void 0 ) translate = (this && this.translate) || 0;    var swiper = this;    var params = swiper.params;    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();    var progress = swiper.progress;    var isBeginning = swiper.isBeginning;    var isEnd = swiper.isEnd;    var wasBeginning = isBeginning;    var wasEnd = isEnd;    if (translatesDiff === 0) {      progress = 0;      isBeginning = true;      isEnd = true;    } else {      progress = (translate - swiper.minTranslate()) / (translatesDiff);      isBeginning = progress <= 0;      isEnd = progress >= 1;    }    Utils.extend(swiper, {      progress: progress,      isBeginning: isBeginning,      isEnd: isEnd,    });    if (params.watchSlidesProgress || params.watchSlidesVisibility) { swiper.updateSlidesProgress(translate); }    if (isBeginning && !wasBeginning) {      swiper.emit('reachBeginning toEdge');    }    if (isEnd && !wasEnd) {      swiper.emit('reachEnd toEdge');    }    if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {      swiper.emit('fromEdge');    }    swiper.emit('progress', progress);  }  function updateSlidesClasses () {    var swiper = this;    var slides = swiper.slides;    var params = swiper.params;    var $wrapperEl = swiper.$wrapperEl;    var activeIndex = swiper.activeIndex;    var realIndex = swiper.realIndex;    var isVirtual = swiper.virtual && params.virtual.enabled;    slides.removeClass(((params.slideActiveClass) + " " + (params.slideNextClass) + " " + (params.slidePrevClass) + " " + (params.slideDuplicateActiveClass) + " " + (params.slideDuplicateNextClass) + " " + (params.slideDuplicatePrevClass)));    var activeSlide;    if (isVirtual) {      activeSlide = swiper.$wrapperEl.find(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + activeIndex + "\"]"));    } else {      activeSlide = slides.eq(activeIndex);    }    // Active classes    activeSlide.addClass(params.slideActiveClass);    if (params.loop) {      // Duplicate to all looped slides      if (activeSlide.hasClass(params.slideDuplicateClass)) {        $wrapperEl          .children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + realIndex + "\"]"))          .addClass(params.slideDuplicateActiveClass);      } else {        $wrapperEl          .children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]"))          .addClass(params.slideDuplicateActiveClass);      }    }    // Next Slide    var nextSlide = activeSlide.nextAll(("." + (params.slideClass))).eq(0).addClass(params.slideNextClass);    if (params.loop && nextSlide.length === 0) {      nextSlide = slides.eq(0);      nextSlide.addClass(params.slideNextClass);    }    // Prev Slide    var prevSlide = activeSlide.prevAll(("." + (params.slideClass))).eq(0).addClass(params.slidePrevClass);    if (params.loop && prevSlide.length === 0) {      prevSlide = slides.eq(-1);      prevSlide.addClass(params.slidePrevClass);    }    if (params.loop) {      // Duplicate to all looped slides      if (nextSlide.hasClass(params.slideDuplicateClass)) {        $wrapperEl          .children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + (nextSlide.attr('data-swiper-slide-index')) + "\"]"))          .addClass(params.slideDuplicateNextClass);      } else {        $wrapperEl          .children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + (nextSlide.attr('data-swiper-slide-index')) + "\"]"))          .addClass(params.slideDuplicateNextClass);      }      if (prevSlide.hasClass(params.slideDuplicateClass)) {        $wrapperEl          .children(("." + (params.slideClass) + ":not(." + (params.slideDuplicateClass) + ")[data-swiper-slide-index=\"" + (prevSlide.attr('data-swiper-slide-index')) + "\"]"))          .addClass(params.slideDuplicatePrevClass);      } else {        $wrapperEl          .children(("." + (params.slideClass) + "." + (params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + (prevSlide.attr('data-swiper-slide-index')) + "\"]"))          .addClass(params.slideDuplicatePrevClass);      }    }  }  function updateActiveIndex (newActiveIndex) {    var swiper = this;    var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;    var slidesGrid = swiper.slidesGrid;    var snapGrid = swiper.snapGrid;    var params = swiper.params;    var previousIndex = swiper.activeIndex;    var previousRealIndex = swiper.realIndex;    var previousSnapIndex = swiper.snapIndex;    var activeIndex = newActiveIndex;    var snapIndex;    if (typeof activeIndex === 'undefined') {      for (var i = 0; i < slidesGrid.length; i += 1) {        if (typeof slidesGrid[i + 1] !== 'undefined') {          if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {            activeIndex = i;          } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {            activeIndex = i + 1;          }        } else if (translate >= slidesGrid[i]) {          activeIndex = i;        }      }      // Normalize slideIndex      if (params.normalizeSlideIndex) {        if (activeIndex < 0 || typeof activeIndex === 'undefined') { activeIndex = 0; }      }    }    if (snapGrid.indexOf(translate) >= 0) {      snapIndex = snapGrid.indexOf(translate);    } else {      snapIndex = Math.floor(activeIndex / params.slidesPerGroup);    }    if (snapIndex >= snapGrid.length) { snapIndex = snapGrid.length - 1; }    if (activeIndex === previousIndex) {      if (snapIndex !== previousSnapIndex) {        swiper.snapIndex = snapIndex;        swiper.emit('snapIndexChange');      }      return;    }    // Get real index    var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);    Utils.extend(swiper, {      snapIndex: snapIndex,      realIndex: realIndex,      previousIndex: previousIndex,      activeIndex: activeIndex,    });    swiper.emit('activeIndexChange');    swiper.emit('snapIndexChange');    if (previousRealIndex !== realIndex) {      swiper.emit('realIndexChange');    }    swiper.emit('slideChange');  }  function updateClickedSlide (e) {    var swiper = this;    var params = swiper.params;    var slide = $(e.target).closest(("." + (params.slideClass)))[0];    var slideFound = false;    if (slide) {      for (var i = 0; i < swiper.slides.length; i += 1) {        if (swiper.slides[i] === slide) { slideFound = true; }      }    }    if (slide && slideFound) {      swiper.clickedSlide = slide;      if (swiper.virtual && swiper.params.virtual.enabled) {        swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);      } else {        swiper.clickedIndex = $(slide).index();      }    } else {      swiper.clickedSlide = undefined;      swiper.clickedIndex = undefined;      return;    }    if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {      swiper.slideToClickedSlide();    }  }  var update = {    updateSize: updateSize,    updateSlides: updateSlides,    updateAutoHeight: updateAutoHeight,    updateSlidesOffset: updateSlidesOffset,    updateSlidesProgress: updateSlidesProgress,    updateProgress: updateProgress,    updateSlidesClasses: updateSlidesClasses,    updateActiveIndex: updateActiveIndex,    updateClickedSlide: updateClickedSlide,  };  function getTranslate (axis) {    if ( axis === void 0 ) axis = this.isHorizontal() ? 'x' : 'y';    var swiper = this;    var params = swiper.params;    var rtl = swiper.rtlTranslate;    var translate = swiper.translate;    var $wrapperEl = swiper.$wrapperEl;    if (params.virtualTranslate) {      return rtl ? -translate : translate;    }    var currentTranslate = Utils.getTranslate($wrapperEl[0], axis);    if (rtl) { currentTranslate = -currentTranslate; }    return currentTranslate || 0;  }  function setTranslate (translate, byController) {    var swiper = this;    var rtl = swiper.rtlTranslate;    var params = swiper.params;    var $wrapperEl = swiper.$wrapperEl;    var progress = swiper.progress;    var x = 0;    var y = 0;    var z = 0;    if (swiper.isHorizontal()) {      x = rtl ? -translate : translate;    } else {      y = translate;    }    if (params.roundLengths) {      x = Math.floor(x);      y = Math.floor(y);    }    if (!params.virtualTranslate) {      if (Support.transforms3d) { $wrapperEl.transform(("translate3d(" + x + "px, " + y + "px, " + z + "px)")); }      else { $wrapperEl.transform(("translate(" + x + "px, " + y + "px)")); }    }    swiper.previousTranslate = swiper.translate;    swiper.translate = swiper.isHorizontal() ? x : y;    // Check if we need to update progress    var newProgress;    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();    if (translatesDiff === 0) {      newProgress = 0;    } else {      newProgress = (translate - swiper.minTranslate()) / (translatesDiff);    }    if (newProgress !== progress) {      swiper.updateProgress(translate);    }    swiper.emit('setTranslate', swiper.translate, byController);  }  function minTranslate () {    return (-this.snapGrid[0]);  }  function maxTranslate () {    return (-this.snapGrid[this.snapGrid.length - 1]);  }  var translate = {    getTranslate: getTranslate,    setTranslate: setTranslate,    minTranslate: minTranslate,    maxTranslate: maxTranslate,  };  function setTransition (duration, byController) {    var swiper = this;    swiper.$wrapperEl.transition(duration);    swiper.emit('setTransition', duration, byController);  }  function transitionStart (runCallbacks, direction) {    if ( runCallbacks === void 0 ) runCallbacks = true;    var swiper = this;    var activeIndex = swiper.activeIndex;    var params = swiper.params;    var previousIndex = swiper.previousIndex;    if (params.autoHeight) {      swiper.updateAutoHeight();    }    var dir = direction;    if (!dir) {      if (activeIndex > previousIndex) { dir = 'next'; }      else if (activeIndex < previousIndex) { dir = 'prev'; }      else { dir = 'reset'; }    }    swiper.emit('transitionStart');    if (runCallbacks && activeIndex !== previousIndex) {      if (dir === 'reset') {        swiper.emit('slideResetTransitionStart');        return;      }      swiper.emit('slideChangeTransitionStart');      if (dir === 'next') {        swiper.emit('slideNextTransitionStart');      } else {        swiper.emit('slidePrevTransitionStart');      }    }  }  function transitionEnd$1 (runCallbacks, direction) {    if ( runCallbacks === void 0 ) runCallbacks = true;    var swiper = this;    var activeIndex = swiper.activeIndex;    var previousIndex = swiper.previousIndex;    swiper.animating = false;    swiper.setTransition(0);    var dir = direction;    if (!dir) {      if (activeIndex > previousIndex) { dir = 'next'; }      else if (activeIndex < previousIndex) { dir = 'prev'; }      else { dir = 'reset'; }    }    swiper.emit('transitionEnd');    if (runCallbacks && activeIndex !== previousIndex) {      if (dir === 'reset') {        swiper.emit('slideResetTransitionEnd');        return;      }      swiper.emit('slideChangeTransitionEnd');      if (dir === 'next') {        swiper.emit('slideNextTransitionEnd');      } else {        swiper.emit('slidePrevTransitionEnd');      }    }  }  var transition$1 = {    setTransition: setTransition,    transitionStart: transitionStart,    transitionEnd: transitionEnd$1,  };  function slideTo (index, speed, runCallbacks, internal) {    if ( index === void 0 ) index = 0;    if ( speed === void 0 ) speed = this.params.speed;    if ( runCallbacks === void 0 ) runCallbacks = true;    var swiper = this;    var slideIndex = index;    if (slideIndex < 0) { slideIndex = 0; }    var params = swiper.params;    var snapGrid = swiper.snapGrid;    var slidesGrid = swiper.slidesGrid;    var previousIndex = swiper.previousIndex;    var activeIndex = swiper.activeIndex;    var rtl = swiper.rtlTranslate;    if (swiper.animating && params.preventInteractionOnTransition) {      return false;    }    var snapIndex = Math.floor(slideIndex / params.slidesPerGroup);    if (snapIndex >= snapGrid.length) { snapIndex = snapGrid.length - 1; }    if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {      swiper.emit('beforeSlideChangeStart');    }    var translate = -snapGrid[snapIndex];    // Update progress    swiper.updateProgress(translate);    // Normalize slideIndex    if (params.normalizeSlideIndex) {      for (var i = 0; i < slidesGrid.length; i += 1) {        if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {          slideIndex = i;        }      }    }    // Directions locks    if (swiper.initialized && slideIndex !== activeIndex) {      if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {        return false;      }      if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {        if ((activeIndex || 0) !== slideIndex) { return false; }      }    }    var direction;    if (slideIndex > activeIndex) { direction = 'next'; }    else if (slideIndex < activeIndex) { direction = 'prev'; }    else { direction = 'reset'; }    // Update Index    if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {      swiper.updateActiveIndex(slideIndex);      // Update Height      if (params.autoHeight) {        swiper.updateAutoHeight();      }      swiper.updateSlidesClasses();      if (params.effect !== 'slide') {        swiper.setTranslate(translate);      }      if (direction !== 'reset') {        swiper.transitionStart(runCallbacks, direction);        swiper.transitionEnd(runCallbacks, direction);      }      return false;    }    if (speed === 0 || !Support.transition) {      swiper.setTransition(0);      swiper.setTranslate(translate);      swiper.updateActiveIndex(slideIndex);      swiper.updateSlidesClasses();      swiper.emit('beforeTransitionStart', speed, internal);      swiper.transitionStart(runCallbacks, direction);      swiper.transitionEnd(runCallbacks, direction);    } else {      swiper.setTransition(speed);      swiper.setTranslate(translate);      swiper.updateActiveIndex(slideIndex);      swiper.updateSlidesClasses();      swiper.emit('beforeTransitionStart', speed, internal);      swiper.transitionStart(runCallbacks, direction);      if (!swiper.animating) {        swiper.animating = true;        if (!swiper.onSlideToWrapperTransitionEnd) {          swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {            if (!swiper || swiper.destroyed) { return; }            if (e.target !== this) { return; }            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);            swiper.onSlideToWrapperTransitionEnd = null;            delete swiper.onSlideToWrapperTransitionEnd;            swiper.transitionEnd(runCallbacks, direction);          };        }        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);      }    }    return true;  }  function slideToLoop (index, speed, runCallbacks, internal) {    if ( index === void 0 ) index = 0;    if ( speed === void 0 ) speed = this.params.speed;    if ( runCallbacks === void 0 ) runCallbacks = true;    var swiper = this;    var newIndex = index;    if (swiper.params.loop) {      newIndex += swiper.loopedSlides;    }    return swiper.slideTo(newIndex, speed, runCallbacks, internal);  }  /* eslint no-unused-vars: "off" */  function slideNext (speed, runCallbacks, internal) {    if ( speed === void 0 ) speed = this.params.speed;    if ( runCallbacks === void 0 ) runCallbacks = true;    var swiper = this;    var params = swiper.params;    var animating = swiper.animating;    if (params.loop) {      if (animating) { return false; }      swiper.loopFix();      // eslint-disable-next-line      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;      return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);    }    return swiper.slideTo(swiper.activeIndex + params.slidesPerGroup, speed, runCallbacks, internal);  }  /* eslint no-unused-vars: "off" */  function slidePrev (speed, runCallbacks, internal) {    if ( speed === void 0 ) speed = this.params.speed;    if ( runCallbacks === void 0 ) runCallbacks = true;    var swiper = this;    var params = swiper.params;    var animating = swiper.animating;    var snapGrid = swiper.snapGrid;    var slidesGrid = swiper.slidesGrid;    var rtlTranslate = swiper.rtlTranslate;    if (params.loop) {      if (animating) { return false; }      swiper.loopFix();      // eslint-disable-next-line      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;    }    var translate = rtlTranslate ? swiper.translate : -swiper.translate;    function normalize(val) {      if (val < 0) { return -Math.floor(Math.abs(val)); }      return Math.floor(val);    }    var normalizedTranslate = normalize(translate);    var normalizedSnapGrid = snapGrid.map(function (val) { return normalize(val); });    var normalizedSlidesGrid = slidesGrid.map(function (val) { return normalize(val); });    var currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];    var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];    var prevIndex;    if (typeof prevSnap !== 'undefined') {      prevIndex = slidesGrid.indexOf(prevSnap);      if (prevIndex < 0) { prevIndex = swiper.activeIndex - 1; }    }    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);  }  /* eslint no-unused-vars: "off" */  function slideReset (speed, runCallbacks, internal) {    if ( speed === void 0 ) speed = this.params.speed;    if ( runCallbacks === void 0 ) runCallbacks = true;    var swiper = this;    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);  }  /* eslint no-unused-vars: "off" */  function slideToClosest (speed, runCallbacks, internal) {    if ( speed === void 0 ) speed = this.params.speed;    if ( runCallbacks === void 0 ) runCallbacks = true;    var swiper = this;    var index = swiper.activeIndex;    var snapIndex = Math.floor(index / swiper.params.slidesPerGroup);    if (snapIndex < swiper.snapGrid.length - 1) {      var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;      var currentSnap = swiper.snapGrid[snapIndex];      var nextSnap = swiper.snapGrid[snapIndex + 1];      if ((translate - currentSnap) > (nextSnap - currentSnap) / 2) {        index = swiper.params.slidesPerGroup;      }    }    return swiper.slideTo(index, speed, runCallbacks, internal);  }  function slideToClickedSlide () {    var swiper = this;    var params = swiper.params;    var $wrapperEl = swiper.$wrapperEl;    var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;    var slideToIndex = swiper.clickedIndex;    var realIndex;    if (params.loop) {      if (swiper.animating) { return; }      realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);      if (params.centeredSlides) {        if (          (slideToIndex < swiper.loopedSlides - (slidesPerView / 2))          || (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))        ) {          swiper.loopFix();          slideToIndex = $wrapperEl            .children(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + (params.slideDuplicateClass) + ")"))            .eq(0)            .index();          Utils.nextTick(function () {            swiper.slideTo(slideToIndex);          });        } else {          swiper.slideTo(slideToIndex);        }      } else if (slideToIndex > swiper.slides.length - slidesPerView) {        swiper.loopFix();        slideToIndex = $wrapperEl          .children(("." + (params.slideClass) + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + (params.slideDuplicateClass) + ")"))          .eq(0)          .index();        Utils.nextTick(function () {          swiper.slideTo(slideToIndex);        });      } else {        swiper.slideTo(slideToIndex);      }    } else {      swiper.slideTo(slideToIndex);    }  }  var slide = {    slideTo: slideTo,    slideToLoop: slideToLoop,    slideNext: slideNext,    slidePrev: slidePrev,    slideReset: slideReset,    slideToClosest: slideToClosest,    slideToClickedSlide: slideToClickedSlide,  };  function loopCreate () {    var swiper = this;    var params = swiper.params;    var $wrapperEl = swiper.$wrapperEl;    // Remove duplicated slides    $wrapperEl.children(("." + (params.slideClass) + "." + (params.slideDuplicateClass))).remove();    var slides = $wrapperEl.children(("." + (params.slideClass)));    if (params.loopFillGroupWithBlank) {      var blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);      if (blankSlidesNum !== params.slidesPerGroup) {        for (var i = 0; i < blankSlidesNum; i += 1) {          var blankNode = $(doc.createElement('div')).addClass(((params.slideClass) + " " + (params.slideBlankClass)));          $wrapperEl.append(blankNode);        }        slides = $wrapperEl.children(("." + (params.slideClass)));      }    }    if (params.slidesPerView === 'auto' && !params.loopedSlides) { params.loopedSlides = slides.length; }    swiper.loopedSlides = parseInt(params.loopedSlides || params.slidesPerView, 10);    swiper.loopedSlides += params.loopAdditionalSlides;    if (swiper.loopedSlides > slides.length) {      swiper.loopedSlides = slides.length;    }    var prependSlides = [];    var appendSlides = [];    slides.each(function (index, el) {      var slide = $(el);      if (index < swiper.loopedSlides) { appendSlides.push(el); }      if (index < slides.length && index >= slides.length - swiper.loopedSlides) { prependSlides.push(el); }      slide.attr('data-swiper-slide-index', index);    });    for (var i$1 = 0; i$1 < appendSlides.length; i$1 += 1) {      $wrapperEl.append($(appendSlides[i$1].cloneNode(true)).addClass(params.slideDuplicateClass));    }    for (var i$2 = prependSlides.length - 1; i$2 >= 0; i$2 -= 1) {      $wrapperEl.prepend($(prependSlides[i$2].cloneNode(true)).addClass(params.slideDuplicateClass));    }  }  function loopFix () {    var swiper = this;    var params = swiper.params;    var activeIndex = swiper.activeIndex;    var slides = swiper.slides;    var loopedSlides = swiper.loopedSlides;    var allowSlidePrev = swiper.allowSlidePrev;    var allowSlideNext = swiper.allowSlideNext;    var snapGrid = swiper.snapGrid;    var rtl = swiper.rtlTranslate;    var newIndex;    swiper.allowSlidePrev = true;    swiper.allowSlideNext = true;    var snapTranslate = -snapGrid[activeIndex];    var diff = snapTranslate - swiper.getTranslate();    // Fix For Negative Oversliding    if (activeIndex < loopedSlides) {      newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;      newIndex += loopedSlides;      var slideChanged = swiper.slideTo(newIndex, 0, false, true);      if (slideChanged && diff !== 0) {        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);      }    } else if ((params.slidesPerView === 'auto' && activeIndex >= loopedSlides * 2) || (activeIndex >= slides.length - loopedSlides)) {      // Fix For Positive Oversliding      newIndex = -slides.length + activeIndex + loopedSlides;      newIndex += loopedSlides;      var slideChanged$1 = swiper.slideTo(newIndex, 0, false, true);      if (slideChanged$1 && diff !== 0) {        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);      }    }    swiper.allowSlidePrev = allowSlidePrev;    swiper.allowSlideNext = allowSlideNext;  }  function loopDestroy () {    var swiper = this;    var $wrapperEl = swiper.$wrapperEl;    var params = swiper.params;    var slides = swiper.slides;    $wrapperEl.children(("." + (params.slideClass) + "." + (params.slideDuplicateClass))).remove();    slides.removeAttr('data-swiper-slide-index');  }  var loop = {    loopCreate: loopCreate,    loopFix: loopFix,    loopDestroy: loopDestroy,  };  function setGrabCursor (moving) {    var swiper = this;    if (Support.touch || !swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked)) { return; }    var el = swiper.el;    el.style.cursor = 'move';    el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';    el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';    el.style.cursor = moving ? 'grabbing' : 'grab';  }  function unsetGrabCursor () {    var swiper = this;    if (Support.touch || (swiper.params.watchOverflow && swiper.isLocked)) { return; }    swiper.el.style.cursor = '';  }  var grabCursor = {    setGrabCursor: setGrabCursor,    unsetGrabCursor: unsetGrabCursor,  };  function appendSlide (slides) {    var swiper = this;    var $wrapperEl = swiper.$wrapperEl;    var params = swiper.params;    if (params.loop) {      swiper.loopDestroy();    }    if (typeof slides === 'object' && 'length' in slides) {      for (var i = 0; i < slides.length; i += 1) {        if (slides[i]) { $wrapperEl.append(slides[i]); }      }    } else {      $wrapperEl.append(slides);    }    if (params.loop) {      swiper.loopCreate();    }    if (!(params.observer && Support.observer)) {      swiper.update();    }  }  function prependSlide (slides) {    var swiper = this;    var params = swiper.params;    var $wrapperEl = swiper.$wrapperEl;    var activeIndex = swiper.activeIndex;    if (params.loop) {      swiper.loopDestroy();    }    var newActiveIndex = activeIndex + 1;    if (typeof slides === 'object' && 'length' in slides) {      for (var i = 0; i < slides.length; i += 1) {        if (slides[i]) { $wrapperEl.prepend(slides[i]); }      }      newActiveIndex = activeIndex + slides.length;    } else {      $wrapperEl.prepend(slides);    }    if (params.loop) {      swiper.loopCreate();    }    if (!(params.observer && Support.observer)) {      swiper.update();    }    swiper.slideTo(newActiveIndex, 0, false);  }  function addSlide (index, slides) {    var swiper = this;    var $wrapperEl = swiper.$wrapperEl;    var params = swiper.params;    var activeIndex = swiper.activeIndex;    var activeIndexBuffer = activeIndex;    if (params.loop) {      activeIndexBuffer -= swiper.loopedSlides;      swiper.loopDestroy();      swiper.slides = $wrapperEl.children(("." + (params.slideClass)));    }    var baseLength = swiper.slides.length;    if (index <= 0) {      swiper.prependSlide(slides);      return;    }    if (index >= baseLength) {      swiper.appendSlide(slides);      return;    }    var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;    var slidesBuffer = [];    for (var i = baseLength - 1; i >= index; i -= 1) {      var currentSlide = swiper.slides.eq(i);      currentSlide.remove();      slidesBuffer.unshift(currentSlide);    }    if (typeof slides === 'object' && 'length' in slides) {      for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {        if (slides[i$1]) { $wrapperEl.append(slides[i$1]); }      }      newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;    } else {      $wrapperEl.append(slides);    }    for (var i$2 = 0; i$2 < slidesBuffer.length; i$2 += 1) {      $wrapperEl.append(slidesBuffer[i$2]);    }    if (params.loop) {      swiper.loopCreate();    }    if (!(params.observer && Support.observer)) {      swiper.update();    }    if (params.loop) {      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);    } else {      swiper.slideTo(newActiveIndex, 0, false);    }  }  function removeSlide (slidesIndexes) {    var swiper = this;    var params = swiper.params;    var $wrapperEl = swiper.$wrapperEl;    var activeIndex = swiper.activeIndex;    var activeIndexBuffer = activeIndex;    if (params.loop) {      activeIndexBuffer -= swiper.loopedSlides;      swiper.loopDestroy();      swiper.slides = $wrapperEl.children(("." + (params.slideClass)));    }    var newActiveIndex = activeIndexBuffer;    var indexToRemove;    if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {      for (var i = 0; i < slidesIndexes.length; i += 1) {        indexToRemove = slidesIndexes[i];        if (swiper.slides[indexToRemove]) { swiper.slides.eq(indexToRemove).remove(); }        if (indexToRemove < newActiveIndex) { newActiveIndex -= 1; }      }      newActiveIndex = Math.max(newActiveIndex, 0);    } else {      indexToRemove = slidesIndexes;      if (swiper.slides[indexToRemove]) { swiper.slides.eq(indexToRemove).remove(); }      if (indexToRemove < newActiveIndex) { newActiveIndex -= 1; }      newActiveIndex = Math.max(newActiveIndex, 0);    }    if (params.loop) {      swiper.loopCreate();    }    if (!(params.observer && Support.observer)) {      swiper.update();    }    if (params.loop) {      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);    } else {      swiper.slideTo(newActiveIndex, 0, false);    }  }  function removeAllSlides () {    var swiper = this;    var slidesIndexes = [];    for (var i = 0; i < swiper.slides.length; i += 1) {      slidesIndexes.push(i);    }    swiper.removeSlide(slidesIndexes);  }  var manipulation = {    appendSlide: appendSlide,    prependSlide: prependSlide,    addSlide: addSlide,    removeSlide: removeSlide,    removeAllSlides: removeAllSlides,  };  var Device = (function Device() {    var ua = win.navigator.userAgent;    var device = {      ios: false,      android: false,      androidChrome: false,      desktop: false,      windows: false,      iphone: false,      ipod: false,      ipad: false,      cordova: win.cordova || win.phonegap,      phonegap: win.cordova || win.phonegap,    };    var windows = ua.match(/(Windows Phone);?[\s\/]+([\d.]+)?/); // eslint-disable-line    var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line    var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);    var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);    var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);    // Windows    if (windows) {      device.os = 'windows';      device.osVersion = windows[2];      device.windows = true;    }    // Android    if (android && !windows) {      device.os = 'android';      device.osVersion = android[2];      device.android = true;      device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;    }    if (ipad || iphone || ipod) {      device.os = 'ios';      device.ios = true;    }    // iOS    if (iphone && !ipod) {      device.osVersion = iphone[2].replace(/_/g, '.');      device.iphone = true;    }    if (ipad) {      device.osVersion = ipad[2].replace(/_/g, '.');      device.ipad = true;    }    if (ipod) {      device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;      device.iphone = true;    }    // iOS 8+ changed UA    if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {      if (device.osVersion.split('.')[0] === '10') {        device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];      }    }    // Desktop    device.desktop = !(device.os || device.android || device.webView);    // Webview    device.webView = (iphone || ipad || ipod) && ua.match(/.*AppleWebKit(?!.*Safari)/i);    // Minimal UI    if (device.os && device.os === 'ios') {      var osVersionArr = device.osVersion.split('.');      var metaViewport = doc.querySelector('meta[name="viewport"]');      device.minimalUi = !device.webView        && (ipod || iphone)        && (osVersionArr[0] * 1 === 7 ? osVersionArr[1] * 1 >= 1 : osVersionArr[0] * 1 > 7)        && metaViewport && metaViewport.getAttribute('content').indexOf('minimal-ui') >= 0;    }    // Pixel Ratio    device.pixelRatio = win.devicePixelRatio || 1;    // Export object    return device;  }());  function onTouchStart (event) {    var swiper = this;    var data = swiper.touchEventsData;    var params = swiper.params;    var touches = swiper.touches;    if (swiper.animating && params.preventInteractionOnTransition) {      return;    }    var e = event;    if (e.originalEvent) { e = e.originalEvent; }    data.isTouchEvent = e.type === 'touchstart';    if (!data.isTouchEvent && 'which' in e && e.which === 3) { return; }    if (!data.isTouchEvent && 'button' in e && e.button > 0) { return; }    if (data.isTouched && data.isMoved) { return; }    if (params.noSwiping && $(e.target).closest(params.noSwipingSelector ? params.noSwipingSelector : ("." + (params.noSwipingClass)))[0]) {      swiper.allowClick = true;      return;    }    if (params.swipeHandler) {      if (!$(e).closest(params.swipeHandler)[0]) { return; }    }    touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;    touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;    var startX = touches.currentX;    var startY = touches.currentY;    // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore    var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;    var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;    if (      edgeSwipeDetection      && ((startX <= edgeSwipeThreshold)      || (startX >= win.screen.width - edgeSwipeThreshold))    ) {      return;    }    Utils.extend(data, {      isTouched: true,      isMoved: false,      allowTouchCallbacks: true,      isScrolling: undefined,      startMoving: undefined,    });    touches.startX = startX;    touches.startY = startY;    data.touchStartTime = Utils.now();    swiper.allowClick = true;    swiper.updateSize();    swiper.swipeDirection = undefined;    if (params.threshold > 0) { data.allowThresholdMove = false; }    if (e.type !== 'touchstart') {      var preventDefault = true;      if ($(e.target).is(data.formElements)) { preventDefault = false; }      if (        doc.activeElement        && $(doc.activeElement).is(data.formElements)        && doc.activeElement !== e.target      ) {        doc.activeElement.blur();      }      var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;      if (params.touchStartForcePreventDefault || shouldPreventDefault) {        e.preventDefault();      }    }    swiper.emit('touchStart', e);  }  function onTouchMove (event) {    var swiper = this;    var data = swiper.touchEventsData;    var params = swiper.params;    var touches = swiper.touches;    var rtl = swiper.rtlTranslate;    var e = event;    if (e.originalEvent) { e = e.originalEvent; }    if (!data.isTouched) {      if (data.startMoving && data.isScrolling) {        swiper.emit('touchMoveOpposite', e);      }      return;    }    if (data.isTouchEvent && e.type === 'mousemove') { return; }    var pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;    var pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;    if (e.preventedByNestedSwiper) {      touches.startX = pageX;      touches.startY = pageY;      return;    }    if (!swiper.allowTouchMove) {      // isMoved = true;      swiper.allowClick = false;      if (data.isTouched) {        Utils.extend(touches, {          startX: pageX,          startY: pageY,          currentX: pageX,          currentY: pageY,        });        data.touchStartTime = Utils.now();      }      return;    }    if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {      if (swiper.isVertical()) {        // Vertical        if (          (pageY < touches.startY && swiper.translate <= swiper.maxTranslate())          || (pageY > touches.startY && swiper.translate >= swiper.minTranslate())        ) {          data.isTouched = false;          data.isMoved = false;          return;        }      } else if (        (pageX < touches.startX && swiper.translate <= swiper.maxTranslate())        || (pageX > touches.startX && swiper.translate >= swiper.minTranslate())      ) {        return;      }    }    if (data.isTouchEvent && doc.activeElement) {      if (e.target === doc.activeElement && $(e.target).is(data.formElements)) {        data.isMoved = true;        swiper.allowClick = false;        return;      }    }    if (data.allowTouchCallbacks) {      swiper.emit('touchMove', e);    }    if (e.targetTouches && e.targetTouches.length > 1) { return; }    touches.currentX = pageX;    touches.currentY = pageY;    var diffX = touches.currentX - touches.startX;    var diffY = touches.currentY - touches.startY;    if (swiper.params.threshold && Math.sqrt((Math.pow( diffX, 2 )) + (Math.pow( diffY, 2 ))) < swiper.params.threshold) { return; }    if (typeof data.isScrolling === 'undefined') {      var touchAngle;      if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {        data.isScrolling = false;      } else {        // eslint-disable-next-line        if ((diffX * diffX) + (diffY * diffY) >= 25) {          touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;          data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);        }      }    }    if (data.isScrolling) {      swiper.emit('touchMoveOpposite', e);    }    if (typeof data.startMoving === 'undefined') {      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {        data.startMoving = true;      }    }    if (data.isScrolling) {      data.isTouched = false;      return;    }    if (!data.startMoving) {      return;    }    swiper.allowClick = false;    e.preventDefault();    if (params.touchMoveStopPropagation && !params.nested) {      e.stopPropagation();    }    if (!data.isMoved) {      if (params.loop) {        swiper.loopFix();      }      data.startTranslate = swiper.getTranslate();      swiper.setTransition(0);      if (swiper.animating) {        swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');      }      data.allowMomentumBounce = false;      // Grab Cursor      if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {        swiper.setGrabCursor(true);      }      swiper.emit('sliderFirstMove', e);    }    swiper.emit('sliderMove', e);    data.isMoved = true;    var diff = swiper.isHorizontal() ? diffX : diffY;    touches.diff = diff;    diff *= params.touchRatio;    if (rtl) { diff = -diff; }    swiper.swipeDirection = diff > 0 ? 'prev' : 'next';    data.currentTranslate = diff + data.startTranslate;    var disableParentSwiper = true;    var resistanceRatio = params.resistanceRatio;    if (params.touchReleaseOnEdges) {      resistanceRatio = 0;    }    if ((diff > 0 && data.currentTranslate > swiper.minTranslate())) {      disableParentSwiper = false;      if (params.resistance) { data.currentTranslate = (swiper.minTranslate() - 1) + (Math.pow( (-swiper.minTranslate() + data.startTranslate + diff), resistanceRatio )); }    } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {      disableParentSwiper = false;      if (params.resistance) { data.currentTranslate = (swiper.maxTranslate() + 1) - (Math.pow( (swiper.maxTranslate() - data.startTranslate - diff), resistanceRatio )); }    }    if (disableParentSwiper) {      e.preventedByNestedSwiper = true;    }    // Directions locks    if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {      data.currentTranslate = data.startTranslate;    }    if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {      data.currentTranslate = data.startTranslate;    }    // Threshold    if (params.threshold > 0) {      if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {        if (!data.allowThresholdMove) {          data.allowThresholdMove = true;          touches.startX = touches.currentX;          touches.startY = touches.currentY;          data.currentTranslate = data.startTranslate;          touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;          return;        }      } else {        data.currentTranslate = data.startTranslate;        return;      }    }    if (!params.followFinger) { return; }    // Update active index in free mode    if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {      swiper.updateActiveIndex();      swiper.updateSlidesClasses();    }    if (params.freeMode) {      // Velocity      if (data.velocities.length === 0) {        data.velocities.push({          position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],          time: data.touchStartTime,        });      }      data.velocities.push({        position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],        time: Utils.now(),      });    }    // Update progress    swiper.updateProgress(data.currentTranslate);    // Update translate    swiper.setTranslate(data.currentTranslate);  }  function onTouchEnd (event) {    var swiper = this;    var data = swiper.touchEventsData;    var params = swiper.params;    var touches = swiper.touches;    var rtl = swiper.rtlTranslate;    var $wrapperEl = swiper.$wrapperEl;    var slidesGrid = swiper.slidesGrid;    var snapGrid = swiper.snapGrid;    var e = event;    if (e.originalEvent) { e = e.originalEvent; }    if (data.allowTouchCallbacks) {      swiper.emit('touchEnd', e);    }    data.allowTouchCallbacks = false;    if (!data.isTouched) {      if (data.isMoved && params.grabCursor) {        swiper.setGrabCursor(false);      }      data.isMoved = false;      data.startMoving = false;      return;    }    // Return Grab Cursor    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {      swiper.setGrabCursor(false);    }    // Time diff    var touchEndTime = Utils.now();    var timeDiff = touchEndTime - data.touchStartTime;    // Tap, doubleTap, Click    if (swiper.allowClick) {      swiper.updateClickedSlide(e);      swiper.emit('tap', e);      if (timeDiff < 300 && (touchEndTime - data.lastClickTime) > 300) {        if (data.clickTimeout) { clearTimeout(data.clickTimeout); }        data.clickTimeout = Utils.nextTick(function () {          if (!swiper || swiper.destroyed) { return; }          swiper.emit('click', e);        }, 300);      }      if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {        if (data.clickTimeout) { clearTimeout(data.clickTimeout); }        swiper.emit('doubleTap', e);      }    }    data.lastClickTime = Utils.now();    Utils.nextTick(function () {      if (!swiper.destroyed) { swiper.allowClick = true; }    });    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {      data.isTouched = false;      data.isMoved = false;      data.startMoving = false;      return;    }    data.isTouched = false;    data.isMoved = false;    data.startMoving = false;    var currentPos;    if (params.followFinger) {      currentPos = rtl ? swiper.translate : -swiper.translate;    } else {      currentPos = -data.currentTranslate;    }    if (params.freeMode) {      if (currentPos < -swiper.minTranslate()) {        swiper.slideTo(swiper.activeIndex);        return;      }      if (currentPos > -swiper.maxTranslate()) {        if (swiper.slides.length < snapGrid.length) {          swiper.slideTo(snapGrid.length - 1);        } else {          swiper.slideTo(swiper.slides.length - 1);        }        return;      }      if (params.freeModeMomentum) {        if (data.velocities.length > 1) {          var lastMoveEvent = data.velocities.pop();          var velocityEvent = data.velocities.pop();          var distance = lastMoveEvent.position - velocityEvent.position;          var time = lastMoveEvent.time - velocityEvent.time;          swiper.velocity = distance / time;          swiper.velocity /= 2;          if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {            swiper.velocity = 0;          }          // this implies that the user stopped moving a finger then released.          // There would be no events with distance zero, so the last event is stale.          if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {            swiper.velocity = 0;          }        } else {          swiper.velocity = 0;        }        swiper.velocity *= params.freeModeMomentumVelocityRatio;        data.velocities.length = 0;        var momentumDuration = 1000 * params.freeModeMomentumRatio;        var momentumDistance = swiper.velocity * momentumDuration;        var newPosition = swiper.translate + momentumDistance;        if (rtl) { newPosition = -newPosition; }        var doBounce = false;        var afterBouncePosition;        var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;        var needsLoopFix;        if (newPosition < swiper.maxTranslate()) {          if (params.freeModeMomentumBounce) {            if (newPosition + swiper.maxTranslate() < -bounceAmount) {              newPosition = swiper.maxTranslate() - bounceAmount;            }            afterBouncePosition = swiper.maxTranslate();            doBounce = true;            data.allowMomentumBounce = true;          } else {            newPosition = swiper.maxTranslate();          }          if (params.loop && params.centeredSlides) { needsLoopFix = true; }        } else if (newPosition > swiper.minTranslate()) {          if (params.freeModeMomentumBounce) {            if (newPosition - swiper.minTranslate() > bounceAmount) {              newPosition = swiper.minTranslate() + bounceAmount;            }            afterBouncePosition = swiper.minTranslate();            doBounce = true;            data.allowMomentumBounce = true;          } else {            newPosition = swiper.minTranslate();          }          if (params.loop && params.centeredSlides) { needsLoopFix = true; }        } else if (params.freeModeSticky) {          var nextSlide;          for (var j = 0; j < snapGrid.length; j += 1) {            if (snapGrid[j] > -newPosition) {              nextSlide = j;              break;            }          }          if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {            newPosition = snapGrid[nextSlide];          } else {            newPosition = snapGrid[nextSlide - 1];          }          newPosition = -newPosition;        }        if (needsLoopFix) {          swiper.once('transitionEnd', function () {            swiper.loopFix();          });        }        // Fix duration        if (swiper.velocity !== 0) {          if (rtl) {            momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);          } else {            momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);          }        } else if (params.freeModeSticky) {          swiper.slideToClosest();          return;        }        if (params.freeModeMomentumBounce && doBounce) {          swiper.updateProgress(afterBouncePosition);          swiper.setTransition(momentumDuration);          swiper.setTranslate(newPosition);          swiper.transitionStart(true, swiper.swipeDirection);          swiper.animating = true;          $wrapperEl.transitionEnd(function () {            if (!swiper || swiper.destroyed || !data.allowMomentumBounce) { return; }            swiper.emit('momentumBounce');            swiper.setTransition(params.speed);            swiper.setTranslate(afterBouncePosition);            $wrapperEl.transitionEnd(function () {              if (!swiper || swiper.destroyed) { return; }              swiper.transitionEnd();            });          });        } else if (swiper.velocity) {          swiper.updateProgress(newPosition);          swiper.setTransition(momentumDuration);          swiper.setTranslate(newPosition);          swiper.transitionStart(true, swiper.swipeDirection);          if (!swiper.animating) {            swiper.animating = true;            $wrapperEl.transitionEnd(function () {              if (!swiper || swiper.destroyed) { return; }              swiper.transitionEnd();            });          }        } else {          swiper.updateProgress(newPosition);        }        swiper.updateActiveIndex();        swiper.updateSlidesClasses();      } else if (params.freeModeSticky) {        swiper.slideToClosest();        return;      }      if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {        swiper.updateProgress();        swiper.updateActiveIndex();        swiper.updateSlidesClasses();      }      return;    }    // Find current slide    var stopIndex = 0;    var groupSize = swiper.slidesSizesGrid[0];    for (var i = 0; i < slidesGrid.length; i += params.slidesPerGroup) {      if (typeof slidesGrid[i + params.slidesPerGroup] !== 'undefined') {        if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + params.slidesPerGroup]) {          stopIndex = i;          groupSize = slidesGrid[i + params.slidesPerGroup] - slidesGrid[i];        }      } else if (currentPos >= slidesGrid[i]) {        stopIndex = i;        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];      }    }    // Find current slide size    var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;    if (timeDiff > params.longSwipesMs) {      // Long touches      if (!params.longSwipes) {        swiper.slideTo(swiper.activeIndex);        return;      }      if (swiper.swipeDirection === 'next') {        if (ratio >= params.longSwipesRatio) { swiper.slideTo(stopIndex + params.slidesPerGroup); }        else { swiper.slideTo(stopIndex); }      }      if (swiper.swipeDirection === 'prev') {        if (ratio > (1 - params.longSwipesRatio)) { swiper.slideTo(stopIndex + params.slidesPerGroup); }        else { swiper.slideTo(stopIndex); }      }    } else {      // Short swipes      if (!params.shortSwipes) {        swiper.slideTo(swiper.activeIndex);        return;      }      if (swiper.swipeDirection === 'next') {        swiper.slideTo(stopIndex + params.slidesPerGroup);      }      if (swiper.swipeDirection === 'prev') {        swiper.slideTo(stopIndex);      }    }  }  function onResize () {    var swiper = this;    var params = swiper.params;    var el = swiper.el;    if (el && el.offsetWidth === 0) { return; }    // Breakpoints    if (params.breakpoints) {      swiper.setBreakpoint();    }    // Save locks    var allowSlideNext = swiper.allowSlideNext;    var allowSlidePrev = swiper.allowSlidePrev;    var snapGrid = swiper.snapGrid;    // Disable locks on resize    swiper.allowSlideNext = true;    swiper.allowSlidePrev = true;    swiper.updateSize();    swiper.updateSlides();    if (params.freeMode) {      var newTranslate = Math.min(Math.max(swiper.translate, swiper.maxTranslate()), swiper.minTranslate());      swiper.setTranslate(newTranslate);      swiper.updateActiveIndex();      swiper.updateSlidesClasses();      if (params.autoHeight) {        swiper.updateAutoHeight();      }    } else {      swiper.updateSlidesClasses();      if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {        swiper.slideTo(swiper.slides.length - 1, 0, false, true);      } else {        swiper.slideTo(swiper.activeIndex, 0, false, true);      }    }    // Return locks after resize    swiper.allowSlidePrev = allowSlidePrev;    swiper.allowSlideNext = allowSlideNext;    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {      swiper.checkOverflow();    }  }  function onClick (e) {    var swiper = this;    if (!swiper.allowClick) {      if (swiper.params.preventClicks) { e.preventDefault(); }      if (swiper.params.preventClicksPropagation && swiper.animating) {        e.stopPropagation();        e.stopImmediatePropagation();      }    }  }  function attachEvents() {    var swiper = this;    var params = swiper.params;    var touchEvents = swiper.touchEvents;    var el = swiper.el;    var wrapperEl = swiper.wrapperEl;    {      swiper.onTouchStart = onTouchStart.bind(swiper);      swiper.onTouchMove = onTouchMove.bind(swiper);      swiper.onTouchEnd = onTouchEnd.bind(swiper);    }    swiper.onClick = onClick.bind(swiper);    var target = params.touchEventsTarget === 'container' ? el : wrapperEl;    var capture = !!params.nested;    // Touch Events    {      if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {        target.addEventListener(touchEvents.start, swiper.onTouchStart, false);        doc.addEventListener(touchEvents.move, swiper.onTouchMove, capture);        doc.addEventListener(touchEvents.end, swiper.onTouchEnd, false);      } else {        if (Support.touch) {          var passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;          target.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);          target.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? { passive: false, capture: capture } : capture);          target.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);        }        if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {          target.addEventListener('mousedown', swiper.onTouchStart, false);          doc.addEventListener('mousemove', swiper.onTouchMove, capture);          doc.addEventListener('mouseup', swiper.onTouchEnd, false);        }      }      // Prevent Links Clicks      if (params.preventClicks || params.preventClicksPropagation) {        target.addEventListener('click', swiper.onClick, true);      }    }    // Resize handler    swiper.on((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize, true);  }  function detachEvents() {    var swiper = this;    var params = swiper.params;    var touchEvents = swiper.touchEvents;    var el = swiper.el;    var wrapperEl = swiper.wrapperEl;    var target = params.touchEventsTarget === 'container' ? el : wrapperEl;    var capture = !!params.nested;    // Touch Events    {      if (!Support.touch && (Support.pointerEvents || Support.prefixedPointerEvents)) {        target.removeEventListener(touchEvents.start, swiper.onTouchStart, false);        doc.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);        doc.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);      } else {        if (Support.touch) {          var passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;          target.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);          target.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);          target.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);        }        if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {          target.removeEventListener('mousedown', swiper.onTouchStart, false);          doc.removeEventListener('mousemove', swiper.onTouchMove, capture);          doc.removeEventListener('mouseup', swiper.onTouchEnd, false);        }      }      // Prevent Links Clicks      if (params.preventClicks || params.preventClicksPropagation) {        target.removeEventListener('click', swiper.onClick, true);      }    }    // Resize handler    swiper.off((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize);  }  var events = {    attachEvents: attachEvents,    detachEvents: detachEvents,  };  function setBreakpoint () {    var swiper = this;    var activeIndex = swiper.activeIndex;    var initialized = swiper.initialized;    var loopedSlides = swiper.loopedSlides; if ( loopedSlides === void 0 ) loopedSlides = 0;    var params = swiper.params;    var breakpoints = params.breakpoints;    if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) { return; }    // Set breakpoint for window width and update parameters    var breakpoint = swiper.getBreakpoint(breakpoints);    if (breakpoint && swiper.currentBreakpoint !== breakpoint) {      var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;      if (breakpointOnlyParams) {        ['slidesPerView', 'spaceBetween', 'slidesPerGroup'].forEach(function (param) {          var paramValue = breakpointOnlyParams[param];          if (typeof paramValue === 'undefined') { return; }          if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {            breakpointOnlyParams[param] = 'auto';          } else if (param === 'slidesPerView') {            breakpointOnlyParams[param] = parseFloat(paramValue);          } else {            breakpointOnlyParams[param] = parseInt(paramValue, 10);          }        });      }      var breakpointParams = breakpointOnlyParams || swiper.originalParams;      var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView);      Utils.extend(swiper.params, breakpointParams);      Utils.extend(swiper, {        allowTouchMove: swiper.params.allowTouchMove,        allowSlideNext: swiper.params.allowSlideNext,        allowSlidePrev: swiper.params.allowSlidePrev,      });      swiper.currentBreakpoint = breakpoint;      if (needsReLoop && initialized) {        swiper.loopDestroy();        swiper.loopCreate();        swiper.updateSlides();        swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);      }      swiper.emit('breakpoint', breakpointParams);    }  }  function getBreakpoint (breakpoints) {    var swiper = this;    // Get breakpoint for window width    if (!breakpoints) { return undefined; }    var breakpoint = false;    var points = [];    Object.keys(breakpoints).forEach(function (point) {      points.push(point);    });    points.sort(function (a, b) { return parseInt(a, 10) - parseInt(b, 10); });    for (var i = 0; i < points.length; i += 1) {      var point = points[i];      if (swiper.params.breakpointsInverse) {        if (point <= win.innerWidth) {          breakpoint = point;        }      } else if (point >= win.innerWidth && !breakpoint) {        breakpoint = point;      }    }    return breakpoint || 'max';  }  var breakpoints = { setBreakpoint: setBreakpoint, getBreakpoint: getBreakpoint };  var Browser = (function Browser() {    function isSafari() {      var ua = win.navigator.userAgent.toLowerCase();      return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);    }    return {      isIE: !!win.navigator.userAgent.match(/Trident/g) || !!win.navigator.userAgent.match(/MSIE/g),      isEdge: !!win.navigator.userAgent.match(/Edge/g),      isSafari: isSafari(),      isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(win.navigator.userAgent),    };  }());  function addClasses () {    var swiper = this;    var classNames = swiper.classNames;    var params = swiper.params;    var rtl = swiper.rtl;    var $el = swiper.$el;    var suffixes = [];    suffixes.push(params.direction);    if (params.freeMode) {      suffixes.push('free-mode');    }    if (!Support.flexbox) {      suffixes.push('no-flexbox');    }    if (params.autoHeight) {      suffixes.push('autoheight');    }    if (rtl) {      suffixes.push('rtl');    }    if (params.slidesPerColumn > 1) {      suffixes.push('multirow');    }    if (Device.android) {      suffixes.push('android');    }    if (Device.ios) {      suffixes.push('ios');    }    // WP8 Touch Events Fix    if ((Browser.isIE || Browser.isEdge) && (Support.pointerEvents || Support.prefixedPointerEvents)) {      suffixes.push(("wp8-" + (params.direction)));    }    suffixes.forEach(function (suffix) {      classNames.push(params.containerModifierClass + suffix);    });    $el.addClass(classNames.join(' '));  }  function removeClasses () {    var swiper = this;    var $el = swiper.$el;    var classNames = swiper.classNames;    $el.removeClass(classNames.join(' '));  }  var classes = { addClasses: addClasses, removeClasses: removeClasses };  function loadImage (imageEl, src, srcset, sizes, checkForComplete, callback) {    var image;    function onReady() {      if (callback) { callback(); }    }    if (!imageEl.complete || !checkForComplete) {      if (src) {        image = new win.Image();        image.onload = onReady;        image.onerror = onReady;        if (sizes) {          image.sizes = sizes;        }        if (srcset) {          image.srcset = srcset;        }        if (src) {          image.src = src;        }      } else {        onReady();      }    } else {      // image already loaded...      onReady();    }  }  function preloadImages () {    var swiper = this;    swiper.imagesToLoad = swiper.$el.find('img');    function onReady() {      if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) { return; }      if (swiper.imagesLoaded !== undefined) { swiper.imagesLoaded += 1; }      if (swiper.imagesLoaded === swiper.imagesToLoad.length) {        if (swiper.params.updateOnImagesReady) { swiper.update(); }        swiper.emit('imagesReady');      }    }    for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {      var imageEl = swiper.imagesToLoad[i];      swiper.loadImage(        imageEl,        imageEl.currentSrc || imageEl.getAttribute('src'),        imageEl.srcset || imageEl.getAttribute('srcset'),        imageEl.sizes || imageEl.getAttribute('sizes'),        true,        onReady      );    }  }  var images = {    loadImage: loadImage,    preloadImages: preloadImages,  };  function checkOverflow() {    var swiper = this;    var wasLocked = swiper.isLocked;    swiper.isLocked = swiper.snapGrid.length === 1;    swiper.allowSlideNext = !swiper.isLocked;    swiper.allowSlidePrev = !swiper.isLocked;    // events    if (wasLocked !== swiper.isLocked) { swiper.emit(swiper.isLocked ? 'lock' : 'unlock'); }    if (wasLocked && wasLocked !== swiper.isLocked) {      swiper.isEnd = false;      swiper.navigation.update();    }  }  var checkOverflow$1 = { checkOverflow: checkOverflow };  var defaults = {    init: true,    direction: 'horizontal',    touchEventsTarget: 'container',    initialSlide: 0,    speed: 300,    //    preventInteractionOnTransition: false,    // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).    edgeSwipeDetection: false,    edgeSwipeThreshold: 20,    // Free mode    freeMode: false,    freeModeMomentum: true,    freeModeMomentumRatio: 1,    freeModeMomentumBounce: true,    freeModeMomentumBounceRatio: 1,    freeModeMomentumVelocityRatio: 1,    freeModeSticky: false,    freeModeMinimumVelocity: 0.02,    // Autoheight    autoHeight: false,    // Set wrapper width    setWrapperSize: false,    // Virtual Translate    virtualTranslate: false,    // Effects    effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'    // Breakpoints    breakpoints: undefined,    breakpointsInverse: false,    // Slides grid    spaceBetween: 0,    slidesPerView: 1,    slidesPerColumn: 1,    slidesPerColumnFill: 'column',    slidesPerGroup: 1,    centeredSlides: false,    slidesOffsetBefore: 0, // in px    slidesOffsetAfter: 0, // in px    normalizeSlideIndex: true,    centerInsufficientSlides: false,    // Disable swiper and hide navigation when container not overflow    watchOverflow: false,    // Round length    roundLengths: false,    // Touches    touchRatio: 1,    touchAngle: 45,    simulateTouch: true,    shortSwipes: true,    longSwipes: true,    longSwipesRatio: 0.5,    longSwipesMs: 300,    followFinger: true,    allowTouchMove: true,    threshold: 0,    touchMoveStopPropagation: true,    touchStartPreventDefault: true,    touchStartForcePreventDefault: false,    touchReleaseOnEdges: false,    // Unique Navigation Elements    uniqueNavElements: true,    // Resistance    resistance: true,    resistanceRatio: 0.85,    // Progress    watchSlidesProgress: false,    watchSlidesVisibility: false,    // Cursor    grabCursor: false,    // Clicks    preventClicks: true,    preventClicksPropagation: true,    slideToClickedSlide: false,    // Images    preloadImages: true,    updateOnImagesReady: true,    // loop    loop: false,    loopAdditionalSlides: 0,    loopedSlides: null,    loopFillGroupWithBlank: false,    // Swiping/no swiping    allowSlidePrev: true,    allowSlideNext: true,    swipeHandler: null, // '.swipe-handler',    noSwiping: true,    noSwipingClass: 'swiper-no-swiping',    noSwipingSelector: null,    // Passive Listeners    passiveListeners: true,    // NS    containerModifierClass: 'swiper-container-', // NEW    slideClass: 'swiper-slide',    slideBlankClass: 'swiper-slide-invisible-blank',    slideActiveClass: 'swiper-slide-active',    slideDuplicateActiveClass: 'swiper-slide-duplicate-active',    slideVisibleClass: 'swiper-slide-visible',    slideDuplicateClass: 'swiper-slide-duplicate',    slideNextClass: 'swiper-slide-next',    slideDuplicateNextClass: 'swiper-slide-duplicate-next',    slidePrevClass: 'swiper-slide-prev',    slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',    wrapperClass: 'swiper-wrapper',    // Callbacks    runCallbacksOnInit: true,  };  var prototypes = {    update: update,    translate: translate,    transition: transition$1,    slide: slide,    loop: loop,    grabCursor: grabCursor,    manipulation: manipulation,    events: events,    breakpoints: breakpoints,    checkOverflow: checkOverflow$1,    classes: classes,    images: images,  };  var extendedDefaults = {};  var Swiper = /*@__PURE__*/(function (SwiperClass$$1) {    function Swiper() {      var assign;      var args = [], len = arguments.length;      while ( len-- ) args[ len ] = arguments[ len ];      var el;      var params;      if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {        params = args[0];      } else {        (assign = args, el = assign[0], params = assign[1]);      }      if (!params) { params = {}; }      params = Utils.extend({}, params);      if (el && !params.el) { params.el = el; }      SwiperClass$$1.call(this, params);      Object.keys(prototypes).forEach(function (prototypeGroup) {        Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {          if (!Swiper.prototype[protoMethod]) {            Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];          }        });      });      // Swiper Instance      var swiper = this;      if (typeof swiper.modules === 'undefined') {        swiper.modules = {};      }      Object.keys(swiper.modules).forEach(function (moduleName) {        var module = swiper.modules[moduleName];        if (module.params) {          var moduleParamName = Object.keys(module.params)[0];          var moduleParams = module.params[moduleParamName];          if (typeof moduleParams !== 'object' || moduleParams === null) { return; }          if (!(moduleParamName in params && 'enabled' in moduleParams)) { return; }          if (params[moduleParamName] === true) {            params[moduleParamName] = { enabled: true };          }          if (            typeof params[moduleParamName] === 'object'            && !('enabled' in params[moduleParamName])          ) {            params[moduleParamName].enabled = true;          }          if (!params[moduleParamName]) { params[moduleParamName] = { enabled: false }; }        }      });      // Extend defaults with modules params      var swiperParams = Utils.extend({}, defaults);      swiper.useModulesParams(swiperParams);      // Extend defaults with passed params      swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);      swiper.originalParams = Utils.extend({}, swiper.params);      swiper.passedParams = Utils.extend({}, params);      // Save Dom lib      swiper.$ = $;      // Find el      var $el = $(swiper.params.el);      el = $el[0];      if (!el) {        return undefined;      }      if ($el.length > 1) {        var swipers = [];        $el.each(function (index, containerEl) {          var newParams = Utils.extend({}, params, { el: containerEl });          swipers.push(new Swiper(newParams));        });        return swipers;      }      el.swiper = swiper;      $el.data('swiper', swiper);      // Find Wrapper      var $wrapperEl = $el.children(("." + (swiper.params.wrapperClass)));      // Extend Swiper      Utils.extend(swiper, {        $el: $el,        el: el,        $wrapperEl: $wrapperEl,        wrapperEl: $wrapperEl[0],        // Classes        classNames: [],        // Slides        slides: $(),        slidesGrid: [],        snapGrid: [],        slidesSizesGrid: [],        // isDirection        isHorizontal: function isHorizontal() {          return swiper.params.direction === 'horizontal';        },        isVertical: function isVertical() {          return swiper.params.direction === 'vertical';        },        // RTL        rtl: (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),        rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),        wrongRTL: $wrapperEl.css('display') === '-webkit-box',        // Indexes        activeIndex: 0,        realIndex: 0,        //        isBeginning: true,        isEnd: false,        // Props        translate: 0,        previousTranslate: 0,        progress: 0,        velocity: 0,        animating: false,        // Locks        allowSlideNext: swiper.params.allowSlideNext,        allowSlidePrev: swiper.params.allowSlidePrev,        // Touch Events        touchEvents: (function touchEvents() {          var touch = ['touchstart', 'touchmove', 'touchend'];          var desktop = ['mousedown', 'mousemove', 'mouseup'];          if (Support.pointerEvents) {            desktop = ['pointerdown', 'pointermove', 'pointerup'];          } else if (Support.prefixedPointerEvents) {            desktop = ['MSPointerDown', 'MSPointerMove', 'MSPointerUp'];          }          swiper.touchEventsTouch = {            start: touch[0],            move: touch[1],            end: touch[2],          };          swiper.touchEventsDesktop = {            start: desktop[0],            move: desktop[1],            end: desktop[2],          };          return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;        }()),        touchEventsData: {          isTouched: undefined,          isMoved: undefined,          allowTouchCallbacks: undefined,          touchStartTime: undefined,          isScrolling: undefined,          currentTranslate: undefined,          startTranslate: undefined,          allowThresholdMove: undefined,          // Form elements to match          formElements: 'input, select, option, textarea, button, video',          // Last click time          lastClickTime: Utils.now(),          clickTimeout: undefined,          // Velocities          velocities: [],          allowMomentumBounce: undefined,          isTouchEvent: undefined,          startMoving: undefined,        },        // Clicks        allowClick: true,        // Touches        allowTouchMove: swiper.params.allowTouchMove,        touches: {          startX: 0,          startY: 0,          currentX: 0,          currentY: 0,          diff: 0,        },        // Images        imagesToLoad: [],        imagesLoaded: 0,      });      // Install Modules      swiper.useModules();      // Init      if (swiper.params.init) {        swiper.init();      }      // Return app instance      return swiper;    }    if ( SwiperClass$$1 ) Swiper.__proto__ = SwiperClass$$1;    Swiper.prototype = Object.create( SwiperClass$$1 && SwiperClass$$1.prototype );    Swiper.prototype.constructor = Swiper;    var staticAccessors = { extendedDefaults: { configurable: true },defaults: { configurable: true },Class: { configurable: true },$: { configurable: true } };    Swiper.prototype.slidesPerViewDynamic = function slidesPerViewDynamic () {      var swiper = this;      var params = swiper.params;      var slides = swiper.slides;      var slidesGrid = swiper.slidesGrid;      var swiperSize = swiper.size;      var activeIndex = swiper.activeIndex;      var spv = 1;      if (params.centeredSlides) {        var slideSize = slides[activeIndex].swiperSlideSize;        var breakLoop;        for (var i = activeIndex + 1; i < slides.length; i += 1) {          if (slides[i] && !breakLoop) {            slideSize += slides[i].swiperSlideSize;            spv += 1;            if (slideSize > swiperSize) { breakLoop = true; }          }        }        for (var i$1 = activeIndex - 1; i$1 >= 0; i$1 -= 1) {          if (slides[i$1] && !breakLoop) {            slideSize += slides[i$1].swiperSlideSize;            spv += 1;            if (slideSize > swiperSize) { breakLoop = true; }          }        }      } else {        for (var i$2 = activeIndex + 1; i$2 < slides.length; i$2 += 1) {          if (slidesGrid[i$2] - slidesGrid[activeIndex] < swiperSize) {            spv += 1;          }        }      }      return spv;    };    Swiper.prototype.update = function update$$1 () {      var swiper = this;      if (!swiper || swiper.destroyed) { return; }      var snapGrid = swiper.snapGrid;      var params = swiper.params;      // Breakpoints      if (params.breakpoints) {        swiper.setBreakpoint();      }      swiper.updateSize();      swiper.updateSlides();      swiper.updateProgress();      swiper.updateSlidesClasses();      function setTranslate() {        var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;        var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());        swiper.setTranslate(newTranslate);        swiper.updateActiveIndex();        swiper.updateSlidesClasses();      }      var translated;      if (swiper.params.freeMode) {        setTranslate();        if (swiper.params.autoHeight) {          swiper.updateAutoHeight();        }      } else {        if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {          translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);        } else {          translated = swiper.slideTo(swiper.activeIndex, 0, false, true);        }        if (!translated) {          setTranslate();        }      }      if (params.watchOverflow && snapGrid !== swiper.snapGrid) {        swiper.checkOverflow();      }      swiper.emit('update');    };    Swiper.prototype.init = function init () {      var swiper = this;      if (swiper.initialized) { return; }      swiper.emit('beforeInit');      // Set breakpoint      if (swiper.params.breakpoints) {        swiper.setBreakpoint();      }      // Add Classes      swiper.addClasses();      // Create loop      if (swiper.params.loop) {        swiper.loopCreate();      }      // Update size      swiper.updateSize();      // Update slides      swiper.updateSlides();      if (swiper.params.watchOverflow) {        swiper.checkOverflow();      }      // Set Grab Cursor      if (swiper.params.grabCursor) {        swiper.setGrabCursor();      }      if (swiper.params.preloadImages) {        swiper.preloadImages();      }      // Slide To Initial Slide      if (swiper.params.loop) {        swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);      } else {        swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);      }      // Attach events      swiper.attachEvents();      // Init Flag      swiper.initialized = true;      // Emit      swiper.emit('init');    };    Swiper.prototype.destroy = function destroy (deleteInstance, cleanStyles) {      if ( deleteInstance === void 0 ) deleteInstance = true;      if ( cleanStyles === void 0 ) cleanStyles = true;      var swiper = this;      var params = swiper.params;      var $el = swiper.$el;      var $wrapperEl = swiper.$wrapperEl;      var slides = swiper.slides;      if (typeof swiper.params === 'undefined' || swiper.destroyed) {        return null;      }      swiper.emit('beforeDestroy');      // Init Flag      swiper.initialized = false;      // Detach events      swiper.detachEvents();      // Destroy loop      if (params.loop) {        swiper.loopDestroy();      }      // Cleanup styles      if (cleanStyles) {        swiper.removeClasses();        $el.removeAttr('style');        $wrapperEl.removeAttr('style');        if (slides && slides.length) {          slides            .removeClass([              params.slideVisibleClass,              params.slideActiveClass,              params.slideNextClass,              params.slidePrevClass ].join(' '))            .removeAttr('style')            .removeAttr('data-swiper-slide-index')            .removeAttr('data-swiper-column')            .removeAttr('data-swiper-row');        }      }      swiper.emit('destroy');      // Detach emitter events      Object.keys(swiper.eventsListeners).forEach(function (eventName) {        swiper.off(eventName);      });      if (deleteInstance !== false) {        swiper.$el[0].swiper = null;        swiper.$el.data('swiper', null);        Utils.deleteProps(swiper);      }      swiper.destroyed = true;      return null;    };    Swiper.extendDefaults = function extendDefaults (newDefaults) {      Utils.extend(extendedDefaults, newDefaults);    };    staticAccessors.extendedDefaults.get = function () {      return extendedDefaults;    };    staticAccessors.defaults.get = function () {      return defaults;    };    staticAccessors.Class.get = function () {      return SwiperClass$$1;    };    staticAccessors.$.get = function () {      return $;    };    Object.defineProperties( Swiper, staticAccessors );    return Swiper;  }(SwiperClass));  var Device$1 = {    name: 'device',    proto: {      device: Device,    },    static: {      device: Device,    },  };  var Support$1 = {    name: 'support',    proto: {      support: Support,    },    static: {      support: Support,    },  };  var Browser$1 = {    name: 'browser',    proto: {      browser: Browser,    },    static: {      browser: Browser,    },  };  var Resize = {    name: 'resize',    create: function create() {      var swiper = this;      Utils.extend(swiper, {        resize: {          resizeHandler: function resizeHandler() {            if (!swiper || swiper.destroyed || !swiper.initialized) { return; }            swiper.emit('beforeResize');            swiper.emit('resize');          },          orientationChangeHandler: function orientationChangeHandler() {            if (!swiper || swiper.destroyed || !swiper.initialized) { return; }            swiper.emit('orientationchange');          },        },      });    },    on: {      init: function init() {        var swiper = this;        // Emit resize        win.addEventListener('resize', swiper.resize.resizeHandler);        // Emit orientationchange        win.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);      },      destroy: function destroy() {        var swiper = this;        win.removeEventListener('resize', swiper.resize.resizeHandler);        win.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);      },    },  };  var Observer = {    func: win.MutationObserver || win.WebkitMutationObserver,    attach: function attach(target, options) {      if ( options === void 0 ) options = {};      var swiper = this;      var ObserverFunc = Observer.func;      var observer = new ObserverFunc(function (mutations) {        // The observerUpdate event should only be triggered        // once despite the number of mutations.  Additional        // triggers are redundant and are very costly        if (mutations.length === 1) {          swiper.emit('observerUpdate', mutations[0]);          return;        }        var observerUpdate = function observerUpdate() {          swiper.emit('observerUpdate', mutations[0]);        };        if (win.requestAnimationFrame) {          win.requestAnimationFrame(observerUpdate);        } else {          win.setTimeout(observerUpdate, 0);        }      });      observer.observe(target, {        attributes: typeof options.attributes === 'undefined' ? true : options.attributes,        childList: typeof options.childList === 'undefined' ? true : options.childList,        characterData: typeof options.characterData === 'undefined' ? true : options.characterData,      });      swiper.observer.observers.push(observer);    },    init: function init() {      var swiper = this;      if (!Support.observer || !swiper.params.observer) { return; }      if (swiper.params.observeParents) {        var containerParents = swiper.$el.parents();        for (var i = 0; i < containerParents.length; i += 1) {          swiper.observer.attach(containerParents[i]);        }      }      // Observe container      swiper.observer.attach(swiper.$el[0], { childList: false });      // Observe wrapper      swiper.observer.attach(swiper.$wrapperEl[0], { attributes: false });    },    destroy: function destroy() {      var swiper = this;      swiper.observer.observers.forEach(function (observer) {        observer.disconnect();      });      swiper.observer.observers = [];    },  };  var Observer$1 = {    name: 'observer',    params: {      observer: false,      observeParents: false,    },    create: function create() {      var swiper = this;      Utils.extend(swiper, {        observer: {          init: Observer.init.bind(swiper),          attach: Observer.attach.bind(swiper),          destroy: Observer.destroy.bind(swiper),          observers: [],        },      });    },    on: {      init: function init() {        var swiper = this;        swiper.observer.init();      },      destroy: function destroy() {        var swiper = this;        swiper.observer.destroy();      },    },  };  var Virtual = {    update: function update(force) {      var swiper = this;      var ref = swiper.params;      var slidesPerView = ref.slidesPerView;      var slidesPerGroup = ref.slidesPerGroup;      var centeredSlides = ref.centeredSlides;      var ref$1 = swiper.params.virtual;      var addSlidesBefore = ref$1.addSlidesBefore;      var addSlidesAfter = ref$1.addSlidesAfter;      var ref$2 = swiper.virtual;      var previousFrom = ref$2.from;      var previousTo = ref$2.to;      var slides = ref$2.slides;      var previousSlidesGrid = ref$2.slidesGrid;      var renderSlide = ref$2.renderSlide;      var previousOffset = ref$2.offset;      swiper.updateActiveIndex();      var activeIndex = swiper.activeIndex || 0;      var offsetProp;      if (swiper.rtlTranslate) { offsetProp = 'right'; }      else { offsetProp = swiper.isHorizontal() ? 'left' : 'top'; }      var slidesAfter;      var slidesBefore;      if (centeredSlides) {        slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;        slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;      } else {        slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;        slidesBefore = slidesPerGroup + addSlidesAfter;      }      var from = Math.max((activeIndex || 0) - slidesBefore, 0);      var to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);      var offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);      Utils.extend(swiper.virtual, {        from: from,        to: to,        offset: offset,        slidesGrid: swiper.slidesGrid,      });      function onRendered() {        swiper.updateSlides();        swiper.updateProgress();        swiper.updateSlidesClasses();        if (swiper.lazy && swiper.params.lazy.enabled) {          swiper.lazy.load();        }      }      if (previousFrom === from && previousTo === to && !force) {        if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {          swiper.slides.css(offsetProp, (offset + "px"));        }        swiper.updateProgress();        return;      }      if (swiper.params.virtual.renderExternal) {        swiper.params.virtual.renderExternal.call(swiper, {          offset: offset,          from: from,          to: to,          slides: (function getSlides() {            var slidesToRender = [];            for (var i = from; i <= to; i += 1) {              slidesToRender.push(slides[i]);            }            return slidesToRender;          }()),        });        onRendered();        return;      }      var prependIndexes = [];      var appendIndexes = [];      if (force) {        swiper.$wrapperEl.find(("." + (swiper.params.slideClass))).remove();      } else {        for (var i = previousFrom; i <= previousTo; i += 1) {          if (i < from || i > to) {            swiper.$wrapperEl.find(("." + (swiper.params.slideClass) + "[data-swiper-slide-index=\"" + i + "\"]")).remove();          }        }      }      for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {        if (i$1 >= from && i$1 <= to) {          if (typeof previousTo === 'undefined' || force) {            appendIndexes.push(i$1);          } else {            if (i$1 > previousTo) { appendIndexes.push(i$1); }            if (i$1 < previousFrom) { prependIndexes.push(i$1); }          }        }      }      appendIndexes.forEach(function (index) {        swiper.$wrapperEl.append(renderSlide(slides[index], index));      });      prependIndexes.sort(function (a, b) { return b - a; }).forEach(function (index) {        swiper.$wrapperEl.prepend(renderSlide(slides[index], index));      });      swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, (offset + "px"));      onRendered();    },    renderSlide: function renderSlide(slide, index) {      var swiper = this;      var params = swiper.params.virtual;      if (params.cache && swiper.virtual.cache[index]) {        return swiper.virtual.cache[index];      }      var $slideEl = params.renderSlide        ? $(params.renderSlide.call(swiper, slide, index))        : $(("<div class=\"" + (swiper.params.slideClass) + "\" data-swiper-slide-index=\"" + index + "\">" + slide + "</div>"));      if (!$slideEl.attr('data-swiper-slide-index')) { $slideEl.attr('data-swiper-slide-index', index); }      if (params.cache) { swiper.virtual.cache[index] = $slideEl; }      return $slideEl;    },    appendSlide: function appendSlide(slide) {      var swiper = this;      swiper.virtual.slides.push(slide);      swiper.virtual.update(true);    },    prependSlide: function prependSlide(slide) {      var swiper = this;      swiper.virtual.slides.unshift(slide);      if (swiper.params.virtual.cache) {        var cache = swiper.virtual.cache;        var newCache = {};        Object.keys(cache).forEach(function (cachedIndex) {          newCache[cachedIndex + 1] = cache[cachedIndex];        });        swiper.virtual.cache = newCache;      }      swiper.virtual.update(true);      swiper.slideNext(0);    },  };  var Virtual$1 = {    name: 'virtual',    params: {      virtual: {        enabled: false,        slides: [],        cache: true,        renderSlide: null,        renderExternal: null,        addSlidesBefore: 0,        addSlidesAfter: 0,      },    },    create: function create() {      var swiper = this;      Utils.extend(swiper, {        virtual: {          update: Virtual.update.bind(swiper),          appendSlide: Virtual.appendSlide.bind(swiper),          prependSlide: Virtual.prependSlide.bind(swiper),          renderSlide: Virtual.renderSlide.bind(swiper),          slides: swiper.params.virtual.slides,          cache: {},        },      });    },    on: {      beforeInit: function beforeInit() {        var swiper = this;        if (!swiper.params.virtual.enabled) { return; }        swiper.classNames.push(((swiper.params.containerModifierClass) + "virtual"));        var overwriteParams = {          watchSlidesProgress: true,        };        Utils.extend(swiper.params, overwriteParams);        Utils.extend(swiper.originalParams, overwriteParams);        if (!swiper.params.initialSlide) {          swiper.virtual.update();        }      },      setTranslate: function setTranslate() {        var swiper = this;        if (!swiper.params.virtual.enabled) { return; }        swiper.virtual.update();      },    },  };  var Keyboard = {    handle: function handle(event) {      var swiper = this;      var rtl = swiper.rtlTranslate;      var e = event;      if (e.originalEvent) { e = e.originalEvent; } // jquery fix      var kc = e.keyCode || e.charCode;      // Directions locks      if (!swiper.allowSlideNext && ((swiper.isHorizontal() && kc === 39) || (swiper.isVertical() && kc === 40))) {        return false;      }      if (!swiper.allowSlidePrev && ((swiper.isHorizontal() && kc === 37) || (swiper.isVertical() && kc === 38))) {        return false;      }      if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {        return undefined;      }      if (doc.activeElement && doc.activeElement.nodeName && (doc.activeElement.nodeName.toLowerCase() === 'input' || doc.activeElement.nodeName.toLowerCase() === 'textarea')) {        return undefined;      }      if (swiper.params.keyboard.onlyInViewport && (kc === 37 || kc === 39 || kc === 38 || kc === 40)) {        var inView = false;        // Check that swiper should be inside of visible area of window        if (swiper.$el.parents(("." + (swiper.params.slideClass))).length > 0 && swiper.$el.parents(("." + (swiper.params.slideActiveClass))).length === 0) {          return undefined;        }        var windowWidth = win.innerWidth;        var windowHeight = win.innerHeight;        var swiperOffset = swiper.$el.offset();        if (rtl) { swiperOffset.left -= swiper.$el[0].scrollLeft; }        var swiperCoord = [          [swiperOffset.left, swiperOffset.top],          [swiperOffset.left + swiper.width, swiperOffset.top],          [swiperOffset.left, swiperOffset.top + swiper.height],          [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height] ];        for (var i = 0; i < swiperCoord.length; i += 1) {          var point = swiperCoord[i];          if (            point[0] >= 0 && point[0] <= windowWidth            && point[1] >= 0 && point[1] <= windowHeight          ) {            inView = true;          }        }        if (!inView) { return undefined; }      }      if (swiper.isHorizontal()) {        if (kc === 37 || kc === 39) {          if (e.preventDefault) { e.preventDefault(); }          else { e.returnValue = false; }        }        if ((kc === 39 && !rtl) || (kc === 37 && rtl)) { swiper.slideNext(); }        if ((kc === 37 && !rtl) || (kc === 39 && rtl)) { swiper.slidePrev(); }      } else {        if (kc === 38 || kc === 40) {          if (e.preventDefault) { e.preventDefault(); }          else { e.returnValue = false; }        }        if (kc === 40) { swiper.slideNext(); }        if (kc === 38) { swiper.slidePrev(); }      }      swiper.emit('keyPress', kc);      return undefined;    },    enable: function enable() {      var swiper = this;      if (swiper.keyboard.enabled) { return; }      $(doc).on('keydown', swiper.keyboard.handle);      swiper.keyboard.enabled = true;    },    disable: function disable() {      var swiper = this;      if (!swiper.keyboard.enabled) { return; }      $(doc).off('keydown', swiper.keyboard.handle);      swiper.keyboard.enabled = false;    },  };  var Keyboard$1 = {    name: 'keyboard',    params: {      keyboard: {        enabled: false,        onlyInViewport: true,      },    },    create: function create() {      var swiper = this;      Utils.extend(swiper, {        keyboard: {          enabled: false,          enable: Keyboard.enable.bind(swiper),          disable: Keyboard.disable.bind(swiper),          handle: Keyboard.handle.bind(swiper),        },      });    },    on: {      init: function init() {        var swiper = this;        if (swiper.params.keyboard.enabled) {          swiper.keyboard.enable();        }      },      destroy: function destroy() {        var swiper = this;        if (swiper.keyboard.enabled) {          swiper.keyboard.disable();        }      },    },  };  function isEventSupported() {    var eventName = 'onwheel';    var isSupported = eventName in doc;    if (!isSupported) {      var element = doc.createElement('div');      element.setAttribute(eventName, 'return;');      isSupported = typeof element[eventName] === 'function';    }    if (!isSupported      && doc.implementation      && doc.implementation.hasFeature      // always returns true in newer browsers as per the standard.      // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature      && doc.implementation.hasFeature('', '') !== true    ) {      // This is the only way to test support for the `wheel` event in IE9+.      isSupported = doc.implementation.hasFeature('Events.wheel', '3.0');    }    return isSupported;  }  var Mousewheel = {    lastScrollTime: Utils.now(),    event: (function getEvent() {      if (win.navigator.userAgent.indexOf('firefox') > -1) { return 'DOMMouseScroll'; }      return isEventSupported() ? 'wheel' : 'mousewheel';    }()),    normalize: function normalize(e) {      // Reasonable defaults      var PIXEL_STEP = 10;      var LINE_HEIGHT = 40;      var PAGE_HEIGHT = 800;      var sX = 0;      var sY = 0; // spinX, spinY      var pX = 0;      var pY = 0; // pixelX, pixelY      // Legacy      if ('detail' in e) {        sY = e.detail;      }      if ('wheelDelta' in e) {        sY = -e.wheelDelta / 120;      }      if ('wheelDeltaY' in e) {        sY = -e.wheelDeltaY / 120;      }      if ('wheelDeltaX' in e) {        sX = -e.wheelDeltaX / 120;      }      // side scrolling on FF with DOMMouseScroll      if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {        sX = sY;        sY = 0;      }      pX = sX * PIXEL_STEP;      pY = sY * PIXEL_STEP;      if ('deltaY' in e) {        pY = e.deltaY;      }      if ('deltaX' in e) {        pX = e.deltaX;      }      if ((pX || pY) && e.deltaMode) {        if (e.deltaMode === 1) { // delta in LINE units          pX *= LINE_HEIGHT;          pY *= LINE_HEIGHT;        } else { // delta in PAGE units          pX *= PAGE_HEIGHT;          pY *= PAGE_HEIGHT;        }      }      // Fall-back if spin cannot be determined      if (pX && !sX) {        sX = (pX < 1) ? -1 : 1;      }      if (pY && !sY) {        sY = (pY < 1) ? -1 : 1;      }      return {        spinX: sX,        spinY: sY,        pixelX: pX,        pixelY: pY,      };    },    handleMouseEnter: function handleMouseEnter() {      var swiper = this;      swiper.mouseEntered = true;    },    handleMouseLeave: function handleMouseLeave() {      var swiper = this;      swiper.mouseEntered = false;    },    handle: function handle(event) {      var e = event;      var swiper = this;      var params = swiper.params.mousewheel;      if (!swiper.mouseEntered && !params.releaseOnEdges) { return true; }      if (e.originalEvent) { e = e.originalEvent; } // jquery fix      var delta = 0;      var rtlFactor = swiper.rtlTranslate ? -1 : 1;      var data = Mousewheel.normalize(e);      if (params.forceToAxis) {        if (swiper.isHorizontal()) {          if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) { delta = data.pixelX * rtlFactor; }          else { return true; }        } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) { delta = data.pixelY; }        else { return true; }      } else {        delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;      }      if (delta === 0) { return true; }      if (params.invert) { delta = -delta; }      if (!swiper.params.freeMode) {        if (Utils.now() - swiper.mousewheel.lastScrollTime > 60) {          if (delta < 0) {            if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {              swiper.slideNext();              swiper.emit('scroll', e);            } else if (params.releaseOnEdges) { return true; }          } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {            swiper.slidePrev();            swiper.emit('scroll', e);          } else if (params.releaseOnEdges) { return true; }        }        swiper.mousewheel.lastScrollTime = (new win.Date()).getTime();      } else {        // Freemode or scrollContainer:        if (swiper.params.loop) {          swiper.loopFix();        }        var position = swiper.getTranslate() + (delta * params.sensitivity);        var wasBeginning = swiper.isBeginning;        var wasEnd = swiper.isEnd;        if (position >= swiper.minTranslate()) { position = swiper.minTranslate(); }        if (position <= swiper.maxTranslate()) { position = swiper.maxTranslate(); }        swiper.setTransition(0);        swiper.setTranslate(position);        swiper.updateProgress();        swiper.updateActiveIndex();        swiper.updateSlidesClasses();        if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {          swiper.updateSlidesClasses();        }        if (swiper.params.freeModeSticky) {          clearTimeout(swiper.mousewheel.timeout);          swiper.mousewheel.timeout = Utils.nextTick(function () {            swiper.slideToClosest();          }, 300);        }        // Emit event        swiper.emit('scroll', e);        // Stop autoplay        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) { swiper.autoplay.stop(); }        // Return page scroll on edge positions        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) { return true; }      }      if (e.preventDefault) { e.preventDefault(); }      else { e.returnValue = false; }      return false;    },    enable: function enable() {      var swiper = this;      if (!Mousewheel.event) { return false; }      if (swiper.mousewheel.enabled) { return false; }      var target = swiper.$el;      if (swiper.params.mousewheel.eventsTarged !== 'container') {        target = $(swiper.params.mousewheel.eventsTarged);      }      target.on('mouseenter', swiper.mousewheel.handleMouseEnter);      target.on('mouseleave', swiper.mousewheel.handleMouseLeave);      target.on(Mousewheel.event, swiper.mousewheel.handle);      swiper.mousewheel.enabled = true;      return true;    },    disable: function disable() {      var swiper = this;      if (!Mousewheel.event) { return false; }      if (!swiper.mousewheel.enabled) { return false; }      var target = swiper.$el;      if (swiper.params.mousewheel.eventsTarged !== 'container') {        target = $(swiper.params.mousewheel.eventsTarged);      }      target.off(Mousewheel.event, swiper.mousewheel.handle);      swiper.mousewheel.enabled = false;      return true;    },  };  var Mousewheel$1 = {    name: 'mousewheel',    params: {      mousewheel: {        enabled: false,        releaseOnEdges: false,        invert: false,        forceToAxis: false,        sensitivity: 1,        eventsTarged: 'container',      },    },    create: function create() {      var swiper = this;      Utils.extend(swiper, {        mousewheel: {          enabled: false,          enable: Mousewheel.enable.bind(swiper),          disable: Mousewheel.disable.bind(swiper),          handle: Mousewheel.handle.bind(swiper),          handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),          handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),          lastScrollTime: Utils.now(),        },      });    },    on: {      init: function init() {        var swiper = this;        if (swiper.params.mousewheel.enabled) { swiper.mousewheel.enable(); }      },      destroy: function destroy() {        var swiper = this;        if (swiper.mousewheel.enabled) { swiper.mousewheel.disable(); }      },    },  };  var Navigation = {    update: function update() {      // Update Navigation Buttons      var swiper = this;      var params = swiper.params.navigation;      if (swiper.params.loop) { return; }      var ref = swiper.navigation;      var $nextEl = ref.$nextEl;      var $prevEl = ref.$prevEl;      if ($prevEl && $prevEl.length > 0) {        if (swiper.isBeginning) {          $prevEl.addClass(params.disabledClass);        } else {          $prevEl.removeClass(params.disabledClass);        }        $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);      }      if ($nextEl && $nextEl.length > 0) {        if (swiper.isEnd) {          $nextEl.addClass(params.disabledClass);        } else {          $nextEl.removeClass(params.disabledClass);        }        $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);      }    },    onPrevClick: function onPrevClick(e) {      var swiper = this;      e.preventDefault();      if (swiper.isBeginning && !swiper.params.loop) { return; }      swiper.slidePrev();    },    onNextClick: function onNextClick(e) {      var swiper = this;      e.preventDefault();      if (swiper.isEnd && !swiper.params.loop) { return; }      swiper.slideNext();    },    init: function init() {      var swiper = this;      var params = swiper.params.navigation;      if (!(params.nextEl || params.prevEl)) { return; }      var $nextEl;      var $prevEl;      if (params.nextEl) {        $nextEl = $(params.nextEl);        if (          swiper.params.uniqueNavElements          && typeof params.nextEl === 'string'          && $nextEl.length > 1          && swiper.$el.find(params.nextEl).length === 1        ) {          $nextEl = swiper.$el.find(params.nextEl);        }      }      if (params.prevEl) {        $prevEl = $(params.prevEl);        if (          swiper.params.uniqueNavElements          && typeof params.prevEl === 'string'          && $prevEl.length > 1          && swiper.$el.find(params.prevEl).length === 1        ) {          $prevEl = swiper.$el.find(params.prevEl);        }      }      if ($nextEl && $nextEl.length > 0) {        $nextEl.on('click', swiper.navigation.onNextClick);      }      if ($prevEl && $prevEl.length > 0) {        $prevEl.on('click', swiper.navigation.onPrevClick);      }      Utils.extend(swiper.navigation, {        $nextEl: $nextEl,        nextEl: $nextEl && $nextEl[0],        $prevEl: $prevEl,        prevEl: $prevEl && $prevEl[0],      });    },    destroy: function destroy() {      var swiper = this;      var ref = swiper.navigation;      var $nextEl = ref.$nextEl;      var $prevEl = ref.$prevEl;      if ($nextEl && $nextEl.length) {        $nextEl.off('click', swiper.navigation.onNextClick);        $nextEl.removeClass(swiper.params.navigation.disabledClass);      }      if ($prevEl && $prevEl.length) {        $prevEl.off('click', swiper.navigation.onPrevClick);        $prevEl.removeClass(swiper.params.navigation.disabledClass);      }    },  };  var Navigation$1 = {    name: 'navigation',    params: {      navigation: {        nextEl: null,        prevEl: null,        hideOnClick: false,        disabledClass: 'swiper-button-disabled',        hiddenClass: 'swiper-button-hidden',        lockClass: 'swiper-button-lock',      },    },    create: function create() {      var swiper = this;      Utils.extend(swiper, {        navigation: {          init: Navigation.init.bind(swiper),          update: Navigation.update.bind(swiper),          destroy: Navigation.destroy.bind(swiper),          onNextClick: Navigation.onNextClick.bind(swiper),          onPrevClick: Navigation.onPrevClick.bind(swiper),        },      });    },    on: {      init: function init() {        var swiper = this;        swiper.navigation.init();        swiper.navigation.update();      },      toEdge: function toEdge() {        var swiper = this;        swiper.navigation.update();      },      fromEdge: function fromEdge() {        var swiper = this;        swiper.navigation.update();      },      destroy: function destroy() {        var swiper = this;        swiper.navigation.destroy();      },      click: function click(e) {        var swiper = this;        var ref = swiper.navigation;        var $nextEl = ref.$nextEl;        var $prevEl = ref.$prevEl;        if (          swiper.params.navigation.hideOnClick          && !$(e.target).is($prevEl)          && !$(e.target).is($nextEl)        ) {          if ($nextEl) { $nextEl.toggleClass(swiper.params.navigation.hiddenClass); }          if ($prevEl) { $prevEl.toggleClass(swiper.params.navigation.hiddenClass); }        }      },    },  };  var Pagination = {    update: function update() {      // Render || Update Pagination bullets/items      var swiper = this;      var rtl = swiper.rtl;      var params = swiper.params.pagination;      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }      var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;      var $el = swiper.pagination.$el;      // Current/Total      var current;      var total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;      if (swiper.params.loop) {        current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);        if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {          current -= (slidesLength - (swiper.loopedSlides * 2));        }        if (current > total - 1) { current -= total; }        if (current < 0 && swiper.params.paginationType !== 'bullets') { current = total + current; }      } else if (typeof swiper.snapIndex !== 'undefined') {        current = swiper.snapIndex;      } else {        current = swiper.activeIndex || 0;      }      // Types      if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {        var bullets = swiper.pagination.bullets;        var firstIndex;        var lastIndex;        var midIndex;        if (params.dynamicBullets) {          swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);          $el.css(swiper.isHorizontal() ? 'width' : 'height', ((swiper.pagination.bulletSize * (params.dynamicMainBullets + 4)) + "px"));          if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {            swiper.pagination.dynamicBulletIndex += (current - swiper.previousIndex);            if (swiper.pagination.dynamicBulletIndex > (params.dynamicMainBullets - 1)) {              swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;            } else if (swiper.pagination.dynamicBulletIndex < 0) {              swiper.pagination.dynamicBulletIndex = 0;            }          }          firstIndex = current - swiper.pagination.dynamicBulletIndex;          lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);          midIndex = (lastIndex + firstIndex) / 2;        }        bullets.removeClass(((params.bulletActiveClass) + " " + (params.bulletActiveClass) + "-next " + (params.bulletActiveClass) + "-next-next " + (params.bulletActiveClass) + "-prev " + (params.bulletActiveClass) + "-prev-prev " + (params.bulletActiveClass) + "-main"));        if ($el.length > 1) {          bullets.each(function (index, bullet) {            var $bullet = $(bullet);            var bulletIndex = $bullet.index();            if (bulletIndex === current) {              $bullet.addClass(params.bulletActiveClass);            }            if (params.dynamicBullets) {              if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {                $bullet.addClass(((params.bulletActiveClass) + "-main"));              }              if (bulletIndex === firstIndex) {                $bullet                  .prev()                  .addClass(((params.bulletActiveClass) + "-prev"))                  .prev()                  .addClass(((params.bulletActiveClass) + "-prev-prev"));              }              if (bulletIndex === lastIndex) {                $bullet                  .next()                  .addClass(((params.bulletActiveClass) + "-next"))                  .next()                  .addClass(((params.bulletActiveClass) + "-next-next"));              }            }          });        } else {          var $bullet = bullets.eq(current);          $bullet.addClass(params.bulletActiveClass);          if (params.dynamicBullets) {            var $firstDisplayedBullet = bullets.eq(firstIndex);            var $lastDisplayedBullet = bullets.eq(lastIndex);            for (var i = firstIndex; i <= lastIndex; i += 1) {              bullets.eq(i).addClass(((params.bulletActiveClass) + "-main"));            }            $firstDisplayedBullet              .prev()              .addClass(((params.bulletActiveClass) + "-prev"))              .prev()              .addClass(((params.bulletActiveClass) + "-prev-prev"));            $lastDisplayedBullet              .next()              .addClass(((params.bulletActiveClass) + "-next"))              .next()              .addClass(((params.bulletActiveClass) + "-next-next"));          }        }        if (params.dynamicBullets) {          var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);          var bulletsOffset = (((swiper.pagination.bulletSize * dynamicBulletsLength) - (swiper.pagination.bulletSize)) / 2) - (midIndex * swiper.pagination.bulletSize);          var offsetProp = rtl ? 'right' : 'left';          bullets.css(swiper.isHorizontal() ? offsetProp : 'top', (bulletsOffset + "px"));        }      }      if (params.type === 'fraction') {        $el.find(("." + (params.currentClass))).text(params.formatFractionCurrent(current + 1));        $el.find(("." + (params.totalClass))).text(params.formatFractionTotal(total));      }      if (params.type === 'progressbar') {        var progressbarDirection;        if (params.progressbarOpposite) {          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';        } else {          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';        }        var scale = (current + 1) / total;        var scaleX = 1;        var scaleY = 1;        if (progressbarDirection === 'horizontal') {          scaleX = scale;        } else {          scaleY = scale;        }        $el.find(("." + (params.progressbarFillClass))).transform(("translate3d(0,0,0) scaleX(" + scaleX + ") scaleY(" + scaleY + ")")).transition(swiper.params.speed);      }      if (params.type === 'custom' && params.renderCustom) {        $el.html(params.renderCustom(swiper, current + 1, total));        swiper.emit('paginationRender', swiper, $el[0]);      } else {        swiper.emit('paginationUpdate', swiper, $el[0]);      }      $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);    },    render: function render() {      // Render Container      var swiper = this;      var params = swiper.params.pagination;      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }      var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;      var $el = swiper.pagination.$el;      var paginationHTML = '';      if (params.type === 'bullets') {        var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;        for (var i = 0; i < numberOfBullets; i += 1) {          if (params.renderBullet) {            paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);          } else {            paginationHTML += "<" + (params.bulletElement) + " class=\"" + (params.bulletClass) + "\"></" + (params.bulletElement) + ">";          }        }        $el.html(paginationHTML);        swiper.pagination.bullets = $el.find(("." + (params.bulletClass)));      }      if (params.type === 'fraction') {        if (params.renderFraction) {          paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);        } else {          paginationHTML = "<span class=\"" + (params.currentClass) + "\"></span>"          + ' / '          + "<span class=\"" + (params.totalClass) + "\"></span>";        }        $el.html(paginationHTML);      }      if (params.type === 'progressbar') {        if (params.renderProgressbar) {          paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);        } else {          paginationHTML = "<span class=\"" + (params.progressbarFillClass) + "\"></span>";        }        $el.html(paginationHTML);      }      if (params.type !== 'custom') {        swiper.emit('paginationRender', swiper.pagination.$el[0]);      }    },    init: function init() {      var swiper = this;      var params = swiper.params.pagination;      if (!params.el) { return; }      var $el = $(params.el);      if ($el.length === 0) { return; }      if (        swiper.params.uniqueNavElements        && typeof params.el === 'string'        && $el.length > 1        && swiper.$el.find(params.el).length === 1      ) {        $el = swiper.$el.find(params.el);      }      if (params.type === 'bullets' && params.clickable) {        $el.addClass(params.clickableClass);      }      $el.addClass(params.modifierClass + params.type);      if (params.type === 'bullets' && params.dynamicBullets) {        $el.addClass(("" + (params.modifierClass) + (params.type) + "-dynamic"));        swiper.pagination.dynamicBulletIndex = 0;        if (params.dynamicMainBullets < 1) {          params.dynamicMainBullets = 1;        }      }      if (params.type === 'progressbar' && params.progressbarOpposite) {        $el.addClass(params.progressbarOppositeClass);      }      if (params.clickable) {        $el.on('click', ("." + (params.bulletClass)), function onClick(e) {          e.preventDefault();          var index = $(this).index() * swiper.params.slidesPerGroup;          if (swiper.params.loop) { index += swiper.loopedSlides; }          swiper.slideTo(index);        });      }      Utils.extend(swiper.pagination, {        $el: $el,        el: $el[0],      });    },    destroy: function destroy() {      var swiper = this;      var params = swiper.params.pagination;      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) { return; }      var $el = swiper.pagination.$el;      $el.removeClass(params.hiddenClass);      $el.removeClass(params.modifierClass + params.type);      if (swiper.pagination.bullets) { swiper.pagination.bullets.removeClass(params.bulletActiveClass); }      if (params.clickable) {        $el.off('click', ("." + (params.bulletClass)));      }    },  };  var Pagination$1 = {    name: 'pagination',    params: {      pagination: {        el: null,        bulletElement: 'span',        clickable: false,        hideOnClick: false,        renderBullet: null,        renderProgressbar: null,        renderFraction: null,        renderCustom: null,        progressbarOpposite: false,        type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'        dynamicBullets: false,        dynamicMainBullets: 1,        formatFractionCurrent: function (number) { return number; },        formatFractionTotal: function (number) { return number; },        bulletClass: 'swiper-pagination-bullet',        bulletActiveClass: 'swiper-pagination-bullet-active',        modifierClass: 'swiper-pagination-', // NEW        currentClass: 'swiper-pagination-current',        totalClass: 'swiper-pagination-total',        hiddenClass: 'swiper-pagination-hidden',        progressbarFillClass: 'swiper-pagination-progressbar-fill',        progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',        clickableClass: 'swiper-pagination-clickable', // NEW        lockClass: 'swiper-pagination-lock',      },    },    create: function create() {      var swiper = this;      Utils.extend(swiper, {        pagination: {          init: Pagination.init.bind(swiper),          render: Pagination.render.bind(swiper),          update: Pagination.update.bind(swiper),          destroy: Pagination.destroy.bind(swiper),          dynamicBulletIndex: 0,        },      });    },    on: {      init: function init() {        var swiper = this;        swiper.pagination.init();        swiper.pagination.render();        swiper.pagination.update();      },      activeIndexChange: function activeIndexChange() {        var swiper = this;        if (swiper.params.loop) {          swiper.pagination.update();        } else if (typeof swiper.snapIndex === 'undefined') {          swiper.pagination.update();        }      },      snapIndexChange: function snapIndexChange() {        var swiper = this;        if (!swiper.params.loop) {          swiper.pagination.update();        }      },      slidesLengthChange: function slidesLengthChange() {        var swiper = this;        if (swiper.params.loop) {          swiper.pagination.render();          swiper.pagination.update();        }      },      snapGridLengthChange: function snapGridLengthChange() {        var swiper = this;        if (!swiper.params.loop) {          swiper.pagination.render();          swiper.pagination.update();        }      },      destroy: function destroy() {        var swiper = this;        swiper.pagination.destroy();      },      click: function click(e) {        var swiper = this;        if (          swiper.params.pagination.el          && swiper.params.pagination.hideOnClick          && swiper.pagination.$el.length > 0          && !$(e.target).hasClass(swiper.params.pagination.bulletClass)        ) {          swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);        }      },    },  };  var Scrollbar = {    setTranslate: function setTranslate() {      var swiper = this;      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }      var scrollbar = swiper.scrollbar;      var rtl = swiper.rtlTranslate;      var progress = swiper.progress;      var dragSize = scrollbar.dragSize;      var trackSize = scrollbar.trackSize;      var $dragEl = scrollbar.$dragEl;      var $el = scrollbar.$el;      var params = swiper.params.scrollbar;      var newSize = dragSize;      var newPos = (trackSize - dragSize) * progress;      if (rtl) {        newPos = -newPos;        if (newPos > 0) {          newSize = dragSize - newPos;          newPos = 0;        } else if (-newPos + dragSize > trackSize) {          newSize = trackSize + newPos;        }      } else if (newPos < 0) {        newSize = dragSize + newPos;        newPos = 0;      } else if (newPos + dragSize > trackSize) {        newSize = trackSize - newPos;      }      if (swiper.isHorizontal()) {        if (Support.transforms3d) {          $dragEl.transform(("translate3d(" + newPos + "px, 0, 0)"));        } else {          $dragEl.transform(("translateX(" + newPos + "px)"));        }        $dragEl[0].style.width = newSize + "px";      } else {        if (Support.transforms3d) {          $dragEl.transform(("translate3d(0px, " + newPos + "px, 0)"));        } else {          $dragEl.transform(("translateY(" + newPos + "px)"));        }        $dragEl[0].style.height = newSize + "px";      }      if (params.hide) {        clearTimeout(swiper.scrollbar.timeout);        $el[0].style.opacity = 1;        swiper.scrollbar.timeout = setTimeout(function () {          $el[0].style.opacity = 0;          $el.transition(400);        }, 1000);      }    },    setTransition: function setTransition(duration) {      var swiper = this;      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }      swiper.scrollbar.$dragEl.transition(duration);    },    updateSize: function updateSize() {      var swiper = this;      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) { return; }      var scrollbar = swiper.scrollbar;      var $dragEl = scrollbar.$dragEl;      var $el = scrollbar.$el;      $dragEl[0].style.width = '';      $dragEl[0].style.height = '';      var trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;      var divider = swiper.size / swiper.virtualSize;      var moveDivider = divider * (trackSize / swiper.size);      var dragSize;      if (swiper.params.scrollbar.dragSize === 'auto') {        dragSize = trackSize * divider;      } else {        dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);      }      if (swiper.isHorizontal()) {        $dragEl[0].style.width = dragSize + "px";      } else {        $dragEl[0].style.height = dragSize + "px";      }      if (divider >= 1) {        $el[0].style.display = 'none';      } else {        $el[0].style.display = '';      }      if (swiper.params.scrollbarHide) {        $el[0].style.opacity = 0;      }      Utils.extend(scrollbar, {        trackSize: trackSize,        divider: divider,        moveDivider: moveDivider,        dragSize: dragSize,      });      scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);    },    setDragPosition: function setDragPosition(e) {      var swiper = this;      var scrollbar = swiper.scrollbar;      var rtl = swiper.rtlTranslate;      var $el = scrollbar.$el;      var dragSize = scrollbar.dragSize;      var trackSize = scrollbar.trackSize;      var pointerPosition;      if (swiper.isHorizontal()) {        pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageX : e.pageX || e.clientX);      } else {        pointerPosition = ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].pageY : e.pageY || e.clientY);      }      var positionRatio;      positionRatio = ((pointerPosition) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragSize / 2)) / (trackSize - dragSize);      positionRatio = Math.max(Math.min(positionRatio, 1), 0);      if (rtl) {        positionRatio = 1 - positionRatio;      }      var position = swiper.minTranslate() + ((swiper.maxTranslate() - swiper.minTranslate()) * positionRatio);      swiper.updateProgress(position);      swiper.setTranslate(position);      swiper.updateActiveIndex();      swiper.updateSlidesClasses();    },    onDragStart: function onDragStart(e) {      var swiper = this;      var params = swiper.params.scrollbar;      var scrollbar = swiper.scrollbar;      var $wrapperEl = swiper.$wrapperEl;      var $el = scrollbar.$el;      var $dragEl = scrollbar.$dragEl;      swiper.scrollbar.isTouched = true;      e.preventDefault();      e.stopPropagation();      $wrapperEl.transition(100);      $dragEl.transition(100);      scrollbar.setDragPosition(e);      clearTimeout(swiper.scrollbar.dragTimeout);      $el.transition(0);      if (params.hide) {        $el.css('opacity', 1);      }      swiper.emit('scrollbarDragStart', e);    },    onDragMove: function onDragMove(e) {      var swiper = this;      var scrollbar = swiper.scrollbar;      var $wrapperEl = swiper.$wrapperEl;      var $el = scrollbar.$el;      var $dragEl = scrollbar.$dragEl;      if (!swiper.scrollbar.isTouched) { return; }      if (e.preventDefault) { e.preventDefault(); }      else { e.returnValue = false; }      scrollbar.setDragPosition(e);      $wrapperEl.transition(0);      $el.transition(0);      $dragEl.transition(0);      swiper.emit('scrollbarDragMove', e);    },    onDragEnd: function onDragEnd(e) {      var swiper = this;      var params = swiper.params.scrollbar;      var scrollbar = swiper.scrollbar;      var $el = scrollbar.$el;      if (!swiper.scrollbar.isTouched) { return; }      swiper.scrollbar.isTouched = false;      if (params.hide) {        clearTimeout(swiper.scrollbar.dragTimeout);        swiper.scrollbar.dragTimeout = Utils.nextTick(function () {          $el.css('opacity', 0);          $el.transition(400);        }, 1000);      }      swiper.emit('scrollbarDragEnd', e);      if (params.snapOnRelease) {        swiper.slideToClosest();      }    },    enableDraggable: function enableDraggable() {      var swiper = this;      if (!swiper.params.scrollbar.el) { return; }      var scrollbar = swiper.scrollbar;      var touchEventsTouch = swiper.touchEventsTouch;      var touchEventsDesktop = swiper.touchEventsDesktop;      var params = swiper.params;      var $el = scrollbar.$el;      var target = $el[0];      var activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;      var passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;      if (!Support.touch) {        target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);        doc.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);        doc.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);      } else {        target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);        target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);        target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);      }    },    disableDraggable: function disableDraggable() {      var swiper = this;      if (!swiper.params.scrollbar.el) { return; }      var scrollbar = swiper.scrollbar;      var touchEventsTouch = swiper.touchEventsTouch;      var touchEventsDesktop = swiper.touchEventsDesktop;      var params = swiper.params;      var $el = scrollbar.$el;      var target = $el[0];      var activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;      var passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;      if (!Support.touch) {        target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);        doc.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);        doc.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);      } else {        target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);        target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);        target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);      }    },    init: function init() {      var swiper = this;      if (!swiper.params.scrollbar.el) { return; }      var scrollbar = swiper.scrollbar;      var $swiperEl = swiper.$el;      var params = swiper.params.scrollbar;      var $el = $(params.el);      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {        $el = $swiperEl.find(params.el);      }      var $dragEl = $el.find(("." + (swiper.params.scrollbar.dragClass)));      if ($dragEl.length === 0) {        $dragEl = $(("<div class=\"" + (swiper.params.scrollbar.dragClass) + "\"></div>"));        $el.append($dragEl);      }      Utils.extend(scrollbar, {        $el: $el,        el: $el[0],        $dragEl: $dragEl,        dragEl: $dragEl[0],      });      if (params.draggable) {        scrollbar.enableDraggable();      }    },    destroy: function destroy() {      var swiper = this;      swiper.scrollbar.disableDraggable();    },  };  var Scrollbar$1 = {    name: 'scrollbar',    params: {      scrollbar: {        el: null,        dragSize: 'auto',        hide: false,        draggable: false,        snapOnRelease: true,        lockClass: 'swiper-scrollbar-lock',        dragClass: 'swiper-scrollbar-drag',      },    },    create: function create() {      var swiper = this;      Utils.extend(swiper, {        scrollbar: {          init: Scrollbar.init.bind(swiper),          destroy: Scrollbar.destroy.bind(swiper),          updateSize: Scrollbar.updateSize.bind(swiper),          setTranslate: Scrollbar.setTranslate.bind(swiper),          setTransition: Scrollbar.setTransition.bind(swiper),          enableDraggable: Scrollbar.enableDraggable.bind(swiper),          disableDraggable: Scrollbar.disableDraggable.bind(swiper),          setDragPosition: Scrollbar.setDragPosition.bind(swiper),          onDragStart: Scrollbar.onDragStart.bind(swiper),          onDragMove: Scrollbar.onDragMove.bind(swiper),          onDragEnd: Scrollbar.onDragEnd.bind(swiper),          isTouched: false,          timeout: null,          dragTimeout: null,        },      });    },    on: {      init: function init() {        var swiper = this;        swiper.scrollbar.init();        swiper.scrollbar.updateSize();        swiper.scrollbar.setTranslate();      },      update: function update() {        var swiper = this;        swiper.scrollbar.updateSize();      },      resize: function resize() {        var swiper = this;        swiper.scrollbar.updateSize();      },      observerUpdate: function observerUpdate() {        var swiper = this;        swiper.scrollbar.updateSize();      },      setTranslate: function setTranslate() {        var swiper = this;        swiper.scrollbar.setTranslate();      },      setTransition: function setTransition(duration) {        var swiper = this;        swiper.scrollbar.setTransition(duration);      },      destroy: function destroy() {        var swiper = this;        swiper.scrollbar.destroy();      },    },  };  var Parallax = {    setTransform: function setTransform(el, progress) {      var swiper = this;      var rtl = swiper.rtl;      var $el = $(el);      var rtlFactor = rtl ? -1 : 1;      var p = $el.attr('data-swiper-parallax') || '0';      var x = $el.attr('data-swiper-parallax-x');      var y = $el.attr('data-swiper-parallax-y');      var scale = $el.attr('data-swiper-parallax-scale');      var opacity = $el.attr('data-swiper-parallax-opacity');      if (x || y) {        x = x || '0';        y = y || '0';      } else if (swiper.isHorizontal()) {        x = p;        y = '0';      } else {        y = p;        x = '0';      }      if ((x).indexOf('%') >= 0) {        x = (parseInt(x, 10) * progress * rtlFactor) + "%";      } else {        x = (x * progress * rtlFactor) + "px";      }      if ((y).indexOf('%') >= 0) {        y = (parseInt(y, 10) * progress) + "%";      } else {        y = (y * progress) + "px";      }      if (typeof opacity !== 'undefined' && opacity !== null) {        var currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));        $el[0].style.opacity = currentOpacity;      }      if (typeof scale === 'undefined' || scale === null) {        $el.transform(("translate3d(" + x + ", " + y + ", 0px)"));      } else {        var currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));        $el.transform(("translate3d(" + x + ", " + y + ", 0px) scale(" + currentScale + ")"));      }    },    setTranslate: function setTranslate() {      var swiper = this;      var $el = swiper.$el;      var slides = swiper.slides;      var progress = swiper.progress;      var snapGrid = swiper.snapGrid;      $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')        .each(function (index, el) {          swiper.parallax.setTransform(el, progress);        });      slides.each(function (slideIndex, slideEl) {        var slideProgress = slideEl.progress;        if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {          slideProgress += Math.ceil(slideIndex / 2) - (progress * (snapGrid.length - 1));        }        slideProgress = Math.min(Math.max(slideProgress, -1), 1);        $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')          .each(function (index, el) {            swiper.parallax.setTransform(el, slideProgress);          });      });    },    setTransition: function setTransition(duration) {      if ( duration === void 0 ) duration = this.params.speed;      var swiper = this;      var $el = swiper.$el;      $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]')        .each(function (index, parallaxEl) {          var $parallaxEl = $(parallaxEl);          var parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;          if (duration === 0) { parallaxDuration = 0; }          $parallaxEl.transition(parallaxDuration);        });    },  };  var Parallax$1 = {    name: 'parallax',    params: {      parallax: {        enabled: false,      },    },    create: function create() {      var swiper = this;      Utils.extend(swiper, {        parallax: {          setTransform: Parallax.setTransform.bind(swiper),          setTranslate: Parallax.setTranslate.bind(swiper),          setTransition: Parallax.setTransition.bind(swiper),        },      });    },    on: {      beforeInit: function beforeInit() {        var swiper = this;        if (!swiper.params.parallax.enabled) { return; }        swiper.params.watchSlidesProgress = true;        swiper.originalParams.watchSlidesProgress = true;      },      init: function init() {        var swiper = this;        if (!swiper.params.parallax) { return; }        swiper.parallax.setTranslate();      },      setTranslate: function setTranslate() {        var swiper = this;        if (!swiper.params.parallax) { return; }        swiper.parallax.setTranslate();      },      setTransition: function setTransition(duration) {        var swiper = this;        if (!swiper.params.parallax) { return; }        swiper.parallax.setTransition(duration);      },    },  };  var Zoom = {    // Calc Scale From Multi-touches    getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {      if (e.targetTouches.length < 2) { return 1; }      var x1 = e.targetTouches[0].pageX;      var y1 = e.targetTouches[0].pageY;      var x2 = e.targetTouches[1].pageX;      var y2 = e.targetTouches[1].pageY;      var distance = Math.sqrt((Math.pow( (x2 - x1), 2 )) + (Math.pow( (y2 - y1), 2 )));      return distance;    },    // Events    onGestureStart: function onGestureStart(e) {      var swiper = this;      var params = swiper.params.zoom;      var zoom = swiper.zoom;      var gesture = zoom.gesture;      zoom.fakeGestureTouched = false;      zoom.fakeGestureMoved = false;      if (!Support.gestures) {        if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {          return;        }        zoom.fakeGestureTouched = true;        gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);      }      if (!gesture.$slideEl || !gesture.$slideEl.length) {        gesture.$slideEl = $(e.target).closest('.swiper-slide');        if (gesture.$slideEl.length === 0) { gesture.$slideEl = swiper.slides.eq(swiper.activeIndex); }        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');        gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));        gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;        if (gesture.$imageWrapEl.length === 0) {          gesture.$imageEl = undefined;          return;        }      }      gesture.$imageEl.transition(0);      swiper.zoom.isScaling = true;    },    onGestureChange: function onGestureChange(e) {      var swiper = this;      var params = swiper.params.zoom;      var zoom = swiper.zoom;      var gesture = zoom.gesture;      if (!Support.gestures) {        if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {          return;        }        zoom.fakeGestureMoved = true;        gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);      }      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }      if (Support.gestures) {        swiper.zoom.scale = e.scale * zoom.currentScale;      } else {        zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;      }      if (zoom.scale > gesture.maxRatio) {        zoom.scale = (gesture.maxRatio - 1) + (Math.pow( ((zoom.scale - gesture.maxRatio) + 1), 0.5 ));      }      if (zoom.scale < params.minRatio) {        zoom.scale = (params.minRatio + 1) - (Math.pow( ((params.minRatio - zoom.scale) + 1), 0.5 ));      }      gesture.$imageEl.transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));    },    onGestureEnd: function onGestureEnd(e) {      var swiper = this;      var params = swiper.params.zoom;      var zoom = swiper.zoom;      var gesture = zoom.gesture;      if (!Support.gestures) {        if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {          return;        }        if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android)) {          return;        }        zoom.fakeGestureTouched = false;        zoom.fakeGestureMoved = false;      }      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }      zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);      gesture.$imageEl.transition(swiper.params.speed).transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));      zoom.currentScale = zoom.scale;      zoom.isScaling = false;      if (zoom.scale === 1) { gesture.$slideEl = undefined; }    },    onTouchStart: function onTouchStart(e) {      var swiper = this;      var zoom = swiper.zoom;      var gesture = zoom.gesture;      var image = zoom.image;      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }      if (image.isTouched) { return; }      if (Device.android) { e.preventDefault(); }      image.isTouched = true;      image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;      image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;    },    onTouchMove: function onTouchMove(e) {      var swiper = this;      var zoom = swiper.zoom;      var gesture = zoom.gesture;      var image = zoom.image;      var velocity = zoom.velocity;      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }      swiper.allowClick = false;      if (!image.isTouched || !gesture.$slideEl) { return; }      if (!image.isMoved) {        image.width = gesture.$imageEl[0].offsetWidth;        image.height = gesture.$imageEl[0].offsetHeight;        image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;        image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;        gesture.slideWidth = gesture.$slideEl[0].offsetWidth;        gesture.slideHeight = gesture.$slideEl[0].offsetHeight;        gesture.$imageWrapEl.transition(0);        if (swiper.rtl) {          image.startX = -image.startX;          image.startY = -image.startY;        }      }      // Define if we need image drag      var scaledWidth = image.width * zoom.scale;      var scaledHeight = image.height * zoom.scale;      if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) { return; }      image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);      image.maxX = -image.minX;      image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);      image.maxY = -image.minY;      image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;      image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;      if (!image.isMoved && !zoom.isScaling) {        if (          swiper.isHorizontal()          && (            (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x)            || (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)          )        ) {          image.isTouched = false;          return;        } if (          !swiper.isHorizontal()          && (            (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y)            || (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)          )        ) {          image.isTouched = false;          return;        }      }      e.preventDefault();      e.stopPropagation();      image.isMoved = true;      image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;      image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;      if (image.currentX < image.minX) {        image.currentX = (image.minX + 1) - (Math.pow( ((image.minX - image.currentX) + 1), 0.8 ));      }      if (image.currentX > image.maxX) {        image.currentX = (image.maxX - 1) + (Math.pow( ((image.currentX - image.maxX) + 1), 0.8 ));      }      if (image.currentY < image.minY) {        image.currentY = (image.minY + 1) - (Math.pow( ((image.minY - image.currentY) + 1), 0.8 ));      }      if (image.currentY > image.maxY) {        image.currentY = (image.maxY - 1) + (Math.pow( ((image.currentY - image.maxY) + 1), 0.8 ));      }      // Velocity      if (!velocity.prevPositionX) { velocity.prevPositionX = image.touchesCurrent.x; }      if (!velocity.prevPositionY) { velocity.prevPositionY = image.touchesCurrent.y; }      if (!velocity.prevTime) { velocity.prevTime = Date.now(); }      velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;      velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;      if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) { velocity.x = 0; }      if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) { velocity.y = 0; }      velocity.prevPositionX = image.touchesCurrent.x;      velocity.prevPositionY = image.touchesCurrent.y;      velocity.prevTime = Date.now();      gesture.$imageWrapEl.transform(("translate3d(" + (image.currentX) + "px, " + (image.currentY) + "px,0)"));    },    onTouchEnd: function onTouchEnd() {      var swiper = this;      var zoom = swiper.zoom;      var gesture = zoom.gesture;      var image = zoom.image;      var velocity = zoom.velocity;      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }      if (!image.isTouched || !image.isMoved) {        image.isTouched = false;        image.isMoved = false;        return;      }      image.isTouched = false;      image.isMoved = false;      var momentumDurationX = 300;      var momentumDurationY = 300;      var momentumDistanceX = velocity.x * momentumDurationX;      var newPositionX = image.currentX + momentumDistanceX;      var momentumDistanceY = velocity.y * momentumDurationY;      var newPositionY = image.currentY + momentumDistanceY;      // Fix duration      if (velocity.x !== 0) { momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x); }      if (velocity.y !== 0) { momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y); }      var momentumDuration = Math.max(momentumDurationX, momentumDurationY);      image.currentX = newPositionX;      image.currentY = newPositionY;      // Define if we need image drag      var scaledWidth = image.width * zoom.scale;      var scaledHeight = image.height * zoom.scale;      image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);      image.maxX = -image.minX;      image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);      image.maxY = -image.minY;      image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);      image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);      gesture.$imageWrapEl.transition(momentumDuration).transform(("translate3d(" + (image.currentX) + "px, " + (image.currentY) + "px,0)"));    },    onTransitionEnd: function onTransitionEnd() {      var swiper = this;      var zoom = swiper.zoom;      var gesture = zoom.gesture;      if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {        gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');        gesture.$imageWrapEl.transform('translate3d(0,0,0)');        gesture.$slideEl = undefined;        gesture.$imageEl = undefined;        gesture.$imageWrapEl = undefined;        zoom.scale = 1;        zoom.currentScale = 1;      }    },    // Toggle Zoom    toggle: function toggle(e) {      var swiper = this;      var zoom = swiper.zoom;      if (zoom.scale && zoom.scale !== 1) {        // Zoom Out        zoom.out();      } else {        // Zoom In        zoom.in(e);      }    },    in: function in$1(e) {      var swiper = this;      var zoom = swiper.zoom;      var params = swiper.params.zoom;      var gesture = zoom.gesture;      var image = zoom.image;      if (!gesture.$slideEl) {        gesture.$slideEl = swiper.clickedSlide ? $(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');        gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));      }      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }      gesture.$slideEl.addClass(("" + (params.zoomedSlideClass)));      var touchX;      var touchY;      var offsetX;      var offsetY;      var diffX;      var diffY;      var translateX;      var translateY;      var imageWidth;      var imageHeight;      var scaledWidth;      var scaledHeight;      var translateMinX;      var translateMinY;      var translateMaxX;      var translateMaxY;      var slideWidth;      var slideHeight;      if (typeof image.touchesStart.x === 'undefined' && e) {        touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;        touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;      } else {        touchX = image.touchesStart.x;        touchY = image.touchesStart.y;      }      zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;      zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;      if (e) {        slideWidth = gesture.$slideEl[0].offsetWidth;        slideHeight = gesture.$slideEl[0].offsetHeight;        offsetX = gesture.$slideEl.offset().left;        offsetY = gesture.$slideEl.offset().top;        diffX = (offsetX + (slideWidth / 2)) - touchX;        diffY = (offsetY + (slideHeight / 2)) - touchY;        imageWidth = gesture.$imageEl[0].offsetWidth;        imageHeight = gesture.$imageEl[0].offsetHeight;        scaledWidth = imageWidth * zoom.scale;        scaledHeight = imageHeight * zoom.scale;        translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);        translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);        translateMaxX = -translateMinX;        translateMaxY = -translateMinY;        translateX = diffX * zoom.scale;        translateY = diffY * zoom.scale;        if (translateX < translateMinX) {          translateX = translateMinX;        }        if (translateX > translateMaxX) {          translateX = translateMaxX;        }        if (translateY < translateMinY) {          translateY = translateMinY;        }        if (translateY > translateMaxY) {          translateY = translateMaxY;        }      } else {        translateX = 0;        translateY = 0;      }      gesture.$imageWrapEl.transition(300).transform(("translate3d(" + translateX + "px, " + translateY + "px,0)"));      gesture.$imageEl.transition(300).transform(("translate3d(0,0,0) scale(" + (zoom.scale) + ")"));    },    out: function out() {      var swiper = this;      var zoom = swiper.zoom;      var params = swiper.params.zoom;      var gesture = zoom.gesture;      if (!gesture.$slideEl) {        gesture.$slideEl = swiper.clickedSlide ? $(swiper.clickedSlide) : swiper.slides.eq(swiper.activeIndex);        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas');        gesture.$imageWrapEl = gesture.$imageEl.parent(("." + (params.containerClass)));      }      if (!gesture.$imageEl || gesture.$imageEl.length === 0) { return; }      zoom.scale = 1;      zoom.currentScale = 1;      gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');      gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');      gesture.$slideEl.removeClass(("" + (params.zoomedSlideClass)));      gesture.$slideEl = undefined;    },    // Attach/Detach Events    enable: function enable() {      var swiper = this;      var zoom = swiper.zoom;      if (zoom.enabled) { return; }      zoom.enabled = true;      var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;      // Scale image      if (Support.gestures) {        swiper.$wrapperEl.on('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);        swiper.$wrapperEl.on('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);        swiper.$wrapperEl.on('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);      } else if (swiper.touchEvents.start === 'touchstart') {        swiper.$wrapperEl.on(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);        swiper.$wrapperEl.on(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);        swiper.$wrapperEl.on(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);      }      // Move image      swiper.$wrapperEl.on(swiper.touchEvents.move, ("." + (swiper.params.zoom.containerClass)), zoom.onTouchMove);    },    disable: function disable() {      var swiper = this;      var zoom = swiper.zoom;      if (!zoom.enabled) { return; }      swiper.zoom.enabled = false;      var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;      // Scale image      if (Support.gestures) {        swiper.$wrapperEl.off('gesturestart', '.swiper-slide', zoom.onGestureStart, passiveListener);        swiper.$wrapperEl.off('gesturechange', '.swiper-slide', zoom.onGestureChange, passiveListener);        swiper.$wrapperEl.off('gestureend', '.swiper-slide', zoom.onGestureEnd, passiveListener);      } else if (swiper.touchEvents.start === 'touchstart') {        swiper.$wrapperEl.off(swiper.touchEvents.start, '.swiper-slide', zoom.onGestureStart, passiveListener);        swiper.$wrapperEl.off(swiper.touchEvents.move, '.swiper-slide', zoom.onGestureChange, passiveListener);        swiper.$wrapperEl.off(swiper.touchEvents.end, '.swiper-slide', zoom.onGestureEnd, passiveListener);      }      // Move image      swiper.$wrapperEl.off(swiper.touchEvents.move, ("." + (swiper.params.zoom.containerClass)), zoom.onTouchMove);    },  };  var Zoom$1 = {    name: 'zoom',    params: {      zoom: {        enabled: false,        maxRatio: 3,        minRatio: 1,        toggle: true,        containerClass: 'swiper-zoom-container',        zoomedSlideClass: 'swiper-slide-zoomed',      },    },    create: function create() {      var swiper = this;      var zoom = {        enabled: false,        scale: 1,        currentScale: 1,        isScaling: false,        gesture: {          $slideEl: undefined,          slideWidth: undefined,          slideHeight: undefined,          $imageEl: undefined,          $imageWrapEl: undefined,          maxRatio: 3,        },        image: {          isTouched: undefined,          isMoved: undefined,          currentX: undefined,          currentY: undefined,          minX: undefined,          minY: undefined,          maxX: undefined,          maxY: undefined,          width: undefined,          height: undefined,          startX: undefined,          startY: undefined,          touchesStart: {},          touchesCurrent: {},        },        velocity: {          x: undefined,          y: undefined,          prevPositionX: undefined,          prevPositionY: undefined,          prevTime: undefined,        },      };      ('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach(function (methodName) {        zoom[methodName] = Zoom[methodName].bind(swiper);      });      Utils.extend(swiper, {        zoom: zoom,      });    },    on: {      init: function init() {        var swiper = this;        if (swiper.params.zoom.enabled) {          swiper.zoom.enable();        }      },      destroy: function destroy() {        var swiper = this;        swiper.zoom.disable();      },      touchStart: function touchStart(e) {        var swiper = this;        if (!swiper.zoom.enabled) { return; }        swiper.zoom.onTouchStart(e);      },      touchEnd: function touchEnd(e) {        var swiper = this;        if (!swiper.zoom.enabled) { return; }        swiper.zoom.onTouchEnd(e);      },      doubleTap: function doubleTap(e) {        var swiper = this;        if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {          swiper.zoom.toggle(e);        }      },      transitionEnd: function transitionEnd() {        var swiper = this;        if (swiper.zoom.enabled && swiper.params.zoom.enabled) {          swiper.zoom.onTransitionEnd();        }      },    },  };  var Lazy = {    loadInSlide: function loadInSlide(index, loadInDuplicate) {      if ( loadInDuplicate === void 0 ) loadInDuplicate = true;      var swiper = this;      var params = swiper.params.lazy;      if (typeof index === 'undefined') { return; }      if (swiper.slides.length === 0) { return; }      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;      var $slideEl = isVirtual        ? swiper.$wrapperEl.children(("." + (swiper.params.slideClass) + "[data-swiper-slide-index=\"" + index + "\"]"))        : swiper.slides.eq(index);      var $images = $slideEl.find(("." + (params.elementClass) + ":not(." + (params.loadedClass) + "):not(." + (params.loadingClass) + ")"));      if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {        $images = $images.add($slideEl[0]);      }      if ($images.length === 0) { return; }      $images.each(function (imageIndex, imageEl) {        var $imageEl = $(imageEl);        $imageEl.addClass(params.loadingClass);        var background = $imageEl.attr('data-background');        var src = $imageEl.attr('data-src');        var srcset = $imageEl.attr('data-srcset');        var sizes = $imageEl.attr('data-sizes');        swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, function () {          if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params) || swiper.destroyed) { return; }          if (background) {            $imageEl.css('background-image', ("url(\"" + background + "\")"));            $imageEl.removeAttr('data-background');          } else {            if (srcset) {              $imageEl.attr('srcset', srcset);              $imageEl.removeAttr('data-srcset');            }            if (sizes) {              $imageEl.attr('sizes', sizes);              $imageEl.removeAttr('data-sizes');            }            if (src) {              $imageEl.attr('src', src);              $imageEl.removeAttr('data-src');            }          }          $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);          $slideEl.find(("." + (params.preloaderClass))).remove();          if (swiper.params.loop && loadInDuplicate) {            var slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');            if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {              var originalSlide = swiper.$wrapperEl.children(("[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]:not(." + (swiper.params.slideDuplicateClass) + ")"));              swiper.lazy.loadInSlide(originalSlide.index(), false);            } else {              var duplicatedSlide = swiper.$wrapperEl.children(("." + (swiper.params.slideDuplicateClass) + "[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]"));              swiper.lazy.loadInSlide(duplicatedSlide.index(), false);            }          }          swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);        });        swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);      });    },    load: function load() {      var swiper = this;      var $wrapperEl = swiper.$wrapperEl;      var swiperParams = swiper.params;      var slides = swiper.slides;      var activeIndex = swiper.activeIndex;      var isVirtual = swiper.virtual && swiperParams.virtual.enabled;      var params = swiperParams.lazy;      var slidesPerView = swiperParams.slidesPerView;      if (slidesPerView === 'auto') {        slidesPerView = 0;      }      function slideExist(index) {        if (isVirtual) {          if ($wrapperEl.children(("." + (swiperParams.slideClass) + "[data-swiper-slide-index=\"" + index + "\"]")).length) {            return true;          }        } else if (slides[index]) { return true; }        return false;      }      function slideIndex(slideEl) {        if (isVirtual) {          return $(slideEl).attr('data-swiper-slide-index');        }        return $(slideEl).index();      }      if (!swiper.lazy.initialImageLoaded) { swiper.lazy.initialImageLoaded = true; }      if (swiper.params.watchSlidesVisibility) {        $wrapperEl.children(("." + (swiperParams.slideVisibleClass))).each(function (elIndex, slideEl) {          var index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();          swiper.lazy.loadInSlide(index);        });      } else if (slidesPerView > 1) {        for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) {          if (slideExist(i)) { swiper.lazy.loadInSlide(i); }        }      } else {        swiper.lazy.loadInSlide(activeIndex);      }      if (params.loadPrevNext) {        if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {          var amount = params.loadPrevNextAmount;          var spv = slidesPerView;          var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);          var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);          // Next Slides          for (var i$1 = activeIndex + slidesPerView; i$1 < maxIndex; i$1 += 1) {            if (slideExist(i$1)) { swiper.lazy.loadInSlide(i$1); }          }          // Prev Slides          for (var i$2 = minIndex; i$2 < activeIndex; i$2 += 1) {            if (slideExist(i$2)) { swiper.lazy.loadInSlide(i$2); }          }        } else {          var nextSlide = $wrapperEl.children(("." + (swiperParams.slideNextClass)));          if (nextSlide.length > 0) { swiper.lazy.loadInSlide(slideIndex(nextSlide)); }          var prevSlide = $wrapperEl.children(("." + (swiperParams.slidePrevClass)));          if (prevSlide.length > 0) { swiper.lazy.loadInSlide(slideIndex(prevSlide)); }        }      }    },  };  var Lazy$1 = {    name: 'lazy',    params: {      lazy: {        enabled: false,        loadPrevNext: false,        loadPrevNextAmount: 1,        loadOnTransitionStart: false,        elementClass: 'swiper-lazy',        loadingClass: 'swiper-lazy-loading',        loadedClass: 'swiper-lazy-loaded',        preloaderClass: 'swiper-lazy-preloader',      },    },    create: function create() {      var swiper = this;      Utils.extend(swiper, {        lazy: {          initialImageLoaded: false,          load: Lazy.load.bind(swiper),          loadInSlide: Lazy.loadInSlide.bind(swiper),        },      });    },    on: {      beforeInit: function beforeInit() {        var swiper = this;        if (swiper.params.lazy.enabled && swiper.params.preloadImages) {          swiper.params.preloadImages = false;        }      },      init: function init() {        var swiper = this;        if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {          swiper.lazy.load();        }      },      scroll: function scroll() {        var swiper = this;        if (swiper.params.freeMode && !swiper.params.freeModeSticky) {          swiper.lazy.load();        }      },      resize: function resize() {        var swiper = this;        if (swiper.params.lazy.enabled) {          swiper.lazy.load();        }      },      scrollbarDragMove: function scrollbarDragMove() {        var swiper = this;        if (swiper.params.lazy.enabled) {          swiper.lazy.load();        }      },      transitionStart: function transitionStart() {        var swiper = this;        if (swiper.params.lazy.enabled) {          if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {            swiper.lazy.load();          }        }      },      transitionEnd: function transitionEnd() {        var swiper = this;        if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {          swiper.lazy.load();        }      },    },  };  /* eslint no-bitwise: ["error", { "allow": [">>"] }] */  var Controller = {    LinearSpline: function LinearSpline(x, y) {      var binarySearch = (function search() {        var maxIndex;        var minIndex;        var guess;        return function (array, val) {          minIndex = -1;          maxIndex = array.length;          while (maxIndex - minIndex > 1) {            guess = maxIndex + minIndex >> 1;            if (array[guess] <= val) {              minIndex = guess;            } else {              maxIndex = guess;            }          }          return maxIndex;        };      }());      this.x = x;      this.y = y;      this.lastIndex = x.length - 1;      // Given an x value (x2), return the expected y2 value:      // (x1,y1) is the known point before given value,      // (x3,y3) is the known point after given value.      var i1;      var i3;      this.interpolate = function interpolate(x2) {        if (!x2) { return 0; }        // Get the indexes of x1 and x3 (the array indexes before and after given x2):        i3 = binarySearch(this.x, x2);        i1 = i3 - 1;        // We have our indexes i1 & i3, so we can calculate already:        // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1        return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];      };      return this;    },    // xxx: for now i will just save one spline function to to    getInterpolateFunction: function getInterpolateFunction(c) {      var swiper = this;      if (!swiper.controller.spline) {        swiper.controller.spline = swiper.params.loop          ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid)          : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);      }    },    setTranslate: function setTranslate(setTranslate$1, byController) {      var swiper = this;      var controlled = swiper.controller.control;      var multiplier;      var controlledTranslate;      function setControlledTranslate(c) {        // this will create an Interpolate function based on the snapGrids        // x is the Grid of the scrolled scroller and y will be the controlled scroller        // it makes sense to create this only once and recall it for the interpolation        // the function does a lot of value caching for performance        var translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;        if (swiper.params.controller.by === 'slide') {          swiper.controller.getInterpolateFunction(c);          // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid          // but it did not work out          controlledTranslate = -swiper.controller.spline.interpolate(-translate);        }        if (!controlledTranslate || swiper.params.controller.by === 'container') {          multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());          controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();        }        if (swiper.params.controller.inverse) {          controlledTranslate = c.maxTranslate() - controlledTranslate;        }        c.updateProgress(controlledTranslate);        c.setTranslate(controlledTranslate, swiper);        c.updateActiveIndex();        c.updateSlidesClasses();      }      if (Array.isArray(controlled)) {        for (var i = 0; i < controlled.length; i += 1) {          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {            setControlledTranslate(controlled[i]);          }        }      } else if (controlled instanceof Swiper && byController !== controlled) {        setControlledTranslate(controlled);      }    },    setTransition: function setTransition(duration, byController) {      var swiper = this;      var controlled = swiper.controller.control;      var i;      function setControlledTransition(c) {        c.setTransition(duration, swiper);        if (duration !== 0) {          c.transitionStart();          if (c.params.autoHeight) {            Utils.nextTick(function () {              c.updateAutoHeight();            });          }          c.$wrapperEl.transitionEnd(function () {            if (!controlled) { return; }            if (c.params.loop && swiper.params.controller.by === 'slide') {              c.loopFix();            }            c.transitionEnd();          });        }      }      if (Array.isArray(controlled)) {        for (i = 0; i < controlled.length; i += 1) {          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {            setControlledTransition(controlled[i]);          }        }      } else if (controlled instanceof Swiper && byController !== controlled) {        setControlledTransition(controlled);      }    },  };  var Controller$1 = {    name: 'controller',    params: {      controller: {        control: undefined,        inverse: false,        by: 'slide', // or 'container'      },    },    create: function create() {      var swiper = this;      Utils.extend(swiper, {        controller: {          control: swiper.params.controller.control,          getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),          setTranslate: Controller.setTranslate.bind(swiper),          setTransition: Controller.setTransition.bind(swiper),        },      });    },    on: {      update: function update() {        var swiper = this;        if (!swiper.controller.control) { return; }        if (swiper.controller.spline) {          swiper.controller.spline = undefined;          delete swiper.controller.spline;        }      },      resize: function resize() {        var swiper = this;        if (!swiper.controller.control) { return; }        if (swiper.controller.spline) {          swiper.controller.spline = undefined;          delete swiper.controller.spline;        }      },      observerUpdate: function observerUpdate() {        var swiper = this;        if (!swiper.controller.control) { return; }        if (swiper.controller.spline) {          swiper.controller.spline = undefined;          delete swiper.controller.spline;        }      },      setTranslate: function setTranslate(translate, byController) {        var swiper = this;        if (!swiper.controller.control) { return; }        swiper.controller.setTranslate(translate, byController);      },      setTransition: function setTransition(duration, byController) {        var swiper = this;        if (!swiper.controller.control) { return; }        swiper.controller.setTransition(duration, byController);      },    },  };  var a11y = {    makeElFocusable: function makeElFocusable($el) {      $el.attr('tabIndex', '0');      return $el;    },    addElRole: function addElRole($el, role) {      $el.attr('role', role);      return $el;    },    addElLabel: function addElLabel($el, label) {      $el.attr('aria-label', label);      return $el;    },    disableEl: function disableEl($el) {      $el.attr('aria-disabled', true);      return $el;    },    enableEl: function enableEl($el) {      $el.attr('aria-disabled', false);      return $el;    },    onEnterKey: function onEnterKey(e) {      var swiper = this;      var params = swiper.params.a11y;      if (e.keyCode !== 13) { return; }      var $targetEl = $(e.target);      if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {        if (!(swiper.isEnd && !swiper.params.loop)) {          swiper.slideNext();        }        if (swiper.isEnd) {          swiper.a11y.notify(params.lastSlideMessage);        } else {          swiper.a11y.notify(params.nextSlideMessage);        }      }      if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {        if (!(swiper.isBeginning && !swiper.params.loop)) {          swiper.slidePrev();        }        if (swiper.isBeginning) {          swiper.a11y.notify(params.firstSlideMessage);        } else {          swiper.a11y.notify(params.prevSlideMessage);        }      }      if (swiper.pagination && $targetEl.is(("." + (swiper.params.pagination.bulletClass)))) {        $targetEl[0].click();      }    },    notify: function notify(message) {      var swiper = this;      var notification = swiper.a11y.liveRegion;      if (notification.length === 0) { return; }      notification.html('');      notification.html(message);    },    updateNavigation: function updateNavigation() {      var swiper = this;      if (swiper.params.loop) { return; }      var ref = swiper.navigation;      var $nextEl = ref.$nextEl;      var $prevEl = ref.$prevEl;      if ($prevEl && $prevEl.length > 0) {        if (swiper.isBeginning) {          swiper.a11y.disableEl($prevEl);        } else {          swiper.a11y.enableEl($prevEl);        }      }      if ($nextEl && $nextEl.length > 0) {        if (swiper.isEnd) {          swiper.a11y.disableEl($nextEl);        } else {          swiper.a11y.enableEl($nextEl);        }      }    },    updatePagination: function updatePagination() {      var swiper = this;      var params = swiper.params.a11y;      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {        swiper.pagination.bullets.each(function (bulletIndex, bulletEl) {          var $bulletEl = $(bulletEl);          swiper.a11y.makeElFocusable($bulletEl);          swiper.a11y.addElRole($bulletEl, 'button');          swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1));        });      }    },    init: function init() {      var swiper = this;      swiper.$el.append(swiper.a11y.liveRegion);      // Navigation      var params = swiper.params.a11y;      var $nextEl;      var $prevEl;      if (swiper.navigation && swiper.navigation.$nextEl) {        $nextEl = swiper.navigation.$nextEl;      }      if (swiper.navigation && swiper.navigation.$prevEl) {        $prevEl = swiper.navigation.$prevEl;      }      if ($nextEl) {        swiper.a11y.makeElFocusable($nextEl);        swiper.a11y.addElRole($nextEl, 'button');        swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);        $nextEl.on('keydown', swiper.a11y.onEnterKey);      }      if ($prevEl) {        swiper.a11y.makeElFocusable($prevEl);        swiper.a11y.addElRole($prevEl, 'button');        swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);        $prevEl.on('keydown', swiper.a11y.onEnterKey);      }      // Pagination      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {        swiper.pagination.$el.on('keydown', ("." + (swiper.params.pagination.bulletClass)), swiper.a11y.onEnterKey);      }    },    destroy: function destroy() {      var swiper = this;      if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) { swiper.a11y.liveRegion.remove(); }      var $nextEl;      var $prevEl;      if (swiper.navigation && swiper.navigation.$nextEl) {        $nextEl = swiper.navigation.$nextEl;      }      if (swiper.navigation && swiper.navigation.$prevEl) {        $prevEl = swiper.navigation.$prevEl;      }      if ($nextEl) {        $nextEl.off('keydown', swiper.a11y.onEnterKey);      }      if ($prevEl) {        $prevEl.off('keydown', swiper.a11y.onEnterKey);      }      // Pagination      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {        swiper.pagination.$el.off('keydown', ("." + (swiper.params.pagination.bulletClass)), swiper.a11y.onEnterKey);      }    },  };  var A11y = {    name: 'a11y',    params: {      a11y: {        enabled: true,        notificationClass: 'swiper-notification',        prevSlideMessage: 'Previous slide',        nextSlideMessage: 'Next slide',        firstSlideMessage: 'This is the first slide',        lastSlideMessage: 'This is the last slide',        paginationBulletMessage: 'Go to slide {{index}}',      },    },    create: function create() {      var swiper = this;      Utils.extend(swiper, {        a11y: {          liveRegion: $(("<span class=\"" + (swiper.params.a11y.notificationClass) + "\" aria-live=\"assertive\" aria-atomic=\"true\"></span>")),        },      });      Object.keys(a11y).forEach(function (methodName) {        swiper.a11y[methodName] = a11y[methodName].bind(swiper);      });    },    on: {      init: function init() {        var swiper = this;        if (!swiper.params.a11y.enabled) { return; }        swiper.a11y.init();        swiper.a11y.updateNavigation();      },      toEdge: function toEdge() {        var swiper = this;        if (!swiper.params.a11y.enabled) { return; }        swiper.a11y.updateNavigation();      },      fromEdge: function fromEdge() {        var swiper = this;        if (!swiper.params.a11y.enabled) { return; }        swiper.a11y.updateNavigation();      },      paginationUpdate: function paginationUpdate() {        var swiper = this;        if (!swiper.params.a11y.enabled) { return; }        swiper.a11y.updatePagination();      },      destroy: function destroy() {        var swiper = this;        if (!swiper.params.a11y.enabled) { return; }        swiper.a11y.destroy();      },    },  };  var History = {    init: function init() {      var swiper = this;      if (!swiper.params.history) { return; }      if (!win.history || !win.history.pushState) {        swiper.params.history.enabled = false;        swiper.params.hashNavigation.enabled = true;        return;      }      var history = swiper.history;      history.initialized = true;      history.paths = History.getPathValues();      if (!history.paths.key && !history.paths.value) { return; }      history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);      if (!swiper.params.history.replaceState) {        win.addEventListener('popstate', swiper.history.setHistoryPopState);      }    },    destroy: function destroy() {      var swiper = this;      if (!swiper.params.history.replaceState) {        win.removeEventListener('popstate', swiper.history.setHistoryPopState);      }    },    setHistoryPopState: function setHistoryPopState() {      var swiper = this;      swiper.history.paths = History.getPathValues();      swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);    },    getPathValues: function getPathValues() {      var pathArray = win.location.pathname.slice(1).split('/').filter(function (part) { return part !== ''; });      var total = pathArray.length;      var key = pathArray[total - 2];      var value = pathArray[total - 1];      return { key: key, value: value };    },    setHistory: function setHistory(key, index) {      var swiper = this;      if (!swiper.history.initialized || !swiper.params.history.enabled) { return; }      var slide = swiper.slides.eq(index);      var value = History.slugify(slide.attr('data-history'));      if (!win.location.pathname.includes(key)) {        value = key + "/" + value;      }      var currentState = win.history.state;      if (currentState && currentState.value === value) {        return;      }      if (swiper.params.history.replaceState) {        win.history.replaceState({ value: value }, null, value);      } else {        win.history.pushState({ value: value }, null, value);      }    },    slugify: function slugify(text) {      return text.toString().toLowerCase()        .replace(/\s+/g, '-')        .replace(/[^\w-]+/g, '')        .replace(/--+/g, '-')        .replace(/^-+/, '')        .replace(/-+$/, '');    },    scrollToSlide: function scrollToSlide(speed, value, runCallbacks) {      var swiper = this;      if (value) {        for (var i = 0, length = swiper.slides.length; i < length; i += 1) {          var slide = swiper.slides.eq(i);          var slideHistory = History.slugify(slide.attr('data-history'));          if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {            var index = slide.index();            swiper.slideTo(index, speed, runCallbacks);          }        }      } else {        swiper.slideTo(0, speed, runCallbacks);      }    },  };  var History$1 = {    name: 'history',    params: {      history: {        enabled: false,        replaceState: false,        key: 'slides',      },    },    create: function create() {      var swiper = this;      Utils.extend(swiper, {        history: {          init: History.init.bind(swiper),          setHistory: History.setHistory.bind(swiper),          setHistoryPopState: History.setHistoryPopState.bind(swiper),          scrollToSlide: History.scrollToSlide.bind(swiper),          destroy: History.destroy.bind(swiper),        },      });    },    on: {      init: function init() {        var swiper = this;        if (swiper.params.history.enabled) {          swiper.history.init();        }      },      destroy: function destroy() {        var swiper = this;        if (swiper.params.history.enabled) {          swiper.history.destroy();        }      },      transitionEnd: function transitionEnd() {        var swiper = this;        if (swiper.history.initialized) {          swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);        }      },    },  };  var HashNavigation = {    onHashCange: function onHashCange() {      var swiper = this;      var newHash = doc.location.hash.replace('#', '');      var activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');      if (newHash !== activeSlideHash) {        var newIndex = swiper.$wrapperEl.children(("." + (swiper.params.slideClass) + "[data-hash=\"" + newHash + "\"]")).index();        if (typeof newIndex === 'undefined') { return; }        swiper.slideTo(newIndex);      }    },    setHash: function setHash() {      var swiper = this;      if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) { return; }      if (swiper.params.hashNavigation.replaceState && win.history && win.history.replaceState) {        win.history.replaceState(null, null, (("#" + (swiper.slides.eq(swiper.activeIndex).attr('data-hash'))) || ''));      } else {        var slide = swiper.slides.eq(swiper.activeIndex);        var hash = slide.attr('data-hash') || slide.attr('data-history');        doc.location.hash = hash || '';      }    },    init: function init() {      var swiper = this;      if (!swiper.params.hashNavigation.enabled || (swiper.params.history && swiper.params.history.enabled)) { return; }      swiper.hashNavigation.initialized = true;      var hash = doc.location.hash.replace('#', '');      if (hash) {        var speed = 0;        for (var i = 0, length = swiper.slides.length; i < length; i += 1) {          var slide = swiper.slides.eq(i);          var slideHash = slide.attr('data-hash') || slide.attr('data-history');          if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {            var index = slide.index();            swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);          }        }      }      if (swiper.params.hashNavigation.watchState) {        $(win).on('hashchange', swiper.hashNavigation.onHashCange);      }    },    destroy: function destroy() {      var swiper = this;      if (swiper.params.hashNavigation.watchState) {        $(win).off('hashchange', swiper.hashNavigation.onHashCange);      }    },  };  var HashNavigation$1 = {    name: 'hash-navigation',    params: {      hashNavigation: {        enabled: false,        replaceState: false,        watchState: false,      },    },    create: function create() {      var swiper = this;      Utils.extend(swiper, {        hashNavigation: {          initialized: false,          init: HashNavigation.init.bind(swiper),          destroy: HashNavigation.destroy.bind(swiper),          setHash: HashNavigation.setHash.bind(swiper),          onHashCange: HashNavigation.onHashCange.bind(swiper),        },      });    },    on: {      init: function init() {        var swiper = this;        if (swiper.params.hashNavigation.enabled) {          swiper.hashNavigation.init();        }      },      destroy: function destroy() {        var swiper = this;        if (swiper.params.hashNavigation.enabled) {          swiper.hashNavigation.destroy();        }      },      transitionEnd: function transitionEnd() {        var swiper = this;        if (swiper.hashNavigation.initialized) {          swiper.hashNavigation.setHash();        }      },    },  };  /* eslint no-underscore-dangle: "off" */  var Autoplay = {    run: function run() {      var swiper = this;      var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);      var delay = swiper.params.autoplay.delay;      if ($activeSlideEl.attr('data-swiper-autoplay')) {        delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;      }      swiper.autoplay.timeout = Utils.nextTick(function () {        if (swiper.params.autoplay.reverseDirection) {          if (swiper.params.loop) {            swiper.loopFix();            swiper.slidePrev(swiper.params.speed, true, true);            swiper.emit('autoplay');          } else if (!swiper.isBeginning) {            swiper.slidePrev(swiper.params.speed, true, true);            swiper.emit('autoplay');          } else if (!swiper.params.autoplay.stopOnLastSlide) {            swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);            swiper.emit('autoplay');          } else {            swiper.autoplay.stop();          }        } else if (swiper.params.loop) {          swiper.loopFix();          swiper.slideNext(swiper.params.speed, true, true);          swiper.emit('autoplay');        } else if (!swiper.isEnd) {          swiper.slideNext(swiper.params.speed, true, true);          swiper.emit('autoplay');        } else if (!swiper.params.autoplay.stopOnLastSlide) {          swiper.slideTo(0, swiper.params.speed, true, true);          swiper.emit('autoplay');        } else {          swiper.autoplay.stop();        }      }, delay);    },    start: function start() {      var swiper = this;      if (typeof swiper.autoplay.timeout !== 'undefined') { return false; }      if (swiper.autoplay.running) { return false; }      swiper.autoplay.running = true;      swiper.emit('autoplayStart');      swiper.autoplay.run();      return true;    },    stop: function stop() {      var swiper = this;      if (!swiper.autoplay.running) { return false; }      if (typeof swiper.autoplay.timeout === 'undefined') { return false; }      if (swiper.autoplay.timeout) {        clearTimeout(swiper.autoplay.timeout);        swiper.autoplay.timeout = undefined;      }      swiper.autoplay.running = false;      swiper.emit('autoplayStop');      return true;    },    pause: function pause(speed) {      var swiper = this;      if (!swiper.autoplay.running) { return; }      if (swiper.autoplay.paused) { return; }      if (swiper.autoplay.timeout) { clearTimeout(swiper.autoplay.timeout); }      swiper.autoplay.paused = true;      if (speed === 0 || !swiper.params.autoplay.waitForTransition) {        swiper.autoplay.paused = false;        swiper.autoplay.run();      } else {        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);      }    },  };  var Autoplay$1 = {    name: 'autoplay',    params: {      autoplay: {        enabled: false,        delay: 3000,        waitForTransition: true,        disableOnInteraction: true,        stopOnLastSlide: false,        reverseDirection: false,      },    },    create: function create() {      var swiper = this;      Utils.extend(swiper, {        autoplay: {          running: false,          paused: false,          run: Autoplay.run.bind(swiper),          start: Autoplay.start.bind(swiper),          stop: Autoplay.stop.bind(swiper),          pause: Autoplay.pause.bind(swiper),          onTransitionEnd: function onTransitionEnd(e) {            if (!swiper || swiper.destroyed || !swiper.$wrapperEl) { return; }            if (e.target !== this) { return; }            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);            swiper.autoplay.paused = false;            if (!swiper.autoplay.running) {              swiper.autoplay.stop();            } else {              swiper.autoplay.run();            }          },        },      });    },    on: {      init: function init() {        var swiper = this;        if (swiper.params.autoplay.enabled) {          swiper.autoplay.start();        }      },      beforeTransitionStart: function beforeTransitionStart(speed, internal) {        var swiper = this;        if (swiper.autoplay.running) {          if (internal || !swiper.params.autoplay.disableOnInteraction) {            swiper.autoplay.pause(speed);          } else {            swiper.autoplay.stop();          }        }      },      sliderFirstMove: function sliderFirstMove() {        var swiper = this;        if (swiper.autoplay.running) {          if (swiper.params.autoplay.disableOnInteraction) {            swiper.autoplay.stop();          } else {            swiper.autoplay.pause();          }        }      },      destroy: function destroy() {        var swiper = this;        if (swiper.autoplay.running) {          swiper.autoplay.stop();        }      },    },  };  var Fade = {    setTranslate: function setTranslate() {      var swiper = this;      var slides = swiper.slides;      for (var i = 0; i < slides.length; i += 1) {        var $slideEl = swiper.slides.eq(i);        var offset = $slideEl[0].swiperSlideOffset;        var tx = -offset;        if (!swiper.params.virtualTranslate) { tx -= swiper.translate; }        var ty = 0;        if (!swiper.isHorizontal()) {          ty = tx;          tx = 0;        }        var slideOpacity = swiper.params.fadeEffect.crossFade          ? Math.max(1 - Math.abs($slideEl[0].progress), 0)          : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);        $slideEl          .css({            opacity: slideOpacity,          })          .transform(("translate3d(" + tx + "px, " + ty + "px, 0px)"));      }    },    setTransition: function setTransition(duration) {      var swiper = this;      var slides = swiper.slides;      var $wrapperEl = swiper.$wrapperEl;      slides.transition(duration);      if (swiper.params.virtualTranslate && duration !== 0) {        var eventTriggered = false;        slides.transitionEnd(function () {          if (eventTriggered) { return; }          if (!swiper || swiper.destroyed) { return; }          eventTriggered = true;          swiper.animating = false;          var triggerEvents = ['webkitTransitionEnd', 'transitionend'];          for (var i = 0; i < triggerEvents.length; i += 1) {            $wrapperEl.trigger(triggerEvents[i]);          }        });      }    },  };  var EffectFade = {    name: 'effect-fade',    params: {      fadeEffect: {        crossFade: false,      },    },    create: function create() {      var swiper = this;      Utils.extend(swiper, {        fadeEffect: {          setTranslate: Fade.setTranslate.bind(swiper),          setTransition: Fade.setTransition.bind(swiper),        },      });    },    on: {      beforeInit: function beforeInit() {        var swiper = this;        if (swiper.params.effect !== 'fade') { return; }        swiper.classNames.push(((swiper.params.containerModifierClass) + "fade"));        var overwriteParams = {          slidesPerView: 1,          slidesPerColumn: 1,          slidesPerGroup: 1,          watchSlidesProgress: true,          spaceBetween: 0,          virtualTranslate: true,        };        Utils.extend(swiper.params, overwriteParams);        Utils.extend(swiper.originalParams, overwriteParams);      },      setTranslate: function setTranslate() {        var swiper = this;        if (swiper.params.effect !== 'fade') { return; }        swiper.fadeEffect.setTranslate();      },      setTransition: function setTransition(duration) {        var swiper = this;        if (swiper.params.effect !== 'fade') { return; }        swiper.fadeEffect.setTransition(duration);      },    },  };  var Cube = {    setTranslate: function setTranslate() {      var swiper = this;      var $el = swiper.$el;      var $wrapperEl = swiper.$wrapperEl;      var slides = swiper.slides;      var swiperWidth = swiper.width;      var swiperHeight = swiper.height;      var rtl = swiper.rtlTranslate;      var swiperSize = swiper.size;      var params = swiper.params.cubeEffect;      var isHorizontal = swiper.isHorizontal();      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;      var wrapperRotate = 0;      var $cubeShadowEl;      if (params.shadow) {        if (isHorizontal) {          $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');          if ($cubeShadowEl.length === 0) {            $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');            $wrapperEl.append($cubeShadowEl);          }          $cubeShadowEl.css({ height: (swiperWidth + "px") });        } else {          $cubeShadowEl = $el.find('.swiper-cube-shadow');          if ($cubeShadowEl.length === 0) {            $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');            $el.append($cubeShadowEl);          }        }      }      for (var i = 0; i < slides.length; i += 1) {        var $slideEl = slides.eq(i);        var slideIndex = i;        if (isVirtual) {          slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);        }        var slideAngle = slideIndex * 90;        var round = Math.floor(slideAngle / 360);        if (rtl) {          slideAngle = -slideAngle;          round = Math.floor(-slideAngle / 360);        }        var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);        var tx = 0;        var ty = 0;        var tz = 0;        if (slideIndex % 4 === 0) {          tx = -round * 4 * swiperSize;          tz = 0;        } else if ((slideIndex - 1) % 4 === 0) {          tx = 0;          tz = -round * 4 * swiperSize;        } else if ((slideIndex - 2) % 4 === 0) {          tx = swiperSize + (round * 4 * swiperSize);          tz = swiperSize;        } else if ((slideIndex - 3) % 4 === 0) {          tx = -swiperSize;          tz = (3 * swiperSize) + (swiperSize * 4 * round);        }        if (rtl) {          tx = -tx;        }        if (!isHorizontal) {          ty = tx;          tx = 0;        }        var transform = "rotateX(" + (isHorizontal ? 0 : -slideAngle) + "deg) rotateY(" + (isHorizontal ? slideAngle : 0) + "deg) translate3d(" + tx + "px, " + ty + "px, " + tz + "px)";        if (progress <= 1 && progress > -1) {          wrapperRotate = (slideIndex * 90) + (progress * 90);          if (rtl) { wrapperRotate = (-slideIndex * 90) - (progress * 90); }        }        $slideEl.transform(transform);        if (params.slideShadows) {          // Set shadows          var shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');          var shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');          if (shadowBefore.length === 0) {            shadowBefore = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>"));            $slideEl.append(shadowBefore);          }          if (shadowAfter.length === 0) {            shadowAfter = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>"));            $slideEl.append(shadowAfter);          }          if (shadowBefore.length) { shadowBefore[0].style.opacity = Math.max(-progress, 0); }          if (shadowAfter.length) { shadowAfter[0].style.opacity = Math.max(progress, 0); }        }      }      $wrapperEl.css({        '-webkit-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),        '-moz-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),        '-ms-transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),        'transform-origin': ("50% 50% -" + (swiperSize / 2) + "px"),      });      if (params.shadow) {        if (isHorizontal) {          $cubeShadowEl.transform(("translate3d(0px, " + ((swiperWidth / 2) + params.shadowOffset) + "px, " + (-swiperWidth / 2) + "px) rotateX(90deg) rotateZ(0deg) scale(" + (params.shadowScale) + ")"));        } else {          var shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);          var multiplier = 1.5 - (            (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2)            + (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2)          );          var scale1 = params.shadowScale;          var scale2 = params.shadowScale / multiplier;          var offset = params.shadowOffset;          $cubeShadowEl.transform(("scale3d(" + scale1 + ", 1, " + scale2 + ") translate3d(0px, " + ((swiperHeight / 2) + offset) + "px, " + (-swiperHeight / 2 / scale2) + "px) rotateX(-90deg)"));        }      }      var zFactor = (Browser.isSafari || Browser.isUiWebView) ? (-swiperSize / 2) : 0;      $wrapperEl        .transform(("translate3d(0px,0," + zFactor + "px) rotateX(" + (swiper.isHorizontal() ? 0 : wrapperRotate) + "deg) rotateY(" + (swiper.isHorizontal() ? -wrapperRotate : 0) + "deg)"));    },    setTransition: function setTransition(duration) {      var swiper = this;      var $el = swiper.$el;      var slides = swiper.slides;      slides        .transition(duration)        .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')        .transition(duration);      if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {        $el.find('.swiper-cube-shadow').transition(duration);      }    },  };  var EffectCube = {    name: 'effect-cube',    params: {      cubeEffect: {        slideShadows: true,        shadow: true,        shadowOffset: 20,        shadowScale: 0.94,      },    },    create: function create() {      var swiper = this;      Utils.extend(swiper, {        cubeEffect: {          setTranslate: Cube.setTranslate.bind(swiper),          setTransition: Cube.setTransition.bind(swiper),        },      });    },    on: {      beforeInit: function beforeInit() {        var swiper = this;        if (swiper.params.effect !== 'cube') { return; }        swiper.classNames.push(((swiper.params.containerModifierClass) + "cube"));        swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));        var overwriteParams = {          slidesPerView: 1,          slidesPerColumn: 1,          slidesPerGroup: 1,          watchSlidesProgress: true,          resistanceRatio: 0,          spaceBetween: 0,          centeredSlides: false,          virtualTranslate: true,        };        Utils.extend(swiper.params, overwriteParams);        Utils.extend(swiper.originalParams, overwriteParams);      },      setTranslate: function setTranslate() {        var swiper = this;        if (swiper.params.effect !== 'cube') { return; }        swiper.cubeEffect.setTranslate();      },      setTransition: function setTransition(duration) {        var swiper = this;        if (swiper.params.effect !== 'cube') { return; }        swiper.cubeEffect.setTransition(duration);      },    },  };  var Flip = {    setTranslate: function setTranslate() {      var swiper = this;      var slides = swiper.slides;      var rtl = swiper.rtlTranslate;      for (var i = 0; i < slides.length; i += 1) {        var $slideEl = slides.eq(i);        var progress = $slideEl[0].progress;        if (swiper.params.flipEffect.limitRotation) {          progress = Math.max(Math.min($slideEl[0].progress, 1), -1);        }        var offset = $slideEl[0].swiperSlideOffset;        var rotate = -180 * progress;        var rotateY = rotate;        var rotateX = 0;        var tx = -offset;        var ty = 0;        if (!swiper.isHorizontal()) {          ty = tx;          tx = 0;          rotateX = -rotateY;          rotateY = 0;        } else if (rtl) {          rotateY = -rotateY;        }        $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;        if (swiper.params.flipEffect.slideShadows) {          // Set shadows          var shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');          var shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');          if (shadowBefore.length === 0) {            shadowBefore = $(("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'left' : 'top') + "\"></div>"));            $slideEl.append(shadowBefore);          }          if (shadowAfter.length === 0) {            shadowAfter = $(("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'right' : 'bottom') + "\"></div>"));            $slideEl.append(shadowAfter);          }          if (shadowBefore.length) { shadowBefore[0].style.opacity = Math.max(-progress, 0); }          if (shadowAfter.length) { shadowAfter[0].style.opacity = Math.max(progress, 0); }        }        $slideEl          .transform(("translate3d(" + tx + "px, " + ty + "px, 0px) rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)"));      }    },    setTransition: function setTransition(duration) {      var swiper = this;      var slides = swiper.slides;      var activeIndex = swiper.activeIndex;      var $wrapperEl = swiper.$wrapperEl;      slides        .transition(duration)        .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')        .transition(duration);      if (swiper.params.virtualTranslate && duration !== 0) {        var eventTriggered = false;        // eslint-disable-next-line        slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {          if (eventTriggered) { return; }          if (!swiper || swiper.destroyed) { return; }          // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;          eventTriggered = true;          swiper.animating = false;          var triggerEvents = ['webkitTransitionEnd', 'transitionend'];          for (var i = 0; i < triggerEvents.length; i += 1) {            $wrapperEl.trigger(triggerEvents[i]);          }        });      }    },  };  var EffectFlip = {    name: 'effect-flip',    params: {      flipEffect: {        slideShadows: true,        limitRotation: true,      },    },    create: function create() {      var swiper = this;      Utils.extend(swiper, {        flipEffect: {          setTranslate: Flip.setTranslate.bind(swiper),          setTransition: Flip.setTransition.bind(swiper),        },      });    },    on: {      beforeInit: function beforeInit() {        var swiper = this;        if (swiper.params.effect !== 'flip') { return; }        swiper.classNames.push(((swiper.params.containerModifierClass) + "flip"));        swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));        var overwriteParams = {          slidesPerView: 1,          slidesPerColumn: 1,          slidesPerGroup: 1,          watchSlidesProgress: true,          spaceBetween: 0,          virtualTranslate: true,        };        Utils.extend(swiper.params, overwriteParams);        Utils.extend(swiper.originalParams, overwriteParams);      },      setTranslate: function setTranslate() {        var swiper = this;        if (swiper.params.effect !== 'flip') { return; }        swiper.flipEffect.setTranslate();      },      setTransition: function setTransition(duration) {        var swiper = this;        if (swiper.params.effect !== 'flip') { return; }        swiper.flipEffect.setTransition(duration);      },    },  };  var Coverflow = {    setTranslate: function setTranslate() {      var swiper = this;      var swiperWidth = swiper.width;      var swiperHeight = swiper.height;      var slides = swiper.slides;      var $wrapperEl = swiper.$wrapperEl;      var slidesSizesGrid = swiper.slidesSizesGrid;      var params = swiper.params.coverflowEffect;      var isHorizontal = swiper.isHorizontal();      var transform = swiper.translate;      var center = isHorizontal ? -transform + (swiperWidth / 2) : -transform + (swiperHeight / 2);      var rotate = isHorizontal ? params.rotate : -params.rotate;      var translate = params.depth;      // Each slide offset from center      for (var i = 0, length = slides.length; i < length; i += 1) {        var $slideEl = slides.eq(i);        var slideSize = slidesSizesGrid[i];        var slideOffset = $slideEl[0].swiperSlideOffset;        var offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;        var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;        var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;        // var rotateZ = 0        var translateZ = -translate * Math.abs(offsetMultiplier);        var translateY = isHorizontal ? 0 : params.stretch * (offsetMultiplier);        var translateX = isHorizontal ? params.stretch * (offsetMultiplier) : 0;        // Fix for ultra small values        if (Math.abs(translateX) < 0.001) { translateX = 0; }        if (Math.abs(translateY) < 0.001) { translateY = 0; }        if (Math.abs(translateZ) < 0.001) { translateZ = 0; }        if (Math.abs(rotateY) < 0.001) { rotateY = 0; }        if (Math.abs(rotateX) < 0.001) { rotateX = 0; }        var slideTransform = "translate3d(" + translateX + "px," + translateY + "px," + translateZ + "px)  rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)";        $slideEl.transform(slideTransform);        $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;        if (params.slideShadows) {          // Set shadows          var $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');          var $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');          if ($shadowBeforeEl.length === 0) {            $shadowBeforeEl = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>"));            $slideEl.append($shadowBeforeEl);          }          if ($shadowAfterEl.length === 0) {            $shadowAfterEl = $(("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>"));            $slideEl.append($shadowAfterEl);          }          if ($shadowBeforeEl.length) { $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0; }          if ($shadowAfterEl.length) { $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0; }        }      }      // Set correct perspective for IE10      if (Support.pointerEvents || Support.prefixedPointerEvents) {        var ws = $wrapperEl[0].style;        ws.perspectiveOrigin = center + "px 50%";      }    },    setTransition: function setTransition(duration) {      var swiper = this;      swiper.slides        .transition(duration)        .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')        .transition(duration);    },  };  var EffectCoverflow = {    name: 'effect-coverflow',    params: {      coverflowEffect: {        rotate: 50,        stretch: 0,        depth: 100,        modifier: 1,        slideShadows: true,      },    },    create: function create() {      var swiper = this;      Utils.extend(swiper, {        coverflowEffect: {          setTranslate: Coverflow.setTranslate.bind(swiper),          setTransition: Coverflow.setTransition.bind(swiper),        },      });    },    on: {      beforeInit: function beforeInit() {        var swiper = this;        if (swiper.params.effect !== 'coverflow') { return; }        swiper.classNames.push(((swiper.params.containerModifierClass) + "coverflow"));        swiper.classNames.push(((swiper.params.containerModifierClass) + "3d"));        swiper.params.watchSlidesProgress = true;        swiper.originalParams.watchSlidesProgress = true;      },      setTranslate: function setTranslate() {        var swiper = this;        if (swiper.params.effect !== 'coverflow') { return; }        swiper.coverflowEffect.setTranslate();      },      setTransition: function setTransition(duration) {        var swiper = this;        if (swiper.params.effect !== 'coverflow') { return; }        swiper.coverflowEffect.setTransition(duration);      },    },  };  var Thumbs = {    init: function init() {      var swiper = this;      var ref = swiper.params;      var thumbsParams = ref.thumbs;      var SwiperClass = swiper.constructor;      if (thumbsParams.swiper instanceof SwiperClass) {        swiper.thumbs.swiper = thumbsParams.swiper;        Utils.extend(swiper.thumbs.swiper.originalParams, {          watchSlidesProgress: true,          slideToClickedSlide: false,        });        Utils.extend(swiper.thumbs.swiper.params, {          watchSlidesProgress: true,          slideToClickedSlide: false,        });      } else if (Utils.isObject(thumbsParams.swiper)) {        swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {          watchSlidesVisibility: true,          watchSlidesProgress: true,          slideToClickedSlide: false,        }));        swiper.thumbs.swiperCreated = true;      }      swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);      swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);    },    onThumbClick: function onThumbClick() {      var swiper = this;      var thumbsSwiper = swiper.thumbs.swiper;      if (!thumbsSwiper) { return; }      var clickedIndex = thumbsSwiper.clickedIndex;      var clickedSlide = thumbsSwiper.clickedSlide;      if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) { return; }      if (typeof clickedIndex === 'undefined' || clickedIndex === null) { return; }      var slideToIndex;      if (thumbsSwiper.params.loop) {        slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);      } else {        slideToIndex = clickedIndex;      }      if (swiper.params.loop) {        var currentIndex = swiper.activeIndex;        if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {          swiper.loopFix();          // eslint-disable-next-line          swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;          currentIndex = swiper.activeIndex;        }        var prevIndex = swiper.slides.eq(currentIndex).prevAll(("[data-swiper-slide-index=\"" + slideToIndex + "\"]")).eq(0).index();        var nextIndex = swiper.slides.eq(currentIndex).nextAll(("[data-swiper-slide-index=\"" + slideToIndex + "\"]")).eq(0).index();        if (typeof prevIndex === 'undefined') { slideToIndex = nextIndex; }        else if (typeof nextIndex === 'undefined') { slideToIndex = prevIndex; }        else if (nextIndex - currentIndex < currentIndex - prevIndex) { slideToIndex = nextIndex; }        else { slideToIndex = prevIndex; }      }      swiper.slideTo(slideToIndex);    },    update: function update(initial) {      var swiper = this;      var thumbsSwiper = swiper.thumbs.swiper;      if (!thumbsSwiper) { return; }      var slidesPerView = thumbsSwiper.params.slidesPerView === 'auto'        ? thumbsSwiper.slidesPerViewDynamic()        : thumbsSwiper.params.slidesPerView;      if (swiper.realIndex !== thumbsSwiper.realIndex) {        var currentThumbsIndex = thumbsSwiper.activeIndex;        var newThumbsIndex;        if (thumbsSwiper.params.loop) {          if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {            thumbsSwiper.loopFix();            // eslint-disable-next-line            thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;            currentThumbsIndex = thumbsSwiper.activeIndex;          }          // Find actual thumbs index to slide to          var prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll(("[data-swiper-slide-index=\"" + (swiper.realIndex) + "\"]")).eq(0).index();          var nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll(("[data-swiper-slide-index=\"" + (swiper.realIndex) + "\"]")).eq(0).index();          if (typeof prevThumbsIndex === 'undefined') { newThumbsIndex = nextThumbsIndex; }          else if (typeof nextThumbsIndex === 'undefined') { newThumbsIndex = prevThumbsIndex; }          else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) { newThumbsIndex = currentThumbsIndex; }          else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) { newThumbsIndex = nextThumbsIndex; }          else { newThumbsIndex = prevThumbsIndex; }        } else {          newThumbsIndex = swiper.realIndex;        }        if (thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {          if (thumbsSwiper.params.centeredSlides) {            if (newThumbsIndex > currentThumbsIndex) {              newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;            } else {              newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;            }          } else if (newThumbsIndex > currentThumbsIndex) {            newThumbsIndex = newThumbsIndex - slidesPerView + 1;          }          thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);        }      }      // Activate thumbs      var thumbsToActivate = 1;      var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;      if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {        thumbsToActivate = swiper.params.slidesPerView;      }      thumbsSwiper.slides.removeClass(thumbActiveClass);      if (thumbsSwiper.params.loop) {        for (var i = 0; i < thumbsToActivate; i += 1) {          thumbsSwiper.$wrapperEl.children(("[data-swiper-slide-index=\"" + (swiper.realIndex + i) + "\"]")).addClass(thumbActiveClass);        }      } else {        for (var i$1 = 0; i$1 < thumbsToActivate; i$1 += 1) {          thumbsSwiper.slides.eq(swiper.realIndex + i$1).addClass(thumbActiveClass);        }      }    },  };  var Thumbs$1 = {    name: 'thumbs',    params: {      thumbs: {        swiper: null,        slideThumbActiveClass: 'swiper-slide-thumb-active',        thumbsContainerClass: 'swiper-container-thumbs',      },    },    create: function create() {      var swiper = this;      Utils.extend(swiper, {        thumbs: {          swiper: null,          init: Thumbs.init.bind(swiper),          update: Thumbs.update.bind(swiper),          onThumbClick: Thumbs.onThumbClick.bind(swiper),        },      });    },    on: {      beforeInit: function beforeInit() {        var swiper = this;        var ref = swiper.params;        var thumbs = ref.thumbs;        if (!thumbs || !thumbs.swiper) { return; }        swiper.thumbs.init();        swiper.thumbs.update(true);      },      slideChange: function slideChange() {        var swiper = this;        if (!swiper.thumbs.swiper) { return; }        swiper.thumbs.update();      },      update: function update() {        var swiper = this;        if (!swiper.thumbs.swiper) { return; }        swiper.thumbs.update();      },      resize: function resize() {        var swiper = this;        if (!swiper.thumbs.swiper) { return; }        swiper.thumbs.update();      },      observerUpdate: function observerUpdate() {        var swiper = this;        if (!swiper.thumbs.swiper) { return; }        swiper.thumbs.update();      },      setTransition: function setTransition(duration) {        var swiper = this;        var thumbsSwiper = swiper.thumbs.swiper;        if (!thumbsSwiper) { return; }        thumbsSwiper.setTransition(duration);      },      beforeDestroy: function beforeDestroy() {        var swiper = this;        var thumbsSwiper = swiper.thumbs.swiper;        if (!thumbsSwiper) { return; }        if (swiper.thumbs.swiperCreated && thumbsSwiper) {          thumbsSwiper.destroy();        }      },    },  };  // Swiper Class  var components = [    Device$1,    Support$1,    Browser$1,    Resize,    Observer$1,    Virtual$1,    Keyboard$1,    Mousewheel$1,    Navigation$1,    Pagination$1,    Scrollbar$1,    Parallax$1,    Zoom$1,    Lazy$1,    Controller$1,    A11y,    History$1,    HashNavigation$1,    Autoplay$1,    EffectFade,    EffectCube,    EffectFlip,    EffectCoverflow,    Thumbs$1  ];  if (typeof Swiper.use === 'undefined') {    Swiper.use = Swiper.Class.use;    Swiper.installModule = Swiper.Class.installModule;  }  Swiper.use(components);  return Swiper;})));// dependencyes: jQuery// переписать на чистом js// https://medium.com/talk-like/detecting-if-an-element-is-in-the-viewport-jquery-a6a4405a3ea2$.fn.isInViewport = function () {    var        elementTop = $(this).offset().top,        elementBottom = elementTop + $(this).outerHeight(),        viewportTop = $(window).scrollTop(),        viewportBottom = viewportTop + $(window).height();    return elementBottom > viewportTop && elementTop < viewportBottom;};// usage example:// var isInViewportHandler = function () {//     if ($('.some-div').isInViewport()) {//         // some code//     }// };//// isInViewportHandler();//// $(window).on('resize scroll', function () {////     isInViewportHandler();//// });(function() {  var MutationObserver, Util, WeakMap, getComputedStyle, getComputedStyleRX,    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };  Util = (function() {    function Util() {}    Util.prototype.extend = function(custom, defaults) {      var key, value;      for (key in defaults) {        value = defaults[key];        if (custom[key] == null) {          custom[key] = value;        }      }      return custom;    };    Util.prototype.isMobile = function(agent) {      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(agent);    };    Util.prototype.createEvent = function(event, bubble, cancel, detail) {      var customEvent;      if (bubble == null) {        bubble = false;      }      if (cancel == null) {        cancel = false;      }      if (detail == null) {        detail = null;      }      if (document.createEvent != null) {        customEvent = document.createEvent('CustomEvent');        customEvent.initCustomEvent(event, bubble, cancel, detail);      } else if (document.createEventObject != null) {        customEvent = document.createEventObject();        customEvent.eventType = event;      } else {        customEvent.eventName = event;      }      return customEvent;    };    Util.prototype.emitEvent = function(elem, event) {      if (elem.dispatchEvent != null) {        return elem.dispatchEvent(event);      } else if (event in (elem != null)) {        return elem[event]();      } else if (("on" + event) in (elem != null)) {        return elem["on" + event]();      }    };    Util.prototype.addEvent = function(elem, event, fn) {      if (elem.addEventListener != null) {        return elem.addEventListener(event, fn, false);      } else if (elem.attachEvent != null) {        return elem.attachEvent("on" + event, fn);      } else {        return elem[event] = fn;      }    };    Util.prototype.removeEvent = function(elem, event, fn) {      if (elem.removeEventListener != null) {        return elem.removeEventListener(event, fn, false);      } else if (elem.detachEvent != null) {        return elem.detachEvent("on" + event, fn);      } else {        return delete elem[event];      }    };    Util.prototype.innerHeight = function() {      if ('innerHeight' in window) {        return window.innerHeight;      } else {        return document.documentElement.clientHeight;      }    };    return Util;  })();  WeakMap = this.WeakMap || this.MozWeakMap || (WeakMap = (function() {    function WeakMap() {      this.keys = [];      this.values = [];    }    WeakMap.prototype.get = function(key) {      var i, item, j, len, ref;      ref = this.keys;      for (i = j = 0, len = ref.length; j < len; i = ++j) {        item = ref[i];        if (item === key) {          return this.values[i];        }      }    };    WeakMap.prototype.set = function(key, value) {      var i, item, j, len, ref;      ref = this.keys;      for (i = j = 0, len = ref.length; j < len; i = ++j) {        item = ref[i];        if (item === key) {          this.values[i] = value;          return;        }      }      this.keys.push(key);      return this.values.push(value);    };    return WeakMap;  })());  MutationObserver = this.MutationObserver || this.WebkitMutationObserver || this.MozMutationObserver || (MutationObserver = (function() {    function MutationObserver() {      if (typeof console !== "undefined" && console !== null) {        console.warn('MutationObserver is not supported by your browser.');      }      if (typeof console !== "undefined" && console !== null) {        console.warn('WOW.js cannot detect dom mutations, please call .sync() after loading new content.');      }    }    MutationObserver.notSupported = true;    MutationObserver.prototype.observe = function() {};    return MutationObserver;  })());  getComputedStyle = this.getComputedStyle || function(el, pseudo) {    this.getPropertyValue = function(prop) {      var ref;      if (prop === 'float') {        prop = 'styleFloat';      }      if (getComputedStyleRX.test(prop)) {        prop.replace(getComputedStyleRX, function(_, _char) {          return _char.toUpperCase();        });      }      return ((ref = el.currentStyle) != null ? ref[prop] : void 0) || null;    };    return this;  };  getComputedStyleRX = /(\-([a-z]){1})/g;  this.WOW = (function() {    WOW.prototype.defaults = {      boxClass: 'wow',      animateClass: 'animated',      offset: 0,      mobile: true,      live: true,      callback: null,      scrollContainer: null    };    function WOW(options) {      if (options == null) {        options = {};      }      this.scrollCallback = bind(this.scrollCallback, this);      this.scrollHandler = bind(this.scrollHandler, this);      this.resetAnimation = bind(this.resetAnimation, this);      this.start = bind(this.start, this);      this.scrolled = true;      this.config = this.util().extend(options, this.defaults);      if (options.scrollContainer != null) {        this.config.scrollContainer = document.querySelector(options.scrollContainer);      }      this.animationNameCache = new WeakMap();      this.wowEvent = this.util().createEvent(this.config.boxClass);    }    WOW.prototype.init = function() {      var ref;      this.element = window.document.documentElement;      if ((ref = document.readyState) === "interactive" || ref === "complete") {        this.start();      } else {        this.util().addEvent(document, 'DOMContentLoaded', this.start);      }      return this.finished = [];    };    WOW.prototype.start = function() {      var box, j, len, ref;      this.stopped = false;      this.boxes = (function() {        var j, len, ref, results;        ref = this.element.querySelectorAll("." + this.config.boxClass);        results = [];        for (j = 0, len = ref.length; j < len; j++) {          box = ref[j];          results.push(box);        }        return results;      }).call(this);      this.all = (function() {        var j, len, ref, results;        ref = this.boxes;        results = [];        for (j = 0, len = ref.length; j < len; j++) {          box = ref[j];          results.push(box);        }        return results;      }).call(this);      if (this.boxes.length) {        if (this.disabled()) {          this.resetStyle();        } else {          ref = this.boxes;          for (j = 0, len = ref.length; j < len; j++) {            box = ref[j];            this.applyStyle(box, true);          }        }      }      if (!this.disabled()) {        this.util().addEvent(this.config.scrollContainer || window, 'scroll', this.scrollHandler);        this.util().addEvent(window, 'resize', this.scrollHandler);        this.interval = setInterval(this.scrollCallback, 50);      }      if (this.config.live) {        return new MutationObserver((function(_this) {          return function(records) {            var k, len1, node, record, results;            results = [];            for (k = 0, len1 = records.length; k < len1; k++) {              record = records[k];              results.push((function() {                var l, len2, ref1, results1;                ref1 = record.addedNodes || [];                results1 = [];                for (l = 0, len2 = ref1.length; l < len2; l++) {                  node = ref1[l];                  results1.push(this.doSync(node));                }                return results1;              }).call(_this));            }            return results;          };        })(this)).observe(document.body, {          childList: true,          subtree: true        });      }    };    WOW.prototype.stop = function() {      this.stopped = true;      this.util().removeEvent(this.config.scrollContainer || window, 'scroll', this.scrollHandler);      this.util().removeEvent(window, 'resize', this.scrollHandler);      if (this.interval != null) {        return clearInterval(this.interval);      }    };    WOW.prototype.sync = function(element) {      if (MutationObserver.notSupported) {        return this.doSync(this.element);      }    };    WOW.prototype.doSync = function(element) {      var box, j, len, ref, results;      if (element == null) {        element = this.element;      }      if (element.nodeType !== 1) {        return;      }      element = element.parentNode || element;      ref = element.querySelectorAll("." + this.config.boxClass);      results = [];      for (j = 0, len = ref.length; j < len; j++) {        box = ref[j];        if (indexOf.call(this.all, box) < 0) {          this.boxes.push(box);          this.all.push(box);          if (this.stopped || this.disabled()) {            this.resetStyle();          } else {            this.applyStyle(box, true);          }          results.push(this.scrolled = true);        } else {          results.push(void 0);        }      }      return results;    };    WOW.prototype.show = function(box) {      this.applyStyle(box);      box.className = box.className + " " + this.config.animateClass;      if (this.config.callback != null) {        this.config.callback(box);      }      this.util().emitEvent(box, this.wowEvent);      this.util().addEvent(box, 'animationend', this.resetAnimation);      this.util().addEvent(box, 'oanimationend', this.resetAnimation);      this.util().addEvent(box, 'webkitAnimationEnd', this.resetAnimation);      this.util().addEvent(box, 'MSAnimationEnd', this.resetAnimation);      return box;    };    WOW.prototype.applyStyle = function(box, hidden) {      var delay, duration, iteration;      duration = box.getAttribute('data-wow-duration');      delay = box.getAttribute('data-wow-delay');      iteration = box.getAttribute('data-wow-iteration');      return this.animate((function(_this) {        return function() {          return _this.customStyle(box, hidden, duration, delay, iteration);        };      })(this));    };    WOW.prototype.animate = (function() {      if ('requestAnimationFrame' in window) {        return function(callback) {          return window.requestAnimationFrame(callback);        };      } else {        return function(callback) {          return callback();        };      }    })();    WOW.prototype.resetStyle = function() {      var box, j, len, ref, results;      ref = this.boxes;      results = [];      for (j = 0, len = ref.length; j < len; j++) {        box = ref[j];        results.push(box.style.visibility = 'visible');      }      return results;    };    WOW.prototype.resetAnimation = function(event) {      var target;      if (event.type.toLowerCase().indexOf('animationend') >= 0) {        target = event.target || event.srcElement;        return target.className = target.className.replace(this.config.animateClass, '').trim();      }    };    WOW.prototype.customStyle = function(box, hidden, duration, delay, iteration) {      if (hidden) {        this.cacheAnimationName(box);      }      box.style.visibility = hidden ? 'hidden' : 'visible';      if (duration) {        this.vendorSet(box.style, {          animationDuration: duration        });      }      if (delay) {        this.vendorSet(box.style, {          animationDelay: delay        });      }      if (iteration) {        this.vendorSet(box.style, {          animationIterationCount: iteration        });      }      this.vendorSet(box.style, {        animationName: hidden ? 'none' : this.cachedAnimationName(box)      });      return box;    };    WOW.prototype.vendors = ["moz", "webkit"];    WOW.prototype.vendorSet = function(elem, properties) {      var name, results, value, vendor;      results = [];      for (name in properties) {        value = properties[name];        elem["" + name] = value;        results.push((function() {          var j, len, ref, results1;          ref = this.vendors;          results1 = [];          for (j = 0, len = ref.length; j < len; j++) {            vendor = ref[j];            results1.push(elem["" + vendor + (name.charAt(0).toUpperCase()) + (name.substr(1))] = value);          }          return results1;        }).call(this));      }      return results;    };    WOW.prototype.vendorCSS = function(elem, property) {      var j, len, ref, result, style, vendor;      style = getComputedStyle(elem);      result = style.getPropertyCSSValue(property);      ref = this.vendors;      for (j = 0, len = ref.length; j < len; j++) {        vendor = ref[j];        result = result || style.getPropertyCSSValue("-" + vendor + "-" + property);      }      return result;    };    WOW.prototype.animationName = function(box) {      var animationName, error;      try {        animationName = this.vendorCSS(box, 'animation-name').cssText;      } catch (error) {        animationName = getComputedStyle(box).getPropertyValue('animation-name');      }      if (animationName === 'none') {        return '';      } else {        return animationName;      }    };    WOW.prototype.cacheAnimationName = function(box) {      return this.animationNameCache.set(box, this.animationName(box));    };    WOW.prototype.cachedAnimationName = function(box) {      return this.animationNameCache.get(box);    };    WOW.prototype.scrollHandler = function() {      return this.scrolled = true;    };    WOW.prototype.scrollCallback = function() {      var box;      if (this.scrolled) {        this.scrolled = false;        this.boxes = (function() {          var j, len, ref, results;          ref = this.boxes;          results = [];          for (j = 0, len = ref.length; j < len; j++) {            box = ref[j];            if (!(box)) {              continue;            }            if (this.isVisible(box)) {              this.show(box);              continue;            }            results.push(box);          }          return results;        }).call(this);        if (!(this.boxes.length || this.config.live)) {          return this.stop();        }      }    };    WOW.prototype.offsetTop = function(element) {      var top;      while (element.offsetTop === void 0) {        element = element.parentNode;      }      top = element.offsetTop;      while (element = element.offsetParent) {        top += element.offsetTop;      }      return top;    };    WOW.prototype.isVisible = function(box) {      var bottom, offset, top, viewBottom, viewTop;      offset = box.getAttribute('data-wow-offset') || this.config.offset;      viewTop = (this.config.scrollContainer && this.config.scrollContainer.scrollTop) || window.pageYOffset;      viewBottom = viewTop + Math.min(this.element.clientHeight, this.util().innerHeight()) - offset;      top = this.offsetTop(box);      bottom = top + box.clientHeight;      return top <= viewBottom && bottom >= viewTop;    };    WOW.prototype.util = function() {      return this._util != null ? this._util : this._util = new Util();    };    WOW.prototype.disabled = function() {      return !this.config.mobile && this.util().isMobile(navigator.userAgent);    };    return WOW;  })();}).call(this);// script =====================================================//$(document).load(function () {});$(document).ready(function () {    // global project vars    window.windowWidth = $(window).width();    window.modalOpened = false;    setTimeout(function () {        $('.loader').removeClass('is-visible');    }, 1300);    $(document).on('lazybeforeunveil', function(){        $('.loader').addClass('is-visible');        setTimeout(function () {            $('.loader').removeClass('is-visible');        }, 250);    });    (function () {        $(window).on('resize scroll', function () {            scrollProgress();        });        // https://www.w3schools.com/howto/howto_js_scroll_indicator.asp        function scrollProgress() {            var winScroll = document.body.scrollTop || document.documentElement.scrollTop;            var height = document.documentElement.scrollHeight - document.documentElement.clientHeight;            var scrolled = (winScroll / height) * 100;            //document.querySelectorAll("[data-progress]").style.width = scrolled + "%";            $('[data-progress]').each(function () {                $(this).css({                    width: scrolled + "%"                });            });        }    })();    (function () {        var            $el = $('.js-collapsible'),            isActiveClass = 'is-active',            isVisibleClass = 'is-visible';        if ($el.length) {            $el.each(function () {                var _this = $(this);                _this.on('click', function () {                    var $target = _this.attr('data-target');                    $el.toggleClass('is-open');                    _this.siblings('[data-target-place=' + $target + ']').slideToggle();                });            });            $el.parent().find('a').each(function () {                $(this).on('click', function (e) {                    e.preventDefault();                    scrollToTarget($(this));                });            });        }        // ------------------------------------------------------------------------------------------        // functions        // ------------------------------------------------------------------------------------------        function scrollToTarget(el) {            const                $target = $(el.attr('href')),                $page = $('html'),                $lomeDesktopHeight = $('.lome').outerHeight();            console.log($lomeDesktopHeight);            if ($target.length === 0) return;            $page.animate({                scrollTop: $target.offset().top            }, 750);            // stop scrolling when user scrolls manually ( https://stackoverflow.com/questions/18445590/jquery-animate-stop-scrolling-when-user-scrolls-manually )            $page.on("scroll mousedown wheel DOMMouseScroll mousewheel keyup touchmove", function () {                $(this).stop();            });        }    })();    $(document).on('click', '[data-chatmess-click]', function (e) {        e.preventDefault();        e.stopPropagation();        $('[data-chatmess]').toggleClass('chatmess_active');    });    // var messager_userAgent = window.navigator.userAgent.toLowerCase();    //    // function messager_isFind(text) {    //     return messager_userAgent.indexOf(text) > -1;    // }    //    // function messager_isIos() {    //     return messager_isIphone() || messager_isIpod() || messager_isIpad();    // }    //    // function messager_isIphone() {    //     return !messager_isWindows() && messager_isFind('iphone');    // }    //    // function messager_isIpod() {    //     return messager_isFind('ipod');    // }    //    // function messager_isIpad() {    //     return messager_isFind('ipad');    // }    //    // function messager_isAndroid() {    //     return !messager_isWindows() && messager_isFind('android');    // }    //    // function messager_isAndroidPhone() {    //     return messager_isAndroid() && messager_isFind('mobile');    // }    //    // function messager_isAndroidTablet() {    //     return messager_isAndroid() && !messager_isFind('mobile');    // }    //    // function messager_isBlackberry() {    //     return messager_isFind('blackberry') || messager_isFind('bb10') || messager_isFind('rim');    // }    //    // function messager_isBlackberryPhone() {    //     return messager_isBlackberry() && !messager_isFind('tablet');    // }    //    // function messager_isBlackberryTablet() {    //     return messager_isBlackberry() && messager_isFind('tablet');    // }    //    // function messager_isWindows() {    //     return messager_isFind('windows');    // }    //    // function messager_isWindowsPhone() {    //     return messager_isWindows() && messager_isFind('phone');    // }    //    // function messager_isWindowsTablet() {    //     return messager_isWindows() && (messager_isFind('touch') && !messager_isWindowsPhone());    // }    //    // function messager_isFxos() {    //     return (messager_isFind('(mobile;') || messager_isFind('(tablet;')) && messager_isFind('; rv:');    // }    //    // function messager_messager_isFxosPhone() {    //     return messager_isFxos() && messager_isFind('mobile');    // }    //    // function messager_messager_isFxosTablet() {    //     return messager_isFxos() && messager_isFind('tablet');    // }    //    // function messager_isMeego() {    //     return messager_isFind('meego');    // }    //    // function messager_isCordova() {    //     return window.cordova && location.protocol === 'file:';    // }    //    // function messager_isNodeWebkit() {    //     return typeof window.process === 'object';    // }    //    // function messager_isMobile() {    //     return messager_isAndroidPhone() || messager_isIphone() || messager_isIpod() || messager_isWindowsPhone() || messager_isBlackberryPhone() || messager_messager_isFxosPhone() || messager_isMeego();    // }    //    // function messager_isTablet() {    //     return messager_isIpad() || messager_isAndroidTablet() || messager_isBlackberryTablet() || messager_isWindowsTablet() || messager_messager_isFxosTablet();    // }    //    // function messager_isDesktop() {    //     return !messager_isTablet() && !messager_isMobile();    // }    // function messager_init() {    //     messager_newStyle = document.createElement('style');    //     // messager_newStyle.id = 'messager_style';    //     // messager_newStyle.appendChild(document.createTextNode('div,a{margin:0;padding:0; border:0;} .messager_root{transform-origin:center;-webkit-transform-origin:center;-moz-transform-origin:center;-o-transform-origin:center;-ms-transform-origin:center;border-radius:50%;position:fixed;bottom:0;right:0;-webkit-transform:scale(1);-ms-transform:scale(1);transform:scale(1);z-index:99999999;}.messager_mes{text-align:left;position:absolute;width:18%;height:100%;margin-left:41%;-webkit-transform-origin: 50% 50%; -ms-transform-origin: 50% 50%; transform-origin: 50% 50%;-webkit-touch-callout: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;-webkit-tap-highlight-color: transparent;}.messager_mes1{-webkit-transform: rotate(252deg); -ms-transform: rotate(252deg); transform: rotate(252deg);}.messager_mes2{-webkit-transform: rotate(294deg); -ms-transform: rotate(294deg); transform: rotate(294deg);}.messager_mes3{-webkit-transform: rotate(336deg); -ms-transform: rotate(336deg); transform: rotate(336deg);}.messager_mes4{-webkit-transform: rotate(378deg); -ms-transform: rotate(378deg); transform: rotate(378deg);}.messager_mes5{-webkit-transform: rotate(180deg); -ms-transform: rotate(180deg); transform: rotate(180deg);}.messager_mes_circle{transform-origin:center;-webkit-transform-origin:center;-moz-transform-origin:center;-o-transform-origin:center;-ms-transform-origin:center;width:100%;height:18%;position:absolute;background-color:#ffff00;border-radius: 50%;top:40%;-ms-transform: all 200ms ease-out;-webkit-transition: all 200ms ease-out; -o-transition: all 200ms ease-out; transition: all 200ms ease-out;opacity:0;}.messager_active .messager_mes_circle{top:5%;opacity:1;}.messager_mes1 .messager_mes_circle{background:url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAMAAAD04JH5AAABs1BMVEUAAABBtOZQr9hBtOZBtOZBtedBtOZBtedBteZBtOdBtOZBtOdDtOZBtOdBtOZBteZBs+VBtOZBtOZBtOZAtOZAtedEvP9BtOdAtOdBtOZBtOZCs+dBtOZBtOdBtOZBtOZBtOZBs+dNsuNBtOZBtOVAtehBs+ZCs+g/uORBtOZBtOZBtOdCtOdBtOdCtOhBtedBtOZAseRBs+U/tOVAtedBtOb////S0te5ub77/v9UvOlCteeV1vGO0/Bnw+tMuei7z9z4/P70+v3j8PfA5vea1/LA2+q40d+yucHm9fzX6fJ0yO1QuedIt+dFtue/z9vO0djJ0Nj9/v/q9vvN7PnI6vjc7PW5z93R0te0ucDt9vve8vva8frS7fmH0O9dv+q72OfEz9nL0dimwtKrusX2+/7v+f3n8/i85faz4fWu3/Wm3PSAze7H4O1vx+xYvOhbtd1ftdyh2vN5y+5jwuu30+Natd6hvs6iusmNxN6dx92yzdysyNfk9PvU7/rE6Pe/5ve04fWx4PXN5O+I0O+Czu+22uxrxexovOJguuJ5wOF4wOFwveGAwd97u9m4yta5ydV2aISdAAAANXRSTlMA7wbE+EiQiEP89PEN07mNGtnQzL8fBOfIqosi492yom4sClJOSzwVCOl9c2lWP6idLzYmXMouYY8AAAXySURBVHjaxdpnXxpBEAbwOYoiiCAqCtiNJjHG1GcPe4rpiRpT7JpiEtNM77338pFznkGQu729O+7w/5I3s/PbYXZYlmxJtTdHEtXhWikIBKXacHUi0tyeoqKIbi+pC0FXyFuyPUpu2uIvqYRAZYnfQ67wtDeFYIrU1O78GvaUboUFW0tayEkdjbDMu4mc0haDLVXOLMFfBduq/IXvfSMKUlFYLbRGylAgX2kr2RZogAMaAnbbTmkZnLGzlWzYFYZjYjYqYXsQDvLtJWviJXBYkqzwJOC4xi1kWnkFXFBdTiZtroIrqjaTKTUNcElljan8K+GahigJlVfBRTFhHXgq4KpqDxlLwGWNcTJSAteVkoG9KIJNxLUriCKQarjnbwxFUeexVQDul0EARdOtO/81oGjCHtKKoIi2kUaLD0UU1H4TKuCiEeRLUB4/XDM0MLMAjQCtVwV39C1f38+uQstL67TBFb2HjjHFMHR0UK4YnNd3YriHqfqho8K1HpRNPmMQena7+BUYeTA8ztbsH4GeRlqzB45auHmV5ToLfSnKKIVzTt06y/Lch67smeSphVMe3jjANE5AX23mRNgEZwzN5yZ/cJqtGh8Ch59WNcEJg9evsKyew8fZf7Pg2UmqLSEUbGhgluU6P3GcZdwAj+Rx6BgYVNptrp4LF8+zNZ/AFXBiEuvtn2HrnR+9eJBl9YIrSSsqgQLbbV76Y6PXWNYx8IVJEQUcaLfZ9PfJo2dYjiUYiBLRdkeSz6Yv75tmuQZgoM12CSzcV9PUpi/vy2tFD2EgQkR1sGwk02616csTV9g6B/rAp44lQXtnjdZBJX35yH623hsYkYhSts4arfHDYyvxNWVxCIZqrB0Eg+pZw01ffjTO8n2BIT8122i3WocvqfF16uIUDHVRxEa71aQ/IXPiszkYS1LC5GjPmCD9yQtMx00YS1C1iY6zpCQvSn/yMNPzAMbqKGyj3WrS58ZnQzAWpFpxuxWnL4/dZrpmIFBGklHyarsVpy+PfWD63osX4OP3nP5ZZujahLzq0nHGMQ8RKoOBO/1zjOv2aXnVaW58dsfuAsRrOHNE/k8Zv3jOQIh8ZoauuXFu+rIyfnEtQaSPJJjRO3CuR5O+Shm/+AYgLsJamHRyXl1DNn1xfPbQxALCAKytYfqInI0/zQxc6YOIT9OKhXvxOZt+ZvziOQchiRKw6LsoftYhCDVQBBadnJRV2fGLaxlCXmqGVersox2/OMOIQBO1w6pnsurPcSbwGmKdlIJVX2XV5akXzNhNiO0mCsGikTF5xZN0+rJxET6AGBF5YdXLzALSi4bbcBJCkq2fZr/kFU/TiqkjjGsGYnW2fpzekVcsplX8bXgHsaS9n+ejsuJoWsXfho8Qa7F3QfF8ZQpJZywuMV0LEPLZvKL5qSzgbyb+0ceY12uJVyFWZ/OS6pTSjV9m4wODr5jGMMS20QqPBKteKH0oG18x9Jbl64dQX6vdi8pnahtQHL2L/wbyT4ZBCFWSysZx8E1pA5n4GYPH1g8jIzCzA6p4Law6LT/Niw8MDXPu6HnKtti/rn8uL+bHV/T3aO7ojXgpIwWrfkxOpafuIUuzDScg1E1rGmHRyYtqfO3n58wPI/UF/Wl1ORtfdxtmIdRV0P+Wv++BY3k6c0dvLES5NsEm3jbcgkgnrVMHBx0aZ70QCLn65/XyHESaKU8jnDQCgXrKl/KhmDpIoxRFVLHBj1h85Rv8jKdrgx8y1ZE+TwxFESwnjpYgiqGDuNpQBKVkIAnXecnQDrisPr6xj1ql8o191uuLbuzDZt8uMqHGtRX4dpMpm71wha9lY5/3SykyzbMDjqsX1L/b04E3TtYEtsJJpWRZ1AvHBLvJhnhnGZwRayV7usNwgK+ZbIs3h1Co6nIqRLQJBantoEIFvLAttI2c0F0BW4Kd5JRdTWWwamsnOalmW72l6N4Oclrcv1OCKdJOf5xc4QlEwhAIJwMeclO0LeKVOJl7I22bqShq/F3JHdWxeikEhKT6WPWOZJe/huz4B/HpmW70G+ggAAAAAElFTkSuQmCC\') center;background-size:101%;-webkit-transform: rotate(-252);-ms-transform: rotate(-252deg);transform: rotate(-252deg);}.messager_active .messager_mes1 .messager_mes_circle:hover{-webkit-animation: anim_size1 3s linear infinite;animation: anim_size1 3s linear infinite;}.messager_mes2 .messager_mes_circle{background:url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAMAAAD04JH5AAABIFBMVEUAAABvP6pyMqpvP6pqOqlvP6pvQKpvP6pvP6pvQKpvP6pvP6pvP6pvP6pvP6pvP6pvP6tuPqluP6pvQKtvP6pvP6pvP6pvP6pvPqxuPKpvP6puP6pwQKttP6pvP6pvPqpvP6pvP6pvP6pvPqpvPqlvP6pvP6r////+/v52SK77+v359/zAq9qbecR+VLPv6vZyQ6zs5vTj2e+miMqBV7Xy7vjf1Oy+p9mDWrf39Pro4PJ6TbFxQav18vnWyefRweTItd+pjMyjhcmVccD9/P7Fst3Uxea5ota2ntSxl9Guks+efcaSbb+MZbvw6/bZzOnDr9y7pNeGXrh8UbLl3fDLuuDd0euXdMKOab2skM708PjNvOKhgciJYbp0Ra2vlNDT7sR1AAAAJnRSTlMA8AT0CMZC5IlIItHMv6qQaxyNTfi52XU4DehTKhXVs6Lcgi5bnUGs+goAAAe8SURBVHjavNVbcoIwGAXgcJU7CkrrXab20BemOKK+MrU80HGccQPd/zK6AGkIkPBtIPnznzMhnVjhOPBceyQpgCKNbNcLxqFFBjFZ+pqEWpLmLydEJNX0IzSIfFMlQsjhTgITaRfKhDfLWKCFhb8iPL1u0ZoWEl6WNjpx+FzBdNCZY5K+Vlv0MuuXBTWYoqep0aOVegwOYr3r+AY4ee/0CG8bcGN3SMJeAUfKnrQj++AskFud74E7r0UQ5jMI4M4Jo7UDIZw1YWLFECSymOaPIEy8Zti/A4HsxhzIMwjlquL7R7eVCY0P4QxCsccAQsr/o2AAiwn5h2pjEJrcOwBZfkuP1eNSlkVRlpdHdUxveYaeMdDBIE+r4nz/SGp8389FleZgoNcuIG6cOy1OSaNTkWZosKlbQgC67OuQMPr8+QXdC3mymoLqekhaOFxBpTw34Y8Su+9NGojjAF62GE2Mz9EYTdSY+P1ey6hQKJSnMocwECcbg43BNt//u9De6Fq43RU+f/AH0Ke738NdzSXY7gnuRJzaMHmu7H9g4k6pcPyGVx3/V/UavkOF5+4Uh8YeePKHibw3G5S7gY01dtAtD2ZePp0VI2Mx2Nh/wuCmzhURloMWDFpBORRcESMYvLfSTDUw8LnSv8EWbvpcEV3ovd22Btlx+NePsKWjeMic88whyE6BWZxZAbY2d+KKAL3PqWUo9Mq8U21iB5M4Gk+hlyxRn0DL9ilNm9hJxaEkDJPw1VrZ+wCtY0q+q7nOYW9QnregmgtKF9D6EHeEN9Cy8+ZwHjLSXhagGPCOYQjiFzhfDPFM6RAp3dNhMWmQw4NOieRUTZESpR60vq36cA5afUbyqadwOyT7LaRVfpXIsYt1J5R8aOX2stpAq87ILHWtEiNnyV9a8vPIZ/sS675TKmY1hBfQCiiNEHP9zSrrOY3+MACaHTpDrKlRuoTWayvyDlrXlFzEQq7UK7jTc0iKToDWKTlE2pzSAbQ+yffv0DtjZIHYDe+FiFWuZw6dK8CjOEGayEpEvMrYjHQYGSP2g4kjJJo9wSqK/kbEtTPL8UdzCGC6UU4LTCxsSHZhXpT5GmIiOEBKg5E8zEHwCHp1Rv4idrtgYnQ/TfUzG7XoiyXrahIL87Jkbx9aTUoFpTJLZUiTpUfmXXhswxYsq2ngQitn7oQTSqnIch1K69Xp8icbcAULqNJTO2nXGIVvoPebUgWJJVfav5EYkQGmHGPEvHr8D5jawUvojSjZam7zT7AR7zUMuECRTP3gUjqG3kvrNbJakYO0CyUJI1WGOKEA2rxCIntR8sR6nrkaqj80LQWsueIBiuQtSjxUbuDQuEF5Br0rRtpYEz540iIAQRsex0opXELvmfUJer8e6qcTR+ZAE4rjGtCnp9xAB3pPrceZI7DAupopsgb0dhqBx1ZulxiQbNnn8xU8pDhwd4qBnLW/UxZIXflgYQuZsrNg38KWdUCdhBBZzimdweAfqfa/mzQUxQEcZAmJjoREzf4wUaPJ99y20AIyOlpYUyljmaPRMEAN+v6PMUYJveGM09vs8wIcaO/5danAMBPqOgOx0+CZUFCpmdYC3eLyqFdcRy0LjEEtqFWqMKiGzEbRk8DFTouI7PhEQ0V98SWsQ+DQkztwMe0kSyufHgYWa+p3IB7DNzDpiLg/ah/CahYpythroKAj4omoAUEkvO7thLgWeE+YQtAQixF8abaZO8SteFc8gOC9Xo7luYCzAuJieS7gTWETxeewjRNuFR2bsgZyDcFnsSXDyClI5ldsgThn43EHggvWlPLir9derj0m3YD9fH8h+VoRMxG+sXLCzWw6cKzjQ0hTSPLBRNyQJPcQjGZjythzvZnILCCoSqOZnk3TEKI4pa1uX3sASf5M5IXtB0jC/ZfrLSD7t7xuI+c6tKNcSL7I47k+EA9dlOAOKbOE6LW8oNArCtm/UYQnyRSidyaXZaFHGTWDoV+KMkkfonO2pBLXruRNYGDi0Z5qQ9YsWNPxvYjnWxBd+Z4+wBc4yxeVou+KDnw8qzOP/SgYKsqpGAU+aqta2dp+tuJbPW/rcuzYihj7HjC8vHtVR5FFlweA/x6d1nVR6Iyt6wWt5DiATpe4MiemwS4sROG1ygOQP1/dhGDEO5tPMGH5wzyAUUAnpD9DmKizS6tid4cARg/E2emqtbFgqFnRnJcNoEdk94LA2+oGD6toevujj1JqFd3bkgEMWI9Q2oV8dSsHsCJKJniRqvnlNQ/gRkzz5d8A+SDwACIitcHL1Pl/6B6Lt3vdBmEoDMPHNjYQJRIgqwYCaUTUr3M7dO3aThk79v7vohVLlvzgP/xcgadjWX6Pxl2XA3w+umYsZ8DycTjfi2/n+fnj6dklYrn8If3Ck85cM57z678v+KrcQ6bv948f+JKJUy7R0Q2DwBpaummPFRR0R4PoZOKkM+dpo1bWpc16RZ02bNYnWmAT7QS6pUVGiSjEkDbvZ3XaBYd8JAu8QGCSkx3VI6SJrNUSwQhFDviEQLYZuVEHBKArcsYrBl+7jnzUR3jpW/KldnAmDIWgHAejmCiU0xHWekMh1SaHDakoNF6+MCzzZDhFwcvmgAf01mQU07hvJMN1TBYDrWJTVsW8/s8ANq//F1XZkos/cL+2abdBNoUAAAAASUVORK5CYII=\') center;background-size:101%;-webkit-transform: rotate(-294deg);-ms-transform: rotate(-294deg);transform: rotate(-294deg);}.messager_active .messager_mes2 .messager_mes_circle:hover{-webkit-animation: anim_size2 3s linear infinite; animation: anim_size2 3s linear infinite;}.messager_mes3 .messager_mes_circle{background:url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB4CAMAAAAOusbgAAABKVBMVEUAAAB1tzt1tzs30wB1tzt2uDx1tzt1tzt0tzp2uDp1tjt1uDt1uDt1tzt1tzt1tzt1tzt1tzt1tzp1tzt3uzN2tzt0tzp1uDp1tkF1uDt1uDt2uDt0tzt1tztvxTR1tzt1tzt1tzp1tzp1tzt0uDt0tTp1tzt1tzt1tjp2tzt1tzt1tzp1tzp1tzx2uDt1tzv////9/v36/fd2uDz4+/WAvUt4uT55uUHx+Ou/3qSOxF6GwFN9u0b8/vve7tCiznqYymz2+vLz+e7T6cDR572VyGjn893N5bjI47G12Zau1YyfzXft9uTh8NTZ68i73J+s1Inv9+jq9OHk8tmy15GSxmSKwlnG4a2o0oSl0X+Ev1Db7czC36iczHOay3DE4KuJwVfV6sS425o17DMqAAAAL3RSTlMA/O0B4xTp9DYtZfBWrjreyMS9ewXOShwHqaKbTSgJ+NKYjF1EH5K6s4N1bVNAbPJFspsAAAaxSURBVGjexdtnW+JAEADgTUAQQVHRO3u93mYJTUSkCIKo2JWz6///EVdM3ADZmQWTh/fjHbjJlpnZTWA9WwpFYnOTK349CBDU/SuTc7FIaIZ5yhf6PhrVwIEWHf21yLwxNDIbAFRgdmSIuWxmYVYDBdrn9SXmnuH5MCgLrw4zd4x9gR5NLLjQ7Idx6MN0xPfGu52GPk2PvWUif9Kgf3P9TnHfegDeRP/eV39/nIA3m/jIeraggwvCP1hvpr5q4I5PU6wH78fBNePvmbJFP7jIH1KOkAFwlT6mGKuC4LLgO6ZgXQPXaRFGeqeBBzTynoeD4IllYpxDOnhEX0TDpB8840fW89Q4eGhcHsPWwFNr0gkNHluQBGj1iZXe3G8cXdXr9aPj/c00qNIds6RvQrHR4u2hwW2M7eydYuMTTpXBCKgo1krcQal+nwAFIw71VQBImcYul9ptZYCkd9dh80BJtA44aqNF3/VqVx0LlM1dTjq8AII21jGzpqlePopzBfEjapqNd5R2gLs+5J2SGwcHG0neaTsHuPY8RSylapnblSuNagr+S1WPaxvt/3nRwy1/ANSdYV85V9XOOXRxZb8w4xhQP5kwCZhC3jZzz7ccp8D5CReygPlsy/6AuRftGs8Z6ex7tnXLM2CG1dbwZlJx4uS2RcstpbU8g+33UydiqSSICCOWXPwRC1/WGVEE+2NP3JT/DQI5G8rYerY2VNhRQ+N1eIug4JxbdkBu1EwPGjJuhnW/d6Bkj1uQ5awNkfmwwk2/QVH9deGR2XEWyb7c9GBVAXuHNSImvuaSc6KvfUgithbIWcZcrDv/Ei+eB7as0Skh+/V/BWcIpC6sxWGOV2JHpdt/c1MDjyHfQWqHv7iCF1kz6wJulx7lb38bHpXHjri5klJmDLPiQ5UoGbjpEh3kKLEoxcxqclOFumXyc1HGluSr+NAc4ZzoAPu/0IshKV/JMyxE9vSNVQ3wV7eAs/KK/AJDSKDeN79t5fU7W1YGXM383BESrmMgc2t++1p0oOUEcBecmv8xNkdFj1MwXYqGG0DIU4M8h1Q9Zh1VB1PaeJ3VCSAcmLMQZCbZijT0ma3sgaVpjfAW4MRHUyAxzfxUGNjvys1XQMqKLzvzszBIVK282hX+K0A6pjKUzpalxXR33Hswi4JNoBTEODkLMo36bs4WUpLmRCcHuUotZI1pVPy4dChsbjKAu6dKe40t02MsJLatCpu45xbd1WFqVt+DzWPSajmF13xUqabLl1NOhGqbfStFGZugUCRKP+SXBRARqB4k9Wscq4DOzA9l5AFkkvryNrS76toUVjeM0+y1U140kC3jHJXbjI6rToiWz/5PseJL75ee9sW6Mz9wgCSJmLzykYS9xA235I/+j7olbhUIz+Q+JsYiZM1WB4tYVKLpJLcrtCUnvo8UAiEyt5VEX4txlqi1JbY4SIWwYu9BLKhODcnhU6ut8tkFqSHGomSxeOqQ9y/LvIOYTOm8uGIJDS3oE6di5LokKrxLPte2YTRAyo9vYRpWlyXAweUZbxd/2WFcx+m9+Si+acuU8L1I4YDbGMX2qBVHwvm6tU3Fd23JBEg87pR4R9rYUzmMWCI25qdW1ERsFbK12m0hAx07u/gWMsTEUcSW2LGoujZUjvdWicOXosiqilIlpV3OR/S4SQzXIyjKiQCKpeuAdcBGzK1SAtQUDW7ZA8Qn6kjRPE1sgkBW8SpfGWKmVcmAdU6TYhZZmpvmZZpBFrFCHRvf2SJmulA5iXMef7qWjO4NF07SgIlQB+VH1llLo2lLCWf3DmW0eGRBb+p0JvwEJ0/cWfLmd8YWV1vN9mLgLA2ob+TDkDKXMw4Om5Vac/vE4B12ABf0UU9wc7wP8WMgfCMfeBV4705TQAizdsMasixVJY+BNEI/1Lzp+rtnBtpsNgGkKP0YN1HiNuVmYwsAzjekj1LPQcUi/eD68XW+nFQKYoVc1h3aLtevQck8/qhe5MT8ab3YnaZbtd1S/iXh58u74rJIus/x5YRAe1fvHGYv8SSYhh6NDeh1jK8DegFlnMlMTYCHgkvIS4J+8IwWYojFAHjl3WBeJIMR8lXBZfBCjJEiGrhvbTCvR0JsMC+EwshgXoHVFgbz0m84NJjXnKeXWG8+BLzJC7T3LgRufXggL+/DrG8gP1eILrL+Dfc9vYP44qWNTfbV7JpvED/CCcd8zBXDqzqoW4m4+0MrtXQZmB9y/6dlo2HA+ec/Mk9MjX2T/JgONP/o+hTz1Ezo02RUX9Ze2tOCevTzWqT3/v0D7A9EIAqLTIQAAAAASUVORK5CYII=\') center;background-size:101%;-webkit-transform: rotate(-336deg);-ms-transform: rotate(-336deg);transform: rotate(-336deg);}.messager_active .messager_mes3 .messager_mes_circle:hover{-webkit-animation: anim_size3 3s linear infinite; animation: anim_size3 3s linear infinite;}.messager_mes4 .messager_mes_circle{background:url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAMAAAD04JH5AAAC/VBMVEUAAADrlyvYcGPmkEKWC92bDtL4rg78tAWvM6nfhEP4rg+1PZ2TBObJYXCbEtOnJbmUBuP7sgeSA+eiHcWXDN33qxH9tQbdf0rCU3/nkTH0pxX8tgTKX3CTBOXtmyXwoB7LYm+pJ7iSBeSRAem+S4rRa2D1qBP8tQPRbF/0phfbe0z2qhPBUoP3rQuTBeP8tQS2PpuUBOOZEdSrK7Lhhz+hG8iuMarhhz+/TYiZDtjGWXiXCd/XdVPYeFLAT4SnJrnOZ2bnjzWeFNC5Q5W0O57ljDbegkPGV3jJX3H////df0regUfbfE2/TIrmjzW2PpzYdlXokTKvMazLYW/SbWCrK7WsLbLFV3zHWXnWdFitL6/BUIXZeFLaelCwNKnEVX7ATof4rBD2qRSnJL2cEdWoJrrjijzplC/1pxfCUoK1PJ+3QJq5Q5WxNqejHcapKLjNZWvVcVvJXnTfg0XIXHbMY227RZO8R5DiiD7hh0C0OqGzOaPKX3HOZmnkjDnUb13xoR64QZiyN6WeFdDwoCDzoxvQamX5rw3zpRn8swihG8nDVIHljTfghUKaD9ifF86ZDdq+So2dFNGkH8Tqli3tmybunSTvniKlIMLHW3fsmSmYDNy9SY6XCt6mIsCgGcv6sQrPaWbPZ2fRa2OdE9PRbGKgGMyWB+L9tQWUBeXrmCqWCeCTA+fghEOVBuP+/PyTAuj78/j11sL32r767vDnv97juOXlvOL89PL45+jrx9j+twPwzsjz08bvzc/x1eDpw97029j++ff26PXuztzy3fPdn8LHYpfQcoDXfnToxvDhtev75cjnusjvxbXntbXos6jt0O3Pi+LisdS8Ws/z1c3hqsfTiLvYjaa/T5LKZIP2xHrKYnrxoyb98eHTjdDqv8OsMcK0Q7zip7a/UqLfk4DRbm3rmzfz3OfbpebFcNykI8/JcsD53rjenKz31qnOdqbemqP2zpTchWPytF7vpkL769jqw9LkpprYh5Hmpo3MbI29VLXJbKzbgVkR+Hx8AAAASXRSTlMA/gUKRwhGjUpIGpAmGO3qtraPjlVQJyUi7OzX1MzJjkwiGdvb2dLLsaeMYznz8eDd2dTR0cO9u7Snjorw0syoi4tsYfClYvfzkAtDFQAADE1JREFUeNq8mGlIVFEUxx82QpGpqFBBQrZAREible0LFa+yRC1tcYEWaDG1vaykAj+4tPlFKQvTFMkcB8xSKi11RhQJF9wQzOWDG6GfIiroPe+5c+e+d57jLHa+qYzvN/9z/ud/7xPsKj/dTu/AgNXu7k+f5uW5u6/2DNy0U+cm/Jfy8/EOyEhJeZn/6NGDB9LzT5069fDh48fPnmVn+/t6+SwSprNcZ3p7ZGZkXLx4USIABCAgCG8KClZ56VyFaSmXmds8Tp588SJzAiFFLQIQFBf6B04Dg5+3R9zp06eBgImgInhTUFxcWOi/ybkTMXPd4cOH4wjBlEQoLCry1Dnv8WuOHTlyBBBO8iLkYyIQghJfHyc9PiTkGCMgCJmqWcyTCZgIgKBzvPfroqJCJAJAiMNE0G5DSYmnm2O+m30/NjZKRjiGioAbkiFIBEVerg6ovzLxPhBoi5BiTYTFOru//rlbtxIBIYQTwQZDSgQl9omwYuWhc4yAIQCBTSKssmMSdt07f+gQRYhlIthlyJIiWx3pMvvCvXvnJQReBPsNWeLlIthQMzZcu0AIAEEmiHXQkDYMwpwl169JBLwIDhvSd8pRPW/J8+sSASdCohMMuXjRVJ//5IlEcB0IQARnGHKx29SeHxQkEUgIrA3OMiSiAdL/mJggGYFrg7MMaZ1gxtbjx4GAiuBUQ/q6WvH/hrNnZQIZAQicbEjPyffBxuhUmeA4a4PTDek16f4Nj45OTcVEGGhvaao2iFMqQ3X90PCIpgg+k+TP3nCJQC1CZ3ulaHPVD4/ghvR30xzABRER4eGcCDJBp9Eg2lXVzfmoCKtctQbgSlaEjAAEIMJYuWh31baiImiMwcJLV65kZVERzhIRgtpEh6oZNaQOb8DtSzICL0KF6GA1jCBtQJuwPfS2TAAiwCxaDp9+sOYdq/esyiyroaGhvlZvOYwjiCE3CaqaezU0lCKYZ7GCWatlrHPqCdnbOmRgGiCGzFY7YVn81auMgIhg7v9XY6etCdnbbJahGUlIT9UE3omXCHgROkSoSlOMHQnZ1yRCtSKrWTmHC17dIQiMoJv67ye3lWxIyAbqRiQhfRUCJOeYCUJhFvvp88GQdiQkJWhGEpLfyEtzk3NyeBG6P5APD6am2p+Q0IVqJCFXcwKEvc5NTuYJfsD8/Y52ICH7YBKHkYTUWVogTCLI5dpwG1ZAfziekNqG7Otpqi1rBRGaYRkgxwQLI8xNSgoLU4hQB/7vikATUtuQfdWiXD1EhF7YB73IkdWNLcGEJAmBJxgnH2zMUiSkVUM2Ue8RgiHoAXJkNa9Dl80JCQlKEb6TD/7iw8G6If+IUGVkElrJT0PIud2dJsKso0ePqgi+kP3fzSekdUOOmqOYzGKvngwBdmTV0REMlgkoAhiyVJSrXJGQ1g1pBmgCQ9YSI2JH1kDI4c3BwcEqEb6KctUgCUlFGDNW1Rr0ekNtlfEvEyGRplAPGLKeDDN2ZIUezDpxghEkUUOS//KZT0gmgqmtlDt9tQ1QQ/ZAB6JgJ5SRn9FzO+nB8sgTgGA5iwDAJyQVwdSoFxWlbxkAEXpkDar6YC9SAPQO6T0BsCUyMlIlghkAOyZ0GNDTeDttw+joH5aQAIDeISfW8ZwDBw5EEhEsZxEA4tXHhNRGUaNaziMJCQAQDgoR5Kvinn37gICbRQBQJKRE0FUjalYVkpDvyZ/w65OPPAL7JAKCEMxEAICP6mOC5fNLKysqKks5AlVCAgB+h5SHYP1+IOBFAIAcJQHTv9xoIoY0GatZF1SrGQDwO2SABPB2/36CwM8iALBwIAjj5i/fYbmV2s0ytCsTEgDwi7S7lISXLwMBiACGBADFMaHuAzynpovfSibaGcOAIiEBQOOljp8wK/0tIPAiAACf0aHf6TFNlZCd72gTFOFAAfCXOjphz830dLUIZgA+pOv08P2z1AnZCRroB/iEBACNlzo7hR03bt5kIrA2UACO4Bv0vwtLSBOspzY+ISkA/lLHW9h9QyJQiWAG4BIyHkZtHE/IdsgFPiGhNRpvtrYJ688QAkkErg0AwCXkL/CfVkKCG/9yxwQKgL/UCRDW3j1DEPhZpABcQkIH+jUSMsZI/m7kjgkAoPGWdY0w/y4QKNoAAFxCfia/rEMTUkIwwTrkjqwAoHGH9BDmp0kEiAgAwCVkORlBLCEJAhnDQe60RgHwO6SHkHYwLQ0TAQC4hCRb6AuSkEBQSXYRd2QFAI07ZJxwUCpMBPKxT1xC6vGEZIYkq0DPHVkBQOMOGfevN7P5aSKKovilTVosMaaLFi2m1YUgItFEo8b4GTXx7ezChStDN7LU/8BFjbIXja6Mq4aNibKYKoJlRZMK3ZAY+QiJAVaC8hXExDh0Ttt5792hzLR6lnQxP859d859dyiZNAkYEwAgJSQA9ISECWUAaWQFAH+HvG06kEwmQSA1JACkhEQJpISUGhIlkG4OnwDgcIekA/eSigkWAQCkhMQhNBvyNQiUs4hDKM3tAHBY6uwzAe7d48oAACkhJ60/5vFq1srw2/r9vXR9AgC/1DEB4k9LBEn1LIqS3koJWbT+WEQ4aCZ8w4tIukMCwGGpc4riTU+fgkAyAQBSQs7jVaxtE0CAqPgh3SEB4LDUOUOdAyYBY0IZQBpZ8YRNhQANuYSslO+QAHBY6lymxMuBAc4EAEgJeWvc+quRR0JKJoyV41i+Q2LX6LDUaaGu/pcvqyZUCQAgDyqrGEhyCAc7wfQIBpLf8h0SAA7bhGsU6C8RaCYAQJnWYIEYQkLaGnIYP31WpjUAOCx1mqn12bP+qglVAgAog8qqIeBBXjZhLIcfjK/KmAAAh6XOYaJ+EChnEQDqmLAlIGPTvtRZMgT0RR0TAMDvM64TUfz5cyBIZRAlvdOmtfHqxaSYtxDyE9XL0WctIQHAL3XOEFEiLRMAAQD6yDopqjJyk5M5Q1Q1rCckAPilTgsRRdLpNGMCAPRZ6Q8IOA0zCQkAfqnTTEShhw/TjAkA4EZWVEHX3H0mIQHAb1n3kqn2bYJ0hQAmAIAdWbcMwcj4ySYkANjN1knaVuLRI8YEAPAj659xfUUzt8APKgBgt6wttK3AE44AAAgHzYTVcWlJNTiBjNZNAAC7ZW221nSxbQIVwVrTFbhpDQ05X/yYNd68MbJDxfnyW4kxAVMSt2W9jg/Znb1PdBNmxbY22JGVX+qAQB1ZMUZxW9YWshTprRBUEQpWZU0AZxNAIG1ZVROmrdMywm1ZmwHgi/X2aiYsi5LWuJGVX+rwZfiCNySz8T/pIyiRAoGtIadEScvqrKSEg75lVUbWOUQEs2puobKiqVRKNWEdX2wW9ZGVX+rwJoyNipK+Mp899lNFYYagIEpa4UZWZxNUAlyoR5jPHueoqkBPj4kAAiBMwYJ1ENQw4Q5rQnmns8R89jhONrWDwGbCDN63G4tISA8NuZDFe2pa/+xxieyK9JQIUvazCAvEdySkh4Ysj2nfmM8eh4gUC1QTZmbLBItISJcNuVB+fpb57HGJZAUeP9YI1gS0sQ4TXDVkPiugX8w+4zgpCpsEKsJKJepWYMLuGzI/UQnMCf0qf/ccqYo+NqUSfBdljS6vLbpoyPmh0eqYxI0J+0lT8FWJQGrImYKwabbwTtJbuz5WNJnL2qeF3AIzJpwnXf62V680E2bggXcNLzAJedBHjAJ9IJAackXUpSKXkC+OE6tgn4mgncW1WeFZ2Xk2IVEApggmAVOGKUN40mDxAZuQKACjaLdJABNkhIJwrdymQ0Le3E+O6urrgwlqQ65PLRdm0Vq1NDqYG99adUzIQ7SDghkQKA2pTc3eE/IK7SRfOMOboBJ4TsijPtpR/g6VIKWNrFjqeErIg36qoVBbpoLQU8ME9wl5ZC/VVOhEZldlaPKQkHh+DUVNAuss1jLBbUIeQQPWrsKHTH1nkTeB/f95gg6ToOENeZF9Pi9/+ANMaFxDHvWTC/mCIGhYQx7zkTt1ZUyChjXkhT3kWtG23ZahCQTODXmxlTzIb5ahMQ0J+90rcKIRZ/E07PdmQqbuhjzmp3oUrbMhz7ZSvQp0eG9IuF+vIh3eGrIhj4cLYfcNeXYPNVLR4Ak3DXngais1Wr5IZ/fuzuKBG3t89E/kDwTbajVk/Cqe/q8UigQ7unkTmuKJSIj+i0KBrmBnuD0W6+598jAWa493JroC3p79FyBR1oItpiUQAAAAAElFTkSuQmCC\') center;background-size:101%;-webkit-transform: rotate(-378deg);-ms-transform: rotate(-378deg);transform: rotate(-378deg);}.messager_active .messager_mes4 .messager_mes_circle:hover{-webkit-animation: anim_size4 3s linear infinite; animation: anim_size4 3s linear infinite;}.messager_mes5 .messager_mes_circle{background:url(\'\') center;background-size:101%;-webkit-transform: rotate(-180deg);-ms-transform: rotate(-180deg);transform: rotate(-180deg);}.messager_active .messager_mes5 .messager_mes_circle:hover{-webkit-animation: anim_size5 3s linear infinite; animation: anim_size5 3s linear infinite;}.messager_center_big{transform-origin:center;-webkit-transform-origin:center;-moz-transform-origin:center;-o-transform-origin:center;-ms-transform-origin:center;position:absolute;background-color:rgba(255, 206, 0, 0.3);border-radius: 50%;width:30%;height:30%;margin-left:35%;margin-top:35%;-ms-transform: all 200ms ease-out;-webkit-transition: all 200ms ease-out; -o-transition: all 200ms ease-out; transition: all 200ms ease-out;}.messager_active .messager_center_big{width:100%;height:100%;margin-left:0%;margin-top:0%;}.messager_center{left:0;transform-origin:center;-webkit-transform-origin:center;-moz-transform-origin:center;-o-transform-origin:center;-ms-transform-origin:center;cursor:pointer;position:absolute;background:#ffce00 url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAMAAABrrFhUAAAAb1BMVEUAAAD///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8v0wLRAAAAJHRSTlMA9OgnHxK10jgK2oAwUOGOZe5dQhjHbJe9qHJ3y1etnEjBoYjg4hSaAAAI1klEQVR42uzcC5KiMBAA0M6PED7yE1RE1LHvf8Yty50a18URA2JCfDfQCp1Opzvw8fHx8fExPSU454yxiDHO+VKAExSP/N02+fKOjVxQSjNCkJCMUhrI0tuswvTgs3n+FyI61PujpPhQFjTeKfe5grkQfrovF/gkKr3wwMB2LE6OC9RGZFv71n4SPE7KDIcL2sq373uI6nWG45H7mIM1VJFIHB31UjtCgp8E+CLES01fB1Eo8aXoJjY3KIqdhxMIThGYiIUBTsXbGbctFC3BKQVbk6KB2h1xcvRkyqagKolvQfYmBAOVBvg+X2//C3KJb0VWDN4obvDtSMLhTSIPjUBrBW+wTAiaQsYwuYqiSVoGk4rWaJhsq2AyKjRn9f84+jCRwoDY3+mkYAIqRGM1PnSY+9d/jdTwYmmGZvM4vJD4QuPRGF4mkmiDEF4kN335f2uX8AoJWiPwYXSiRYuQHYyMlWiXGkblL9A2KxjRzsTc/xFPwVhytNJawDgqtFTJYQxbtJZkMJzBh7/HAub270cMmLvr/0JyN+Pfj2YJ+lKcgVKArhhnwQNNvo35X5cv0MLsy//vOYEGYUf5p58KnmfIzedIDvCsE84KZW4cAO8rFTwjsqX+2d/e2QCoEwj3OEMkcjcAXDQK+mFmNX+MJ4F+jL7/HSR2owRwXyDgMTaXI1CXlXMp8K3CjRrIfVLB7/hcd4BvoYsp0BPpkI+z1zqaAvQrDezQAQ3cpQJ0QQX31OiEhYBuYj5l4N/Vbi+A8xJwewEg1q6dAnstAeHGFnBRuVMH638msq0TcuzaUIFOWcMtq1qBR+C7VAjrsp9XM9jzqIB/zPEu7He5yyHwbO1WJex/hMEPMfdSaJdwfv1w+pUhC8YBXyBy8SB8rXZ5Dzhb2zgROCbC3c2CLnJXzwHfvlwshVyTyuVN8Cxy6T6oSwpnETpr43YIQJQuZwFnGXelJ+Cewt2DwEXtdgxE3LhaC/jWuHQpfu+WdIUuY3NvjX2kANXgADLZ5nG6XUnUQLxTncdpuApQQ+adql1chS3FAfJB86EbX8CFKDx8Eg0Z/LWM1/ikxZbBX7wKUFsIBUFNxwNci0t8xobBFZXTAU/pipCgpr3+LrhZwr+4h72REG74R+wtS+HGjqIeD1L9FOKW8IZ0KbFyyDtZRaZbGD2N+EYPL4cMMfp0SKdnTlBHo1kOohF0KQaN7lSD3kNYoY4A1qMOoLU9955O6oh9+GMO+y2g0bxZ7eYPGltJdfv99ZcABTnqqxxKDplf5Fm/Ol63A2rIYDHu4E0yaHKr7VnEuaV/x0/+kHcnaGoCQRSAqxf2XUBERUXr/mdMJgn51MERepkQ6j8Ctr1BvQKOChKdorNC6jy+MIBXeqUHwNSmAI1xyCud3K7ecMEXoNkHIJjOb7jVqv1slvAA/CmXEDplyyfTI6BABZd/Nwd4gdGSNwap2cjWSGknM2h1ZhAnVVoGQzMnoYGrs4g6XGf0+d+4EeKVTu29q7WVaYxGP6bQo4qDVvzSRadyP5UwqgrVDkMtqkilzoHE1Urvy0xmf3qQmUyoO+E0OWjcJhQXpduEcR7sUc1eJ3+sSOCT4KSTCyaPqKSGDtWwLTybcTXJE53mFbUPT8QO1bgat8LnCu7JFmcotoFG3zLewYMkRUUNxBxVhXkFg+qQ4jy7JICBuHGcxy3hr7hFZQe93LSw2QghhcjPodJrpURIKeK90ssdN/KFlMKPXIbqOu0PRBjjjKEqVnCGyhjnDPX4lL8S/CAI1ovd4xXpr+QQPRrJOV9fr1QUC6YGB3pl449KojWDg0ISyI/7ikclP+yVK+WiuQ85hQzJr/jEApSepQ6ZEMFxLa0QuS++VGmRpEKSylH8rKcTJTvuQCVM+ZWYTJry+xftkmL5dEYnUHxcTC5P91FPNU5z9AUtwdIpXpELFX90pR0oiViSjhRF9Kjmig+2q+uvqx8sLNfXX23aV24U86Tu8zRJHggiANJDgEv4ifAskAGQHgKFBCA9BKLV9tqfJnSIt5nZAO1GQzuq3SYHPtBuNnaGP4guhU97IHq9VnJ464IrdiLbdnrKH2BQrfdPsIGfCP8JWpjohquUVjCOStOlDiYTqzwWCgDaDfhL+InyNNDBXzRbkO9hQHQ3kMEs/upuyVuYYM29d3bwiFwnfg/GkbkjTR14b80fzjAB06y2BVUJb627E+cG5gvWtCGKgPgTaIH4E6hhntUVlAxvBcmuhq/XQSpvS0qYb1WlhVtQlqzibHgGdX6I3+iYNTX+sohl4BfZ43dhG0v3kqkDGoIGFWhsWS8pmhaDlpyhAvVze9WiYR3o8T1UoDFV5QUadQNNzhXtax5z8kxyQVvO0bbjU0rhYmbB34SLth3s/e98MODA0LIt3HMyXMJeUCH+0djVRRKiISf48B/MBK6Ee06DZoQBmCGvaBdPngfBIrZCdy412pUFNmaCHIwJtilaVccWBkELBlUZQwXKPcWcbEGTwG+iYWhTK+HBxVvGTuBOfEabuPFBEIFp8ZWhRScJD0pPd6Ntnsg4KlAdBLelLIR3ZJSiPSdhchAcwAon79EavoUHQcRRWQ22+A1HW1xhbAVmAqyp8h3Dgd1BAPFJ/URokzjUaMfON7QZ78GyOKoZmhdG8KyrF7EXGiFyl6NB3N3HMCbpFW9d7ZNJdmRogtckEl5KeuXqaftE0hw5auDHax7DG2XLlrEVGCfLfesVOFtxbLelhEnELdU6Eton/DxzPY5TsNTbXfelhDmqba3dM9Q+GZeb6OzWXsjZ52YjaXh0m0Pni8r+PmwH/1TgSBH75SVJus2mS0rfj4WUjqO/D+sXtBL+aN/ucRiEYSgAm9DGFDsTUSgtlSLh+5+xGwPib4sU+zuDLb/Brwy+mcM81ItplmsD1IwJi+fh0roFr74wqscf7057pAo8wohyYAQlOB0MQgY1Yl7eTrZ6FUuwisPX93rCwL5nlyZsZEWgUZvJY6PmFu57tYGm2YkE0CzyL4ExxhjF/nc6MKl1JJmqAAAAAElFTkSuQmCC\') center no-repeat;background-size:50%;background-size: 100%;background-position: 0 0;background-image: url(/img/manager.jpg);border-radius: 50%;width:30%;height:30%;margin-left:35% !important;margin-top:35% !important;-webkit-touch-callout: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;-webkit-tap-highlight-color: transparent;-ms-transform: all 200ms ease-out;-webkit-transition: all 200ms ease-out; -o-transition: all 200ms ease-out; transition: all 200ms ease-out; -webkit-animation: anim_btn 3s linear infinite; animation: anim_btn 3s linear infinite; -webkit-transform: rotate(0deg); -ms-transform: rotate(0deg); transform: rotate(0deg);}.messager_active .messager_center{background-color:#ffce00;background-image:url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEABAMAAACuXLVVAAAAHlBMVEUAAAD///////////////////////////////////8kfJuVAAAACXRSTlMAjYWECsO9DGd4+BfMAAAClElEQVR42uzXMU4CQBhEYVwtKG09wh7BzsoreAY7j8AVNLH4b0tNXjeQF0jm9Tu7+SAkHFprrbXWWmuttdZaa6211lq7/15O+dnjx+H6Pn/zs/vrBgDf85qeXfP/cz3ATEywZ0AQAExKsGZAkADEBHsGBAlASrBmQJAAxAR7BgQJQEqwZkCQAMQEewYEMQAJGAFAkAOQgBEABDEACRgBQJADkIARAAQJAAgCgJjgOBMTvM1Fp/SnNCVYwduDmfTp+Y4MwCEbgEsyAKdsAG7JAByzAbgmA3DOBuCeDMBBG4CLMgAnbQBuygActQG4KgNw1gbgrgzAYRuAyzIAp20AbssAHLcBuC4DcN4G4L4MwAtsAN4QAuQ944oMIO8dd6gAJLABSCADkMAGIIEMQAIbgAQyAAlsABLIACSwAUggA5DABiBBCJD3NBf9yQAkkAH4LRAAQCADkMAGIIEMQAIbgAQyAAlsABLIACSwAUggA5DABiCBDEACG4AEAJDbeIDb0j8CArgEBJAJCOASEEAmIIBLQACZgAAuAQFkAgK4BASQCQjgEhDAJyBATvDwf8/P7dyxbQRBEMRAQ1Ep/8Tki560z8YAZAIHlHnYnt8f/JIJ+EPk2yWguEtAAJmAAC4BAWQCArgEBJAJCOASEEAmIIBLQACZgAAuAQFkAgK4BASQCQjgEhBAJiCAS0AAmYAALgEBZAICuAQEkAkI4BIQQCYggEtAgD8SXH3YPH/a/f/H7cef9z8YONyeeLwYuZye+TwZOl2eej0au92d+z0bPF6dfL4dvR6c/c6Hz/Pp9378Pp//7w8gzE9A7I9gzM+A7A+hzE/B7I/hzM8B7Q8izU9C7Y9iVVVVVVVVVVVVVVVVVX24H5TUvZ8iia7iAAAAAElFTkSuQmCC\');background-position:center;background-repeat:no-repeat;background-size:40%;-webkit-transform: rotate(360deg); -ms-transform: rotate(360deg); transform: rotate(360deg);-webkit-animation: none; animation: none;}@-webkit-keyframes anim_size0{0%{-webkit-transform: scale(1.0); transform: scale(1.0);}5%{-webkit-transform: scale(1.1); transform: scale(1.1);}10%{-webkit-transform: scale(1.0); transform: scale(1.0);}}@keyframes anim_size0{0%{-webkit-transform: scale(1.0); transform: scale(1.0);}5%{-webkit-transform: scale(1.1); transform: scale(1.1);}10%{-webkit-transform: scale(1.0); transform: scale(1.0);}}@-webkit-keyframes anim_size1{0%{-webkit-transform: rotate(-252deg) scale(1.0); transform: rotate(-252deg) scale(1.0);}5%{-webkit-transform: rotate(-252deg) scale(1.1); transform: rotate(-252deg) scale(1.1);}10%{-webkit-transform: rotate(-252deg) scale(1.0); transform: rotate(-252deg) scale(1.0);}}@keyframes anim_size1{0%{-webkit-transform: rotate(-2525deg) scale(1.0); transform: rotate(-252deg) scale(1.0);}5%{-webkit-transform: rotate(-252deg) scale(1.1); transform: rotate(-252deg) scale(1.1);}10%{-webkit-transform: rotate(-252deg) scale(1.0); transform: rotate(-252deg) scale(1.0);}}@-webkit-keyframes anim_size2{0%{-webkit-transform: rotate(-294deg) scale(1.0); transform: rotate(-294deg) scale(1.0);}5%{-webkit-transform: rotate(-294deg) scale(1.1); transform: rotate(-294deg) scale(1.1);}10%{-webkit-transform: rotate(-294deg) scale(1.0); transform: rotate(-294deg) scale(1.0);}}@keyframes anim_size2{0%{-webkit-transform: rotate(-294deg) scale(1.0); transform: rotate(-294deg) scale(1.0);}5%{-webkit-transform: rotate(-294deg) scale(1.1); transform: rotate(-294deg) scale(1.1);}10%{-webkit-transform: rotate(-294deg) scale(1.0); transform: rotate(-294deg) scale(1.0);}}@-webkit-keyframes anim_size3{0%{-webkit-transform: rotate(-336deg) scale(1.0); transform: rotate(-336deg) scale(1.0);}5%{-webkit-transform: rotate(-336deg) scale(1.1); transform: rotate(-336deg) scale(1.1);}10%{-webkit-transform: rotate(-336deg) scale(1.0); transform: rotate(-336deg) scale(1.0);}}@keyframes anim_size3{0%{-webkit-transform: rotate(-336deg) scale(1.0); transform: rotate(-336deg) scale(1.0);}5%{-webkit-transform: rotate(-336deg) scale(1.1); transform: rotate(-336deg) scale(1.1);}10%{-webkit-transform: rotate(-336deg) scale(1.0); transform: rotate(-336deg) scale(1.0);}}@-webkit-keyframes anim_size4{0%{-webkit-transform: rotate(-378deg) scale(1.0); transform: rotate(-378deg) scale(1.0);}5%{-webkit-transform: rotate(-378deg) scale(1.1); transform: rotate(-378deg) scale(1.1);}10%{-webkit-transform: rotate(-378deg) scale(1.0); transform: rotate(-378deg) scale(1.0);}}@keyframes anim_size4{0%{-webkit-transform: rotate(-378deg) scale(1.0); transform: rotate(-378deg) scale(1.0);}5%{-webkit-transform: rotate(-378deg) scale(1.1); transform: rotate(-378deg) scale(1.1);}10%{-webkit-transform: rotate(-378deg) scale(1.0); transform: rotate(-378deg) scale(1.0);}}@-webkit-keyframes anim_size5{0%{-webkit-transform: rotate(-180deg) scale(1.0); transform: rotate(-180deg) scale(1.0);}5%{-webkit-transform: rotate(-180deg) scale(1.1); transform: rotate(-180deg) scale(1.1);}10%{-webkit-transform: rotate(-180deg) scale(1.0); transform: rotate(-180deg) scale(1.0);}}@keyframes anim_size5{0%{-webkit-transform: rotate(-180deg) scale(1.0); transform: rotate(-180deg) scale(1.0);}5%{-webkit-transform: rotate(-180deg) scale(1.1); transform: rotate(-180deg) scale(1.1);}10%{-webkit-transform: rotate(-180deg) scale(1.0); transform: rotate(-180deg) scale(1.0);}}'));    //     // document.getElementsByTagName('body')[0].appendChild(messager_newStyle);    //     // messager_newStyle = document.createElement('style');    //     messager_newStyle.id = 'messager_style_resize';    //     document.getElementsByTagName('body')[0].appendChild(messager_newStyle);    //     var messager_iDiv = document.createElement('div');    //     messager_iDiv.className = 'messager_root';    //     messager_iDiv.innerHTML = '';    //     document.getElementsByTagName('body')[0].appendChild(messager_iDiv);    //     if (messager_isDesktop()) document.getElementById('viber').href = 'viber://chat?number=%2B380939592872'; else document.getElementById('viber').href = 'viber://chat?number=%2B380939592872';    //     //messager_resize();    // }    // function messager_resize() {    //     var messager_vidgetSize;    //     if (messager_isDesktop()) {    //         if (window.innerHeight > 720) {    //             messager_vidgetSize = 240;    //         } else {    //             messager_vidgetSize = window.innerHeight / 3;    //         }    //     } else {    //         messager_vidgetSize = document.getElementsByTagName('body')[0].clientWidth / 3;    //         if (window.orientation === 90 || window.orientation === -90) {    //             messager_vidgetSize *= 1.2;    //         } else {    //             messager_vidgetSize *= 2;    //         }    //     }    //     var messager_root = document.getElementsByClassName('messager_root')[0];    //     messager_root.style.width = messager_vidgetSize + 'px';    //     messager_root.style.height = messager_vidgetSize + 'px';    //     messager_root.style.marginRight = '-' + messager_vidgetSize * 0.22 + 'px';    //     messager_root.style.marginBottom = '-' + messager_vidgetSize * 0.22 + 'px';    //     var messager_animateSize = messager_vidgetSize / 25;    //     var messager_newStyle = document.getElementById('messager_style_resize');    //     //css = '@-webkit-keyframes anim_btn{0%{-webkit-box-shadow:0 0 0 0 rgba(255, 206, 0, 1),0 0 0 0 rgba(255, 206, 0, .7);box-shadow:0 0 0 0 rgba(255, 206, 0, 1),0 0 0 0 rgba(255, 206, 0, .7)}40%{-webkit-box-shadow:0 0 0 ' + (messager_animateSize * 2) + 'px rgba(255, 206, 0, 0),0 0 0 10px rgba(255, 206, 0, .7);box-shadow:0 0 0 ' + (messager_animateSize * 2) + 'px rgba(255, 206, 0, 0),0 0 0 ' + (messager_animateSize) + 'px rgba(255, 206, 0, .7)}80%{-webkit-box-shadow:0 0 0 ' + (messager_animateSize * 4) + 'px rgba(255, 206, 0, 0),0 0 0 ' + (messager_animateSize * 2) + 'px rgba(255, 206, 0, 0);box-shadow:0 0 0 ' + (messager_animateSize * 4) + 'px rgba(255, 206, 0, 0),0 0 0 ' + (messager_animateSize * 2) + 'px rgba(255, 206, 0, 0)}100%{-webkit-box-shadow:0 0 0 ' + (messager_animateSize * 5) + 'px rgba(255, 206, 0, 0),0 0 0 ' + (messager_animateSize * 4) + 'px rgba(255, 206, 0, 0);box-shadow:0 0 0 ' + (messager_animateSize * 5) + 'px rgba(255, 206, 0, 0),0 0 0 ' + (messager_animateSize * 4) + 'px rgba(255, 206, 0, 0)}}';    //     //messager_newStyle.innerHTML = css;    // }    // function messager_cl() {    //     var messager_element = document.getElementsByClassName('messager_root')[0];    //     if (messager_element.className.indexOf('messager_active') > -1) {    //         messager_element.className = 'messager_root';    //     } else {    //         messager_element.className = 'messager_root messager_active';    //     }    // }    // window.addEventListener('load', function () {    //     messager_init();    //     // window.addEventListener('resize', function () {    //     //     messager_resize();    //     // });    // });    (function () {        var $map_location_wrapper = $('.gmap');        if (!$map_location_wrapper.length)            return;        var window_height = $(window).height();        var map_location_loaded = false;        var map_offset_top = $map_location_wrapper.offset().top;        setInterval(function () {            if (!map_location_loaded)                map_offset_top = $map_location_wrapper.offset().top;        }, 2000);        setInterval(function () {            var scroll_top = $(document).scrollTop();            if (!map_location_loaded && scroll_top > map_offset_top - window_height * 2) {                $.getScript('https://maps.googleapis.com/maps/api/js?key=' + map_api_key + '&callback=drawMaps');                map_location_loaded = true;            }        }, 20);        var map1, map2, map3, map4, map_multi_1, map_multi_2;        window.drawMaps = function () {            var mapOptions = {                zoom: map_location_zoom,                scaleControl: true,                streetViewControl: false,                zoomControl: true,                zoomControlOptions: {                    position: google.maps.ControlPosition.LEFT_TOP                },                draggable: true,                panControl: false,                mapTypeId: google.maps.MapTypeId.ROADMAP,                mapTypeControl: false,                scrollwheel: false            };            if (window.map_location_coords_1) {                //var map_location_coords_1 = '51.509865, -0.118092';                var map_location_center_coords_split_1 = map_location_coords_1.split(",");                mapOptions.center = new google.maps.LatLng(parseFloat(map_location_center_coords_split_1[0]), parseFloat(map_location_center_coords_split_1[1])); // London                map1 = new google.maps.Map(document.getElementById("map1"), mapOptions);                var marker_location1 = new google.maps.Marker({                    position: new google.maps.LatLng(parseFloat(map_location_center_coords_split_1[0]), parseFloat(map_location_center_coords_split_1[1])), // London                    map: map1,                    icon: {                        url: map_location_marker_icon,                        origin: new google.maps.Point(0, 0)                    }                });            }            if (window.map_location_coords_2) {                //var map_location_coords_2 = '51.509865, -0.118092';                var map_location_center_coords_split_2 = map_location_coords_2.split(",");                mapOptions.center = new google.maps.LatLng(parseFloat(map_location_center_coords_split_2[0]), parseFloat(map_location_center_coords_split_2[1])); // Amsterdam                map2 = new google.maps.Map(document.getElementById("map2"), mapOptions);                var marker_location2 = new google.maps.Marker({                    position: new google.maps.LatLng(parseFloat(map_location_center_coords_split_2[0]), parseFloat(map_location_center_coords_split_2[1])), // Amsterdam                    map: map2,                    icon: {                        url: map_location_marker_icon,                        origin: new google.maps.Point(0, 0)                    }                });            }            if (window.map_location_coords_3) {                //var map_location_coords_3 = '51.509865, -0.118092';                var map_location_center_coords_split_3 = map_location_coords_3.split(",");                mapOptions.center = new google.maps.LatLng(parseFloat(map_location_center_coords_split_3[0]), parseFloat(map_location_center_coords_split_3[1])); // Amsterdam                map3 = new google.maps.Map(document.getElementById("map3"), mapOptions);                var marker_location3 = new google.maps.Marker({                    position: new google.maps.LatLng(parseFloat(map_location_center_coords_split_3[0]), parseFloat(map_location_center_coords_split_3[1])), // Amsterdam                    map: map3,                    icon: {                        url: map_location_marker_icon,                        origin: new google.maps.Point(0, 0)                    }                });            }            if (window.map_location_coords_4) {                //var map_location_coords_4 = '51.503215, -0.118092';                var map_location_center_coords_split_4 = map_location_coords_4.split(",");                mapOptions.center = new google.maps.LatLng(parseFloat(map_location_center_coords_split_4[0]), parseFloat(map_location_center_coords_split_4[1])); // Amsterdam                map4 = new google.maps.Map(document.getElementById("map4"), mapOptions);                var marker_location4 = new google.maps.Marker({                    position: new google.maps.LatLng(parseFloat(map_location_center_coords_split_4[0]), parseFloat(map_location_center_coords_split_4[1])), // Amsterdam                    map: map4,                    icon: {                        url: map_location_marker_icon,                        origin: new google.maps.Point(0, 0)                    }                });            }            if (window.map_location_coords_multi_1) {                // https://stackoverflow.com/questions/30012913/google-map-api-v3-add-multiple-infowindows                var locations = map_location_coords_multi_1;                var map_location_coords_multi_center_split = map_location_coords_multi_center_1.split(",");                var infowindow = new google.maps.InfoWindow(); // Only one InfoWindow                map_multi_1 = new google.maps.Map(document.getElementById('map-multi-1'), {                    zoom: map_location_coords_multi_1_zoom,                    center: new google.maps.LatLng(parseFloat(map_location_coords_multi_center_split[0]), parseFloat(map_location_coords_multi_center_split[1])),                });                function placeMarker(loc) {                    const marker = new google.maps.Marker({                        position: new google.maps.LatLng(loc.lat, loc.lng),                        map: map_multi_1,                        icon: {                            url: map_location_marker_icon,                            origin: new google.maps.Point(0, 0)                        }                    });                    google.maps.event.addListener(marker, 'click', function () {                        infowindow.close(); // Close previously opened infowindow                        infowindow.setContent(`<div id="infowindow">${loc.pinData}</div>`);                        infowindow.open(map_multi_1, marker);                    });                }                // ITERATE ALL LOCATIONS. Pass every location to placeMarker                locations.forEach(placeMarker);                // var initGoogleMap = function() {                //                //     var infowindow = new google.maps.InfoWindow(); // Only one InfoWindow                //     map_multi_1 = new google.maps.Map(document.getElementById('map-multi-1'), {                //         zoom: map_location_coords_multi_1_zoom,                //         center: new google.maps.LatLng(parseFloat(map_location_coords_multi_center_split[0]), parseFloat(map_location_coords_multi_center_split[1])),                //     });                //                //     function placeMarker(loc) {                //         const marker = new google.maps.Marker({                //             position: new google.maps.LatLng(loc.lat, loc.lng),                //             map: map_multi_1,                //             icon: {                //                 url: map_location_marker_icon,                //                 origin: new google.maps.Point(0, 0)                //             }                //         });                //         google.maps.event.addListener(marker, 'click', function () {                //             infowindow.close(); // Close previously opened infowindow                //             infowindow.setContent(`<div id="infowindow">${loc.pinData}</div>`);                //             infowindow.open(map_multi_1, marker);                //         });                //     }                //                //     // ITERATE ALL LOCATIONS. Pass every location to placeMarker                //     locations.forEach(placeMarker);                //                // };                //                // google.maps.event.addDomListener(window, 'load', initGoogleMap);            }            // // https://stackoverflow.com/questions/3059044/google-maps-js-api-v3-simple-multiple-marker-example            //            // if (window.map_location_coords_multi_1) {            //            //     var            //         locations,            //         map_location_coords_multi_center_split;            //            //     var infowindow = new google.maps.InfoWindow();            //            //     var marker, i;            //            //            //     locations = map_location_coords_multi_1;            //     map_location_coords_multi_center_split = map_location_coords_multi_center_1.split(",");            //            //     var map_multi_1 = new google.maps.Map(document.getElementById('map-multi-1'), {            //         zoom: map_location_coords_multi_1_zoom,            //         //center: new google.maps.LatLng(-33.92, 151.25),            //         center: new google.maps.LatLng(parseFloat(map_location_coords_multi_center_split[0]), parseFloat(map_location_coords_multi_center_split[1])),            //         mapTypeId: google.maps.MapTypeId.ROADMAP            //     });            //            //     for (i = 0; i < locations.length; i++) {            //         marker = new google.maps.Marker({            //             position: new google.maps.LatLng(locations[i][1], locations[i][2]),            //             map: map_multi_1,            //             icon: {            //                 url: map_location_marker_icon,            //                 origin: new google.maps.Point(0, 0)            //             }            //         });            //            //         google.maps.event.addListener(marker, 'click', (function(marker, i, infowindow, locations, map_multi_1) {            //             return function() {            //                 infowindow.setContent(locations[i][0]);            //                 infowindow.open(map_multi_1, marker);            //             };            //         })(marker, i));            //     }            //            // }            // if (window.map_location_coords_multi_2) {            //            //     locations = map_location_coords_multi_2;            //     map_location_coords_multi_center_split = map_location_coords_multi_center_2.split(",");            //            //     var map_multi_2 = new google.maps.Map(document.getElementById('map-multi-2'), {            //         zoom: map_location_coords_multi_2_zoom,            //         //center: new google.maps.LatLng(-33.92, 151.25),            //         center: new google.maps.LatLng(parseFloat(map_location_coords_multi_center_split[0]), parseFloat(map_location_coords_multi_center_split[1])),            //         mapTypeId: google.maps.MapTypeId.ROADMAP            //     });            //            //     for (i = 0; i < locations.length; i++) {            //         marker = new google.maps.Marker({            //             position: new google.maps.LatLng(locations[i][1], locations[i][2]),            //             map: map_multi_2,            //             icon: {            //                 url: map_location_marker_icon,            //                 origin: new google.maps.Point(0, 0)            //             }            //         });            //            //         google.maps.event.addListener(marker, 'click', (function(marker, i) {            //             return function() {            //                 infowindow.setContent(locations[i][0]);            //                 infowindow.open(map_multi_2, marker);            //             };            //         })(marker, i));            //     }            //            // }        };    })();    var        $lang = $('.js-lang'),        $langCurrent = $lang.find('.lang__current'),        $langTarget = $lang.find('.lang__list li a');    $langCurrent.on('click', function () {       $(this).parent().toggleClass('active');    });    $langTarget.each(function () {        var _this = $(this);        _this.on('click', function () {            $langCurrent.find('span').text(_this.text());            $langCurrent.parent().toggleClass('active');        });    });    var        $location = $('.js-location'),        $locationCurrent = $location.find('.location__current'),        $locationTarget = $location.find('.location__list li span');    $locationCurrent.on('click', function () {        $(this).parent().toggleClass('active');    });    if (getCookie('location')) {        $locationCurrent.find('.location__current-text').html('<a href="https://maps.google.com/?q=' + getCookie('location') + '" rel="nofollow noreferrer" target="_blank">' + getCookie('location') + '</a>');        $location.siblings('.tpan__item_tels').find('.tpan__item-text a:first-child').attr('href', getCookie('tel-one-href')).text(getCookie('tel-one'));        $location.siblings('.tpan__item_tels').find('.tpan__item-text a:last-child').attr('href', getCookie('tel-two-href')).text(getCookie('tel-two'));    }    $locationTarget.each(function () {        var _this = $(this);        _this.on('click', function () {            var $locationAddress = _this.text();            var $locationTelOne = _this.attr('data-tel-one');            var $locationTelOneHref = _this.attr('data-tel-one-href');            var $locationTelTwo = _this.attr('data-tel-two');            var $locationTelTwoHref = _this.attr('data-tel-two-href');            $locationCurrent.find('.location__current-text').html('<a href="https://maps.google.com/?q=' + $locationAddress + '" rel="nofollow noreferrer" target="_blank">' + $locationAddress + '</a>');            $locationCurrent.parent().toggleClass('active');            $location.siblings('.tpan__item_tels').find('.tpan__item-text a:first-child').attr('href', $locationTelOneHref).text($locationTelOne);            $location.siblings('.tpan__item_tels').find('.tpan__item-text a:last-child').attr('href', $locationTelTwoHref).text($locationTelTwo);            // add address to cookie            setCookie('location', $locationAddress, 30);            setCookie('tel-one', $locationTelOne, 30);            setCookie('tel-one-href', $locationTelOneHref, 30);            setCookie('tel-two', $locationTelTwo, 30);            setCookie('tel-two-href', $locationTelTwoHref, 30);            // // debug            // console.log('location : ', getCookie('location'));            // console.log('tel-one : ', getCookie('tel-one'));            // console.log('tel-one-href : ', getCookie('tel-one-href'));            // console.log('tel-two : ', getCookie('tel-two'));            // console.log('tel-two-href : ', getCookie('tel-two-href'));        });    });    // https://www.tabnine.com/academy/javascript/how-to-set-cookies-javascript/    function setCookie(cName, cValue, expDays) {        var date = new Date();        date.setTime(date.getTime() + (expDays * 24 * 60 * 60 * 1000));        var expires = "expires=" + date.toUTCString();        document.cookie = cName + "=" + cValue + "; " + expires + "; path=/";    }    function getCookie(cName) {        var name = cName + "=";        var cDecoded = decodeURIComponent(document.cookie); // to be careful        var cArr = cDecoded.split('; ');        var res;        cArr.forEach(val => {            if (val.indexOf(name) === 0) res = val.substring(name.length);        });        return res;    }    (function(){        lomeFixed();        $(window).on('resize scroll', function () {            lomeFixed();        });        function lomeFixed() {            var                windowWidth = $(window).outerWidth(),                $tpan = $('.tpan'),                $lome = $('.lome'),                $memob = $('.memob'),                $offer = $('.offer'),                $tpanOuterHeight = $tpan.outerHeight(),                $lomeOuterHeight = $lome.outerHeight(),                $tpanPlusLomeHeight = $tpanOuterHeight + $lomeOuterHeight;            var y = $(this).scrollTop();            if (windowWidth <= 767) {                if (y > $tpanPlusLomeHeight) {                    $memob.addClass('is-visible');                } else {                    $memob.removeClass('is-visible');                }            }            if (windowWidth >= 768) {                if (y > $tpanOuterHeight) {                    $lome.addClass('is-fixed');                    $offer.css('marginTop', $lomeOuterHeight);                } else {                    $lome.removeClass('is-fixed');                    $offer.css('marginTop', '0');                }            }        }    })();    (function () {        function collapsIng() {            if (window.windowWidth <= 767) {                $('.menu__item').each(function () {                    var _this = $(this);                    var $subMenu = _this.find('.sub-menu');                    //var isSubMenuOpen = false;                    if ($subMenu) {                        // _this.mouseenter(function () {                        //     _this.addClass('is-hover');                        //     $subMenu.slideDown('500');                        //     isSubMenuOpen = true;                        // });                        //                        // _this.mouseleave(function () {                        //     _this.removeClass('is-hover');                        //     $subMenu.slideUp('500');                        //     isSubMenuOpen = false                        // });                        _this.on('click', function () {                            $subMenu.slideToggle('500');                            _this.toggleClass('is-hover');                        });                    }                });            }            if (window.windowWidth >= 768) {                $('.menu__item').each(function () {                    var _this = $(this);                    _this.mouseenter(function () {                        _this.addClass('is-hover');                    });                    _this.mouseleave(function () {                        _this.removeClass('is-hover');                    });                });            }        }        collapsIng();        var $menuLink = $('.menu.menu_main .menu__link');        if ($('.is-home-page').length && window.location.hash) {            scrollToTarget('hash', window.location.hash);        }        $menuLink.on('click', function (e) {            if ($('.is-home-page').length === 0) return;            if (/#/.test(this.href)) { // https://stackoverflow.com/questions/20745857/check-if-clicked-href-has-a-hash-and-do-nothing-else-go-to-link                e.preventDefault();                scrollToTarget('link', $(this));            }        });        function scrollToTarget(mode, el) {            var                $target = null,                $page = $('html, body'),                $lomeDesktopHeight = $('.lome').outerHeight();            if (mode === 'hash') {                $target = $(el);            }            if (mode === 'link') {                $target = $(el.attr('href'));                if ($('.modal').hasClass('show')) {                    if ($target.length === 0) return;                    $('.modal').modal('hide');                }            }            if ($target.length === 0) return;            if (windowWidth >= 768) {                $page.animate({                    scrollTop: $target.offset().top - $lomeDesktopHeight                }, 750, function () {                    $page.animate({                        scrollTop: $target.offset().top - $lomeDesktopHeight                    }, 750);                });            }            if (windowWidth <= 767) {                $page.animate({                    scrollTop: $target.offset().top                }, 750);            }            // stop scrolling when user scrolls manually ( https://stackoverflow.com/questions/18445590/jquery-animate-stop-scrolling-when-user-scrolls-manually )            $page.on("scroll mousedown wheel DOMMouseScroll mousewheel keyup touchmove", function () {                $(this).stop();            });        }        $(window).on('resize', function () {            var ww = window.outerWidth;            if (ww >= 768) {                $('#modal-menu').modal('hide');            }        });    })();    /** modal */    (function () {        var parseVideo = function (url) {            // https://gist.github.com/hx0day/3bed3b72f25564b1e544afa2a6452229            // - Supported YouTube URL formats:            //   - http://www.youtube.com/watch?v=My2FRPA3Gf8            //   - http://youtu.be/My2FRPA3Gf8            //   - https://youtube.googleapis.com/v/My2FRPA3Gf8            //   - https://www.youtube-nocookie.com/embed/3S5uYYjdMNo            //   - https://www.youtube.com/embed/3S5uYYjdMNo            // - Supported Vimeo URL formats:            //   - http://vimeo.com/25451551            //   - http://player.vimeo.com/video/25451551            // - Also supports relative URLs:            //   - //player.vimeo.com/video/25451551            url.match(/(http:|https:|)\/\/(player.|www.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis|be-nocookie\.com))\/(video\/|embed\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/);            var type = null;            if (RegExp.$3.indexOf('youtu') > -1) {                type = 'youtube';            } else if (RegExp.$3.indexOf('vimeo') > -1) {                type = 'vimeo';            }            return {                type: type,                id: RegExp.$6            };        };        // $(document) используется для возможности работать с динамическими добавленными DOM элементами HTML разметки        $(document).on('click', '.js-open-modal', function (e) {            e.preventDefault();            e.stopPropagation();            $(document).on('keydown', function (e) {                if (e.key === "Escape") {                    $modalToShow.modal('hide');                }            });            var                _this = $(this),                $modalName = _this.attr('data-modal'),                $modalToShow = $('#modal-' + $modalName),                $modalMservData = _this.parents('.services__item, .dental-services__item').find('.services__data').html(),                $modalTeamData = _this.siblings('.team__data').html();            if (!$modalToShow.length) {                console.log('Модальное окно с идентификатором #modal-' + $modalName + ' отстутвует на странице или указано не верно.');            } else if ($modalToShow.length && $modalName === 'video') {                // pug usage example                // .some_element(class='js-open-modal' data-modal='video' data-video='https://www.youtube.com/watch?v=suTYbf-FtXg')                var                    $videoUrl = _this.attr('data-video'),                    $videoType = parseVideo($videoUrl).type,                    $videoId = parseVideo($videoUrl).id;                if ($videoType === 'youtube') {                    $modalToShow.find('.iframe').html('<iframe src="https://www.youtube-nocookie.com/embed/' + $videoId + '?controls=0&autoplay=1" frameborder="0" allow="autoplay; encrypted-media" mozallowfullscreen allowfullscreen allowfullscreen></iframe>');                } else if ($videoType === 'vimeo') {                    $modalToShow.find('.iframe').html('<iframe src="https://player.vimeo.com/video/' + $videoId + '?rel=0&amp;autoplay=1&showinfo=0&controls=0" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>');                }                $modalToShow.modal('show');                $modalToShow.on('hidden.bs.modal', function () {                    $modalToShow.find('.iframe').html('');                });            } else if ($modalToShow.length && $modalName === 'mserv') {                $modalToShow.find('.mserv__inner').html($modalMservData);                $modalToShow.modal('show');                window.modalOpened = true;                $modalToShow.on('hidden.bs.modal', function () {                    window.modalOpened = false;                    $modalToShow.find('.mserv__data').html('');                });            } else if ($modalToShow.length && $modalName === 'mteam') {                $modalToShow.find('.mserv__inner').html($modalTeamData);                $modalToShow.modal('show');                window.modalOpened = true;                $modalToShow.on('hidden.bs.modal', function () {                    window.modalOpened = false;                    $modalToShow.find('.mserv__inner').html('');                });            } else {                $modalToShow.modal('show');                window.modalOpened = true;                $modalToShow.on('hidden.bs.modal', function () {                    window.modalOpened = false;                });            }        });        // if ($btn.length) {        //        //     $.each($btn, function () {        //        //         var _this = $(this);        //        //         _this.on('click', function (e) {        //        //             e.preventDefault();        //        //             var        //                 $modalName = _this.attr('data-modal'),        //                 $modalToShow = $('#modal-' + $modalName),        //                 $modalMservData = _this.parents('.services__item').find('.services__data').html(),        //                 $modalTeamData = _this.siblings('.team__data').html();        //        //        //        //         });        //        //     });        //        // }    })();    (function(){        molinksFixed();        $(window).on('resize scroll', _.throttle(function () {            molinksFixed();        }, 50));        function molinksFixed() {            var                windowWidth = $(window).outerWidth(),                $lome = $('.blog-lome'),                $molinks = $('.blog-molinks'),                $offer = $('.blog-offer'),                //$molinksOuterHeight = $molinks.outerHeight(),                $lomeOuterHeight = $lome.outerHeight();            var y = $(this).scrollTop();            if (windowWidth <= 767) {                if (y > $lomeOuterHeight) {                    $molinks.addClass('is-fixed');                    $offer.addClass('blog-molinks-fixed');                } else {                    $molinks.removeClass('is-fixed');                    $offer.removeClass('blog-molinks-fixed');                }            }        }    })();    $(function () {        objectFitImages();    });    (function () {        var            $price = $('.js-price'),            $priceHead = $price.find('.price__head');        if ($price.length) {            $priceHead.each(function () {                var                    _this = $(this),                    target = _this.attr('data-target');                if (target !== 'undefined') {                    _this.on('click', function (e) {                        e.stopPropagation();                        _this.toggleClass('is-open');                        _this.siblings('#' + target).stop().slideToggle();                    });                }            });        }    })();    $('body').scrollspy({        target: '#menu',        offset: 150    });    (function () {        scrollTo();        $(window).on('resize', function(){            scrollTo();        });        function scrollTo() {            $(".js-scrollTo").off().on('click', function (e) {                e.preventDefault();                var $page = $('html, body');                var                    $windowWidth = $(window).outerWidth(),                    $lomeHeight = $('.lome').outerHeight(),                    $targetOffset = $(this).attr("data-offset"),                    target = $(this).attr("href");                if ($targetOffset && $windowWidth >= 992) {                    //console.log('desktop handler 1');                    $('html, body').animate({                        scrollTop: $(target).offset().top - $lomeHeight + 2 - $targetOffset                    }, 1500);                }                if (!$targetOffset && $windowWidth >= 992) {                    //console.log('desktop handler 2');                    $('html, body').animate({                        scrollTop: $(target).offset().top - $lomeHeight + 2                    }, 1500);                }                if ($windowWidth <= 991) {                    //console.log('mobile handler');                    $('#modal-menu').modal('hide');                    $('html, body').animate({                        scrollTop: $(target).offset().top                    }, 1500);                }                // stop scrolling when user scrolls manually                // https://stackoverflow.com/questions/18445590/jquery-animate-stop-scrolling-when-user-scrolls-manually                $page.on("scroll mousedown wheel DOMMouseScroll mousewheel keyup touchmove", function () {                    $(this).stop();                });            });        }    })();    (function () {        var            swiperAlias = 'dental-services',            swiperClass = '.js-swiper-container-' + swiperAlias,            swiperInited = false;        if ($('.' + swiperAlias + '_v5').length) {            var swiperInit = function () {                var mySwiper = new Swiper(swiperClass, {                    loop: true,                    autoHeight: true,                    grabCursor: true,                    speed: 700,                    resistanceRatio: 0,                    slidesPerView: 4,                    spaceBetween: 30,                    navigation: {                        nextEl: '.js-swiper-' + swiperAlias + '-move-right',                        prevEl: '.js-swiper-' + swiperAlias + '-move-left',                    },                    preloadImages: false,                    lazy: true,                    pagination: {                        el: '.js-swiper-' + swiperAlias + '-pagination',                        type: 'bullets',                        clickable: true                    },                    breakpoints: {                        // when window width is <= 575                        575: {                            slidesPerView: 1                        },                        // when window width is <= 767px                        767: {                            slidesPerView: 2                        },                        // when window width is <= 991px                        991: {                            slidesPerView: 3                        }                    }                });                // mySwiper.on('slideChangeTransitionEnd', function () {                //                //     $('.swiper-slide-duplicate').find('.js-open-modal').off().on('click', function (e) {                //                //         e.preventDefault();                //                //         var                //             _this = $(this),                //             $modalName = _this.attr('data-modal'),                //             $modalToShow = $('#modal-' + $modalName),                //             $modalTeamData = _this.siblings('.team__data').html();                //                //         if (!$modalToShow.length) {                //                //             console.log('Модальное окно с идентификатором #modal-' + $modalName + ' отстутвует на странице или указано не верно.');                //                //         } else if ($modalToShow.length && $modalName === 'mteam') {                //                //             $modalToShow.find('.mserv__inner').html($modalTeamData);                //                //             $modalToShow.modal('show');                //             window.modalOpened = true;                //                //             $modalToShow.on('hidden.bs.modal', function () {                //                 window.modalOpened = false;                //                 $modalToShow.find('.mserv__inner').html('');                //             });                //         }                //     });                //                // });            };            swiperInit();            // var swiperHandler = function () {            //     if (!swiperInited && $('.' + swiperAlias).isInViewport()) {            //         swiperInit();            //         swiperInited = true;            //     }            // };            //            // swiperHandler();            //            // $(window).on('resize scroll', function () {            //     swiperHandler();            // });        }    })();    (function () {        var $lg = $('#photos-gallery');        $lg.lightGallery({            selector: '.gallery__figure-link',            hash: true,            galleryId: 1,            thumbnail: false,            share: false,            loop: true,            slideEndAnimatoin: false,            hideControlOnEnd: true,            download: false,            subHtmlSelectorRelative: true        });        var            swiperAlias = 'gallery',            swiperClass = '.js-swiper-container-' + swiperAlias,            swiperInited = false;        if ($('.' + swiperAlias).length) {            var swiperInit = function () {                var mySwiper = new Swiper(swiperClass, {                    //loop: true,                    speed: 700,                    resistanceRatio: 0,                    slidesPerView: 1,                    navigation: {                        nextEl: '.js-swiper-' + swiperAlias + '-cright',                        prevEl: '.js-swiper-' + swiperAlias + '-cleft',                    },                    preloadImages: false,                    lazy: true,                    loadPrevNext: true                });                mySwiper.on('slideChangeTransitionEnd', function () {                    $lg.data('lightGallery').destroy(true);                    $lg.lightGallery({                        selector: '.gallery__figure-link',                        hash: true,                        galleryId: 1,                        thumbnail: false,                        share: false,                        loop: true,                        slideEndAnimatoin: false,                        hideControlOnEnd: true,                        download: false                    });                });            };            var swiperHandler = function () {                if (!swiperInited && $('.' + swiperAlias).isInViewport()) {                    swiperInit();                    swiperInited = true;                }            };            swiperHandler();            $(window).on('resize scroll', function () {                swiperHandler();            });        }    })();    (function () {        var            swiperAlias = 'offer',            swiperClass = '.js-swiper-only-img-' + swiperAlias,            swiperInited = false;        if ($(swiperClass).length) {            var swiperInit = function () {                var mySwiper = new Swiper(swiperClass, {                    simulateTouch: false,                    roundLengths: true, // Set to true to round values of slides width and height to prevent blurry texts on usual resolution screens (if you have such)                    watchOverflow: true,                    autoplay: {                        delay: 5000,                    },                    loop: true,                    speed: 700,                    resistanceRatio: 0,                    slidesPerView: 1,                    autoHeight: true,                    navigation: {                        nextEl: '.js-swiper-' + swiperAlias + '-cright',                        prevEl: '.js-swiper-' + swiperAlias + '-cleft',                    },                    preloadImages: false,                    lazy: true,                    loadPrevNext: true,                    breakpoints: {                        // when window width is <= 991                        767: {                            lazy: {                                loadPrevNext: true,                                loadPrevNextAmount: 1,                            },                            autoplay: false,                            loadOnTransitionStart: true,                            pagination: {                                el: '.js-swiper-pagination-' + swiperAlias,                                type: 'bullets',                                clickable: true                            },                        }                    },                    on: {                        init: function () {                            setTimeout(function () {                                mySwiper.updateAutoHeight('700');                            }, 500);                        }                    }                });                $(window).on('resize', function () {                    setTimeout(function () {                        mySwiper.updateAutoHeight('700');                    }, 500);                });                mySwiper.on('slideChangeTransitionEnd', function () {                    mobileScrollTo();                    desktopScrollTo();                    $(window).on('resize', function () {                        mobileScrollTo();                        desktopScrollTo();                    });                    function mobileScrollTo() {                        var $windowWidth = $(window).outerWidth();                        if ($windowWidth <= 767) {                            $(".js-scrollTo").on('click', function (e) {                                e.preventDefault();                                var target = $(this).attr("href");                                $('#modal-menu').modal('hide');                                $('html, body').animate({                                    scrollTop: $(target).offset().top                                });                            });                        }                    }                    function desktopScrollTo() {                        var $windowWidth = $(window).outerWidth();                        if ($windowWidth >= 768) {                            var lomeHeight = $('.lome').outerHeight();                            $(".js-scrollTo").on('click', function (e) {                                e.preventDefault();                                var                                    $windowWidth = $(window).outerWidth(),                                    targetOffset = $(this).attr("data-offset"),                                    target = $(this).attr("href");                                //console.log(targetOffset);                                //console.log(lomeHeight);                                // hide modal menu                                $('#modal-menu').modal('hide');                                if (targetOffset && $windowWidth >= 992) {                                    $('html, body').animate({                                        scrollTop: $(target).offset().top - lomeHeight + 2 - targetOffset                                    }, 500);                                } else {                                    $('html, body').animate({                                        scrollTop: $(target).offset().top - lomeHeight + 2                                    }, 500);                                }                            });                        }                    }                });            };            var swiperHandler = function () {                if (!swiperInited && $('.' + swiperAlias).isInViewport()) {                    swiperInit();                    swiperInited = true;                }            };            swiperHandler();            $(window).on('resize scroll', function () {                swiperHandler();            });        }    })();    (function () {        var            swiperAlias = 'offer',            swiperClass = '.js-swiper-container-with-bullets-' + swiperAlias,            swiperInited = false;        if ($(swiperClass).length) {            var swiperInit = function () {                var mySwiper = new Swiper(swiperClass, {                    simulateTouch: false,                    roundLengths: true, // Set to true to round values of slides width and height to prevent blurry texts on usual resolution screens (if you have such)                    watchOverflow: true,                    autoplay: {                        delay: 5000,                    },                    loop: true,                    speed: 700,                    resistanceRatio: 0,                    slidesPerView: 1,                    autoHeight: true,                    navigation: {                        nextEl: '.js-swiper-' + swiperAlias + '-cright',                        prevEl: '.js-swiper-' + swiperAlias + '-cleft',                    },                    pagination: {                        el: '.js-swiper-pagination-' + swiperAlias,                        type: 'bullets',                        clickable: true                    },                    preloadImages: false,                    lazy: true,                    loadPrevNext: true,                    breakpoints: {                        // when window width is <= 991                        991: {                            lazy: {                                loadPrevNext: true,                                loadPrevNextAmount: 1,                            },                            autoplay: false,                            loadOnTransitionStart: true,                        }                    },                    on: {                        init: function () {                            setTimeout(function () {                                mySwiper.updateAutoHeight('700');                            }, 500);                        }                    }                });                $(window).on('resize', function () {                    setTimeout(function () {                        mySwiper.updateAutoHeight('700');                    }, 500);                });                mySwiper.on('slideChangeTransitionEnd', function () {                    mobileScrollTo();                    desktopScrollTo();                    $(window).on('resize', function () {                        mobileScrollTo();                        desktopScrollTo();                    });                    function mobileScrollTo() {                        var $windowWidth = $(window).outerWidth();                        if ($windowWidth <= 767) {                            $(".js-scrollTo").on('click', function (e) {                                e.preventDefault();                                var target = $(this).attr("href");                                $('#modal-menu').modal('hide');                                $('html, body').animate({                                    scrollTop: $(target).offset().top                                });                            });                        }                    }                    function desktopScrollTo() {                        var $windowWidth = $(window).outerWidth();                        if ($windowWidth >= 768) {                            var lomeHeight = $('.lome').outerHeight();                            $(".js-scrollTo").on('click', function (e) {                                e.preventDefault();                                var                                    $windowWidth = $(window).outerWidth(),                                    targetOffset = $(this).attr("data-offset"),                                    target = $(this).attr("href");                                //console.log(targetOffset);                                //console.log(lomeHeight);                                // hide modal menu                                $('#modal-menu').modal('hide');                                if (targetOffset && $windowWidth >= 992) {                                    $('html, body').animate({                                        scrollTop: $(target).offset().top - lomeHeight + 2 - targetOffset                                    }, 500);                                } else {                                    $('html, body').animate({                                        scrollTop: $(target).offset().top - lomeHeight + 2                                    }, 500);                                }                            });                        }                    }                });            };            var swiperHandler = function () {                if (!swiperInited && $('.' + swiperAlias).isInViewport()) {                    swiperInit();                    swiperInited = true;                }            };            swiperHandler();            $(window).on('resize scroll', function () {                swiperHandler();            });        }    })();    (function () {        var            swiperAlias = 'offer',            swiperClass = '.js-swiper-container-with-motion-' + swiperAlias,            swiperInited = false;        if ($(swiperClass).length) {            var swiperInit = function () {                var mySwiper = new Swiper(swiperClass, {                    effect: 'fade',                    // fadeEffect: {                    //     crossFade: true                    // },                    watchSlidesVisibility: true,                    simulateTouch: false,                    roundLengths: true, // Set to true to round values of slides width and height to prevent blurry texts on usual resolution screens (if you have such)                    autoplay: {                        delay: 5000,                    },                    loop: true,                    speed: 0,                    resistanceRatio: 0,                    slidesPerView: 1,                    //autoHeight: true,                    // navigation: {                    //     nextEl: '.js-swiper-' + swiperAlias + '-cright',                    //     prevEl: '.js-swiper-' + swiperAlias + '-cleft',                    // },                    // pagination: {                    //     el: '.js-swiper-pagination-' + swiperAlias,                    //     type: 'bullets',                    //     clickable: true                    // },                    preloadImages: false,                    lazy: {                        loadPrevNext: true,                        loadPrevNextAmount: 1,                    },                    // breakpoints: {                    //     // when window width is <= 991                    //     991: {                    //         lazy: {                    //             loadPrevNext: true,                    //             loadPrevNextAmount: 1,                    //         },                    //         autoplay: false,                    //         loadOnTransitionStart: true,                    //     }                    // },                    on: {                        init: function () {                            $(swiperClass).find('.swiper-slide-active .offer__bgi-wrap-oi')                                .addClass('is-animated')                                .parent().siblings().find('.offer__bgi-wrap-oi').removeClass('is-animated');                            setTimeout(function () {                                mySwiper.updateAutoHeight('700');                            }, 500);                        }                    }                });                $(window).on('resize', function () {                    setTimeout(function () {                        mySwiper.updateAutoHeight('700');                    }, 500);                });                mySwiper.on('slideChangeTransitionEnd', function () {                    $(swiperClass).find('.swiper-slide-active .offer__bgi-wrap-oi')                        .addClass('is-animated')                        .parent().siblings().find('.offer__bgi-wrap-oi').removeClass('is-animated');                    mobileScrollTo();                    desktopScrollTo();                    $(window).on('resize', function () {                        mobileScrollTo();                        desktopScrollTo();                    });                    function mobileScrollTo() {                        var $windowWidth = $(window).outerWidth();                        if ($windowWidth <= 767) {                            $(".js-scrollTo").on('click', function (e) {                                e.preventDefault();                                var target = $(this).attr("href");                                $('#modal-menu').modal('hide');                                $('html, body').animate({                                    scrollTop: $(target).offset().top                                });                            });                        }                    }                    function desktopScrollTo() {                        var $windowWidth = $(window).outerWidth();                        if ($windowWidth >= 768) {                            var lomeHeight = $('.lome').outerHeight();                            $(".js-scrollTo").on('click', function (e) {                                e.preventDefault();                                var                                    $windowWidth = $(window).outerWidth(),                                    targetOffset = $(this).attr("data-offset"),                                    target = $(this).attr("href");                                //console.log(targetOffset);                                //console.log(lomeHeight);                                // hide modal menu                                $('#modal-menu').modal('hide');                                if (targetOffset && $windowWidth >= 992) {                                    $('html, body').animate({                                        scrollTop: $(target).offset().top - lomeHeight + 2 - targetOffset                                    }, 500);                                } else {                                    $('html, body').animate({                                        scrollTop: $(target).offset().top - lomeHeight + 2                                    }, 500);                                }                            });                        }                    }                });            };            var swiperHandler = function () {                if (!swiperInited && $('.' + swiperAlias).isInViewport()) {                    swiperInit();                    swiperInited = true;                }            };            swiperHandler();            $(window).on('resize scroll', function () {                swiperHandler();            });        }    })();    (function () {        var            swiperAlias = 'offer',            swiperClass = '.js-swiper-container-' + swiperAlias,            swiperInited = false;        if ($(swiperClass).length) {            var swiperInit = function () {                var mySwiper = new Swiper(swiperClass, {                    simulateTouch: false,                    roundLengths: true, // Set to true to round values of slides width and height to prevent blurry texts on usual resolution screens (if you have such)                    watchOverflow: true,                    autoplay: {                        delay: 5000,                    },                    loop: true,                    speed: 700,                    resistanceRatio: 0,                    slidesPerView: 1,                    autoHeight: true,                    navigation: {                        nextEl: '.js-swiper-' + swiperAlias + '-cright',                        prevEl: '.js-swiper-' + swiperAlias + '-cleft',                    },                    preloadImages: false,                    lazy: true,                    breakpoints: {                        // when window width is <= 991                        991: {                            lazy: {                                loadPrevNext: true,                                loadPrevNextAmount: 1,                            },                            autoplay: false,                            loadOnTransitionStart: true,                        }                    },                    on: {                        init: function () {                            setTimeout(function () {                                mySwiper.updateAutoHeight('700');                            }, 500);                        }                    }                });                $(window).on('resize', function () {                    setTimeout(function () {                        mySwiper.updateAutoHeight('700');                    }, 500);                });                mySwiper.on('slideChangeTransitionEnd', function () {                    mobileScrollTo();                    desktopScrollTo();                    $(window).on('resize', function () {                        mobileScrollTo();                        desktopScrollTo();                    });                    function mobileScrollTo() {                        var $windowWidth = $(window).outerWidth();                        if ($windowWidth <= 767) {                            $(".js-scrollTo").on('click', function (e) {                                e.preventDefault();                                var target = $(this).attr("href");                                $('#modal-menu').modal('hide');                                $('html, body').animate({                                    scrollTop: $(target).offset().top                                });                            });                        }                    }                    function desktopScrollTo() {                        var $windowWidth = $(window).outerWidth();                        if ($windowWidth >= 768) {                            var lomeHeight = $('.lome').outerHeight();                            $(".js-scrollTo").on('click', function (e) {                                e.preventDefault();                                var                                    $windowWidth = $(window).outerWidth(),                                    targetOffset = $(this).attr("data-offset"),                                    target = $(this).attr("href");                                //console.log(targetOffset);                                //console.log(lomeHeight);                                // hide modal menu                                $('#modal-menu').modal('hide');                                if (targetOffset && $windowWidth >= 992) {                                    $('html, body').animate({                                        scrollTop: $(target).offset().top - lomeHeight + 2 - targetOffset                                    }, 500);                                } else {                                    $('html, body').animate({                                        scrollTop: $(target).offset().top - lomeHeight + 2                                    }, 500);                                }                            });                        }                    }                });            };            var swiperHandler = function () {                if (!swiperInited && $('.' + swiperAlias).isInViewport()) {                    swiperInit();                    swiperInited = true;                }            };            swiperHandler();            $(window).on('resize scroll', function () {                swiperHandler();            });        }    })();    (function () {        var            swiperAlias = 'reviews',            swiperClass = '.js-swiper-container-' + swiperAlias,            swiperInited = false;        if ($('.' + swiperAlias).length) {            var swiperInit = function () {                var mySwiper = new Swiper(swiperClass, {                    loop: true,                    grabCursor: true,                    speed: 700,                    resistanceRatio: 0,                    slidesPerView: 2,                    spaceBetween: 80,                    navigation: {                        nextEl: '.js-swiper-' + swiperAlias + '-move-right',                        prevEl: '.js-swiper-' + swiperAlias + '-move-left',                    },                    preloadImages: false,                    lazy: true,                    loadPrevNext: true,                    pagination: {                        el: '.js-swiper-' + swiperAlias + '-pagination',                        type: 'bullets',                        clickable: true                    },                    breakpoints: {                        // when window width is <= 767                        767: {                            slidesPerView: 1,                        },                        // when window width is <= 767                        1023: {                            spaceBetween: 40,                        }                    }                });            };            swiperInit();            // var swiperHandler = function () {            //     if (!swiperInited && $('.' + swiperAlias).isInViewport()) {            //         swiperInit();            //         swiperInited = true;            //     }            // };            //            // swiperHandler();            //            // $(window).on('resize scroll', function () {            //     swiperHandler();            // });        }    })();    (function () {        var            swiperAlias = 'slider-images',            swiperClass = '.js-swiper-container-' + swiperAlias;        if ($('.' + swiperAlias).length) {            var swiperInit = function () {                var mySwiper = new Swiper(swiperClass, {                    loop: true,                    grabCursor: true,                    speed: 700,                    resistanceRatio: 0,                    spaceBetween: 30,                    navigation: {                        nextEl: '.js-swiper-' + swiperAlias + '-move-right',                        prevEl: '.js-swiper-' + swiperAlias + '-move-left',                    },                    // preloadImages: false,                    // lazy: true,                    pagination: {                        el: '.js-swiper-' + swiperAlias + '-pagination',                        type: 'bullets',                        clickable: true                    },                });            };            swiperInit();        }    })();    (function () {        var            swiperAlias = 'team_another',            swiperClass = '.js-swiper-container-' + swiperAlias,            swiperInited = false;        if ($('.' + swiperAlias).length) {            var swiperInit = function () {                var mySwiper = new Swiper(swiperClass, {                    loop: true,                    grabCursor: true,                    speed: 700,                    resistanceRatio: 0,                    slidesPerView: 1,                    spaceBetween: 30,                    navigation: {                        nextEl: '.js-swiper-' + swiperAlias + '-move-right',                        prevEl: '.js-swiper-' + swiperAlias + '-move-left',                    },                    preloadImages: false,                    lazy: true,                    pagination: {                        el: '.js-swiper-' + swiperAlias + '-pagination',                        type: 'bullets',                        clickable: true                    }                });                mySwiper.on('slideChangeTransitionEnd', function () {                    $('.swiper-slide-duplicate').find('.js-open-modal').off().on('click', function (e) {                        e.preventDefault();                        var                            _this = $(this),                            $modalName = _this.attr('data-modal'),                            $modalToShow = $('#modal-' + $modalName),                            $modalTeamData = _this.siblings('.team__data').html();                        if (!$modalToShow.length) {                            console.log('Модальное окно с идентификатором #modal-' + $modalName + ' отстутвует на странице или указано не верно.');                        } else if ($modalToShow.length && $modalName === 'mteam') {                            $modalToShow.find('.mserv__inner').html($modalTeamData);                            $modalToShow.modal('show');                            window.modalOpened = true;                            $modalToShow.on('hidden.bs.modal', function () {                                window.modalOpened = false;                                $modalToShow.find('.mserv__inner').html('');                            });                        }                    });                });            };            var swiperHandler = function () {                if (!swiperInited && $('.' + swiperAlias).isInViewport()) {                    swiperInit();                    swiperInited = true;                }            };            swiperHandler();            $(window).on('resize scroll', function () {                swiperHandler();            });        }    })();    (function () {        var            swiperAlias = 'team',            swiperClass = '.js-swiper-container-' + swiperAlias,            swiperInited = false;        if ($('.' + swiperAlias).length) {            var swiperInit = function () {                var mySwiper = new Swiper(swiperClass, {                    loop: true,                    grabCursor: true,                    speed: 700,                    resistanceRatio: 0,                    slidesPerView: 3,                    spaceBetween: 30,                    navigation: {                        nextEl: '.js-swiper-' + swiperAlias + '-move-right',                        prevEl: '.js-swiper-' + swiperAlias + '-move-left',                    },                    preloadImages: false,                    lazy: true,                    pagination: {                        el: '.js-swiper-' + swiperAlias + '-pagination',                        type: 'bullets',                        clickable: true                    },                    breakpoints: {                        // when window width is <= 575                        575: {                            slidesPerView: 1                        },                        // when window width is <= 767px                        767: {                            slidesPerView: 2                        }                    }                });                mySwiper.on('slideChangeTransitionEnd', function () {                    $('.swiper-slide-duplicate').find('.js-open-modal').off().on('click', function (e) {                        e.preventDefault();                        var                            _this = $(this),                            $modalName = _this.attr('data-modal'),                            $modalToShow = $('#modal-' + $modalName),                            $modalTeamData = _this.siblings('.team__data').html();                        if (!$modalToShow.length) {                            console.log('Модальное окно с идентификатором #modal-' + $modalName + ' отстутвует на странице или указано не верно.');                        } else if ($modalToShow.length && $modalName === 'mteam') {                            $modalToShow.find('.mserv__inner').html($modalTeamData);                            $modalToShow.modal('show');                            window.modalOpened = true;                            $modalToShow.on('hidden.bs.modal', function () {                                window.modalOpened = false;                                $modalToShow.find('.mserv__inner').html('');                            });                        }                    });                });            };            swiperInit();            // var swiperHandler = function () {            //     if (!swiperInited && $('.' + swiperAlias).isInViewport()) {            //         swiperInit();            //         swiperInited = true;            //     }            // };            //            // swiperHandler();            //            // $(window).on('resize scroll', function () {            //     swiperHandler();            // });        }    })();    (function () {        var            swiperAlias = 'work-examples_gallery-v2',            swiperClass = '.js-swiper-container-' + swiperAlias,            swiperInited = false;        if ($('.' + swiperAlias).length) {            var swiperInit = function () {                var mySwiper = new Swiper(swiperClass, {                    loop: true,                    speed: 700,                    resistanceRatio: 0,                    slidesPerView: 4,                    navigation: {                        nextEl: '.js-swiper-' + swiperAlias + '-cright',                        prevEl: '.js-swiper-' + swiperAlias + '-cleft',                    },                    preloadImages: false,                    lazy: true,                    loadPrevNext: true,                    breakpoints: {                    // when window width is <= 767                    574: {                        slidesPerView: 1,                    },                    767: {                        slidesPerView: 2,                    },                    // when window width is <= 767                    1023: {                        slidesPerView: 3,                    }                }                });            };            var swiperHandler = function () {                if (!swiperInited && $('.' + swiperAlias).isInViewport()) {                    swiperInit();                    swiperInited = true;                }            };            swiperHandler();            $(window).on('resize scroll', function () {                swiperHandler();            });        }    })();    (function () {        var            swiperAlias = 'work-examples',            swiperClass = '.js-swiper-container-' + swiperAlias,            swiperInited = false;        if ($('.' + swiperAlias).length) {            var swiperInit = function () {                var mySwiper = new Swiper(swiperClass, {                    loop: true,                    grabCursor: true,                    speed: 700,                    resistanceRatio: 0,                    slidesPerView: 3,                    spaceBetween: 30,                    navigation: {                        nextEl: '.js-swiper-' + swiperAlias + '-move-right',                        prevEl: '.js-swiper-' + swiperAlias + '-move-left',                    },                    preloadImages: false,                    lazy: true,                    pagination: {                        el: '.js-swiper-' + swiperAlias + '-pagination',                        type: 'bullets',                        clickable: true                    },                    breakpoints: {                        // when window width is <= 575                        575: {                            slidesPerView: 1                        },                        // when window width is <= 767px                        767: {                            slidesPerView: 2                        }                    }                });                // mySwiper.on('slideChangeTransitionEnd', function () {                //                //     $('.swiper-slide-duplicate').find('.js-open-modal').off().on('click', function (e) {                //                //         e.preventDefault();                //                //         var                //             _this = $(this),                //             $modalName = _this.attr('data-modal'),                //             $modalToShow = $('#modal-' + $modalName),                //             $modalTeamData = _this.siblings('.team__data').html();                //                //         if (!$modalToShow.length) {                //                //             console.log('Модальное окно с идентификатором #modal-' + $modalName + ' отстутвует на странице или указано не верно.');                //                //         } else if ($modalToShow.length && $modalName === 'mteam') {                //                //             $modalToShow.find('.mserv__inner').html($modalTeamData);                //                //             $modalToShow.modal('show');                //             window.modalOpened = true;                //                //             $modalToShow.on('hidden.bs.modal', function () {                //                 window.modalOpened = false;                //                 $modalToShow.find('.mserv__inner').html('');                //             });                //         }                //     });                //                // });            };            swiperInit();            // var swiperHandler = function () {            //     if (!swiperInited && $('.' + swiperAlias).isInViewport()) {            //         swiperInit();            //         swiperInited = true;            //     }            // };            //            // swiperHandler();            //            // $(window).on('resize scroll', function () {            //     swiperHandler();            // });        }    })();    (function () {        var $lg = $('.work-examples_gallery-v4');        if ($lg.length === 0) return;        $lg.each(function () {            var _this = $(this);            _this.lightGallery({                selector: _this.find('[data-gallery-link]'),                hash: true,                galleryId: 1,                thumbnail: false,                share: false,                loop: true,                slideEndAnimatoin: false,                hideControlOnEnd: true,                download: false,                subHtmlSelectorRelative: true            });        });    })();    var wow = new WOW(        {            //boxClass: 'wow',                     // animated element css class (default is wow)            //animateClass: 'animated',     // animation css class (default is animated)            //offset: 0,                                 // distance to the element when triggering the animation (default is 0)            mobile: false,                         // trigger animations on mobile devices (default is true)            //live: true,                                // act on asynchronously loaded content (default is true)            // callback: function (box) {            //     // the callback is fired every time an animation is started            //     // the argument that is passed in is the DOM node being animated            // },            // scrollContainer: null // optional scroll container selector, otherwise use window        }    );    wow.init();    // (function(){    //    //     var $el = $('__________');    //    //     if ($el.length) {    //    //     }    //    // })();});